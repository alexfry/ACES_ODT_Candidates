#! /Applications/Nuke15.0v2/Nuke15.0v2.app/Contents/MacOS/libnuke-15.0.2.dylib -nx
version 15.0 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="25" w="2560" h="1470" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1897" stretch="1"/>
            <splitter orientation="2">
                <split size="851"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="599"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
                <page id="Scenegraph.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /Users/afry/GitHub/ACES_ODT_Candidates/ACES_ODT_Candidates_LUT_Bake_rev060.nk
 project_directory "\[python \{nuke.script_directory()\}]"
 lock_range true
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 OCIO_config custom
 customOCIOConfigPath /Users/afry/Documents/GitHub/OpenColorIO-Configs/aces_1.2/config.ocio
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
BackdropNode {
 inputs 0
 name BackdropNode1
 tile_color 0x8e388e00
 note_font_size 42
 xpos -734
 ypos 127
 bdwidth 406
 bdheight 212
}
BackdropNode {
 inputs 0
 name BackdropNode3
 tile_color 0x388e8e00
 label "Candidate CAMDRT"
 note_font_size 42
 xpos -43
 ypos 134
 bdwidth 1170
 bdheight 1017
}
Constant {
 inputs 0
 channels rgb
 color 1
 format "1024 1024 0 0 1024 1024 1 square_1K"
 name Constant1
 xpos 298
 ypos -148
}
Ramp {
 replace true
 p0 {0 0}
 p1 {1023 0}
 name Ramp1
 xpos 298
 ypos -62
}
Read {
 inputs 0
 file_type exr
 file /Users/afry/GitHub/ACES_ODT_SampleFrames/ACES_OT_VWG_SampleFrames/ACES_OT_VWG_SampleFrames.####.exr
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 last 78
 origlast 78
 origset true
 name Read2
 xpos 190
 ypos -147
}
Group {
 inputs 0
 name GamutToXYZ3
 tile_color 0xbd91c9ff
 label "APS4 to XYZ"
 xpos -718
 ypos 207
 addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
 addUserKnob {35 colorspace_presets l preset M {colorspace/ACES "knobs this \{rxy \{0.73470 0.26530\} gxy \{0.00000 1.00000\} bxy \{0.00010 -0.07700\} wxy \{0.32168 0.33767\} src_colorspace_name \{ACES\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ACEScg "knobs this \{rxy \{0.713 0.293\} gxy \{0.165 0.830\} bxy \{0.128 0.044\} wxy \{0.32168 0.33767\} src_colorspace_name \{ACEScg\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/Filmlight E-Gamut" "knobs this \{rxy \{0.8 0.3177\} gxy \{0.18 0.9\} bxy \{0.065 -0.0805\} wxy \{0.3127 0.329\} src_colorspace_name \{Filmlight E-Gamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/Rec709 "knobs this \{rxy \{0.64000 0.33000\} gxy \{0.30000 0.60000\} bxy \{0.15000 0.06000\} wxy \{0.3127 0.329\} src_colorspace_name \{Rec709\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/Rec2020 "knobs this \{rxy \{0.70800 0.29200\} gxy \{0.17000 0.79700\} bxy \{0.13100 0.04600\} wxy \{0.3127 0.329\} src_colorspace_name \{Rec2020\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/P3D60 "knobs this \{rxy \{0.68000 0.32000\} gxy \{0.26500 0.69000\} bxy \{0.15000 0.06000\} wxy \{0.32168 0.33767\} src_colorspace_name \{P3D60\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/P3D65 "knobs this \{rxy \{0.68000 0.32000\} gxy \{0.26500 0.69000\} bxy \{0.15000 0.06000\} wxy \{0.3127 0.329\} src_colorspace_name \{P3D65\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/P3DCI "knobs this \{rxy \{0.68000 0.32000\} gxy \{0.26500 0.69000\} bxy \{0.15000 0.06000\} wxy \{0.314 0.351\} src_colorspace_name \{P3DCI\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/Arri AlexaWideGamut" "knobs this \{rxy \{0.68400 0.31300\} gxy \{0.22100 0.84800\} bxy \{0.08610 -0.10200\} wxy \{0.3127 0.329\} src_colorspace_name \{Arri AlexaWideGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDDRAGONcolor "knobs this \{rxy \{0.753044222785 0.327830576682\} gxy \{0.299570228481 0.700699321956\} bxy \{0.079642066735 -0.0549379510888\} wxy \{0.321683187724 0.337673316035\} src_colorspace_name \{REDDRAGONcolor\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDDRAGONcolor2 "knobs this \{rxy \{0.753044491143 0.327831029513\} gxy \{0.299570490451 0.700699415614\} bxy \{0.145011584278 0.0510971250879\} wxy \{0.321683210353 0.337673610062\} src_colorspace_name \{REDDRAGONcolor2\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor "knobs this \{rxy \{0.699747001291 0.329046930313\} gxy \{0.304264039024 0.623641145129\} bxy \{0.134913961296 0.0347174412813\} wxy \{0.321683289449 0.337673447208\} src_colorspace_name \{REDcolor\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor2 "knobs this \{rxy \{0.878682510476 0.32496400741\} gxy \{0.300888714367 0.679054755791\} bxy \{0.0953986946056 -0.0293793268343\} wxy \{0.321683289449 0.337673447208\} src_colorspace_name \{REDcolor2\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor3 "knobs this \{rxy \{0.701181035906 0.329014155583\} gxy \{0.300600304652 0.683788834269\} bxy \{0.108154455624 -0.00868817578666\} wxy \{0.321683210353 0.337673610062\} src_colorspace_name \{REDcolor3\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor4 "knobs this \{rxy \{0.701180591892 0.329013699116\} gxy \{0.300600395529 0.683788824257\} bxy \{0.145331946229 0.0516168036226\} wxy \{0.321683289449 0.337673447208\} src_colorspace_name \{REDcolor4\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDWideGamutRGB "knobs this \{rxy \{0.780308 0.304253\} gxy \{0.121595 1.493994\} bxy \{0.095612 -0.084589\} wxy \{0.3127 0.329\} src_colorspace_name \{REDWideGamutRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/GoPro Protune Native" "knobs this \{rxy \{0.69848046 0.19302645\} gxy \{0.32955538 1.02459662\} bxy \{0.10844263 -0.03467857\} wxy \{0.3127 0.329\} src_colorspace_name \{GoPro Protune Native\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/CanonCinemaGamut "knobs this \{rxy \{0.74 0.27\} gxy \{0.17 1.14\} bxy \{0.08 -0.1\} wxy \{0.3127 0.329\} src_colorspace_name \{CanonCinemaGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/SonySGamut "knobs this \{rxy \{0.73 0.28\} gxy \{0.14 0.855\} bxy \{0.1 -0.05\} wxy \{0.3127 0.329\} src_colorspace_name \{SonySGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/SonySGamut3Cine "knobs this \{rxy \{0.766 0.275\} gxy \{0.225 0.8\} bxy \{0.089 -0.087\} wxy \{0.3127 0.329\} src_colorspace_name \{SonySGamut3Cine\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/PanasonicVGamut "knobs this \{rxy \{0.730 0.280\} gxy \{0.165 0.840\} bxy \{0.100 -0.030\} wxy \{0.3127 0.329\} src_colorspace_name \{PanasonicVGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/DJI D-Gamut" "knobs this \{rxy \{0.71 0.31\} gxy \{0.21 0.88\} bxy \{0.09 -0.08\} wxy \{0.3127 0.329\} src_colorspace_name \{DJI D-Gamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/Fujifilm F-Gamut" "knobs this \{rxy \{0.70800 0.29200\} gxy \{0.17000 0.79700\} bxy \{0.13100 0.04600\} wxy \{0.3127 0.329\} src_colorspace_name \{Fujifilm F-Gamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMDFilmV1 "knobs this \{rxy \{0.9173 0.2502\} gxy \{0.2833 1.7072\} bxy \{0.0856 -0.0708\} wxy \{0.3135 0.3305\} src_colorspace_name \{BMDFilmV1\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD4kFilmV1 "knobs this \{rxy \{0.7422 0.2859\} gxy \{0.4140 1.3035\} bxy \{0.0342 -0.0833\} wxy \{0.3135 0.3305\} src_colorspace_name \{BMD4kFilmV1\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD4kFilmV3 "knobs this \{rxy \{1.0625 0.3948\} gxy \{0.3689 0.7775\} bxy \{0.0956 -0.0332\} wxy \{0.3135 0.3305\} src_colorspace_name \{BMD4kFilmV3\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD46kFilmV1 "knobs this \{rxy \{0.9175 0.2983\} gxy \{0.2983 1.2835\} bxy \{0.0756 -0.0860\} wxy \{0.3127 0.329\} src_colorspace_name \{BMD46kFilmV1\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD46kFilmV3 "knobs this \{rxy \{0.8608 0.3689\} gxy \{0.3282 0.6156\} bxy \{0.0783 -0.0233\} wxy \{0.3127 0.329\} src_colorspace_name \{BMD46kFilmV3\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMDWideGamutV4 "knobs this \{rxy \{0.7177 0.3171\} gxy \{0.2280 0.8616\} bxy \{0.1006 -0.0820\} wxy \{0.3127 0.329\} src_colorspace_name \{BMDWideGamutV4\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/AdobeRGB\t" "knobs this \{rxy \{0.6400 0.3300\} gxy \{0.2100 0.7100\} bxy \{0.1500 0.0600\} wxy \{0.3127 0.329\} src_colorspace_name \{AdobeRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/AdobeWideGamutRGB "knobs this \{rxy \{0.7347 0.2653\} gxy \{0.1152 0.8264\} bxy \{0.1566 0.0177\} wxy \{0.3457 0.3585\} src_colorspace_name \{AdobeWideGamutRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ROMM "knobs this \{rxy \{7.34700000e-01 2.65300000e-01\} gxy \{1.59600000e-01  8.40400000e-01\} bxy \{3.66000000e-02 1.00000000e-04\} wxy \{0.3457 0.3585\} src_colorspace_name \{ROMM\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/RIMM "knobs this \{rxy \{7.34700000e-01 2.65300000e-01\} gxy \{1.59600000e-01 8.40400000e-01\} bxy \{3.66000000e-02 1.00000000e-04\} wxy \{0.3457 0.3585\} src_colorspace_name \{RIMM\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ERIMM "knobs this \{rxy \{7.34700000e-01 2.65300000e-01\} gxy \{1.59600000e-01 8.40400000e-01\} bxy \{3.66000000e-02 1.00000000e-04\} wxy \{0.3457 0.3585\} src_colorspace_name \{ERIMM\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ProPhotoRGB "knobs this \{rxy \{0.734699 0.265301\} gxy \{0.159597 0.840403\} bxy \{0.036598 0.000105\} wxy \{0.345704 0.358540\} src_colorspace_name \{ProPhotoRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/RusselRGB "knobs this \{rxy \{0.6900 0.3100\} gxy \{0.1800 0.7700\} bxy \{0.1000 0.0200\} wxy \{0.33243 0.34744\} src_colorspace_name \{RusselRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/SharpRGB "knobs this \{rxy \{0.6898 0.3206\} gxy \{0.0736 0.9003\} bxy \{0.1166 0.0374\} wxy \{0.33333333 0.33333333\} src_colorspace_name \{SharpRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/AppleRGB "knobs this \{rxy \{0.6250 0.3400\} gxy \{0.2800 0.5950\} bxy \{0.1550 0.0700\} wxy \{0.3127 0.329\} src_colorspace_name \{AppleRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BestRGB "knobs this \{rxy \{0.735191637630662 0.264808362369338\} gxy \{0.215336134453781 0.774159663865546\} bxy \{0.130122950819672 0.034836065573770\} wxy \{0.3457 0.3585\} src_colorspace_name \{BestRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/XYZ "knobs this \{rxy \{0 0\} gxy \{0 0\} bxy \{0 0\} wxy \{0 0\} src_colorspace_name \{XYZ\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()"}}
 addUserKnob {26 colorspace_chromaticities_label l " " T "<b>Colorspace Chromaticities</b>"}
 addUserKnob {12 rxy l r t "Red xy chromaticity coordinates in CIE 1931 colorspace."}
 rxy {0.96 0.37}
 addUserKnob {12 gxy l g t "Green xy chromaticity coordinates in CIE 1931 colorspace."}
 gxy {-0.03 1.1}
 addUserKnob {12 bxy l b t "Blue xy chromaticity coordinates in CIE 1931 colorspace."}
 bxy {{gxy.x} -0.09}
 addUserKnob {12 wxy l w t "Whitepoint xy chromaticity coordinates in CIE 1931 colorspace."}
 wxy {0.32168 0.33767}
 addUserKnob {1 src_colorspace_name l src}
 src_colorspace_name APS4
 addUserKnob {26 ""}
 addUserKnob {6 invert t "Invert direction of matrix: XYZtoRGB" +STARTLINE}
 addUserKnob {22 calculate_matrix l "Calculate Matrix" t "Calculate 3x3 matrix based on the specified colorspace chromaticities." T "import nuke\nfloat2 = nuke.math.Vector2\nfloat3 = nuke.math.Vector3\nfloat3x3 = nuke.math.Matrix3\nfloat4x4 = nuke.math.Matrix4\n\n\ndef get_primaries(node, dst=False):\n    # get xy coordinates from node\n    dst_pri = \['drxy', 'dgxy', 'dbxy', 'dwxy']\n    pri = \['rxy', 'gxy', 'bxy', 'wxy']\n    d = \{\}\n    for i, p in enumerate(pri):\n        if dst:\n            d\[p] = float2(node\[dst_pri\[i]].getValue()\[0], node\[dst_pri\[i]].getValue()\[1])\n        else:\n            d\[p] = float2(node\[p].getValue()\[0], node\[p].getValue()\[1])\n    return d\n\n\ndef RGBtoXYZ(xy, Y=1.0, inverse=False):\n    # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    # based on CtlColorSpace.cpp from the CTL source code : 77\n    # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    # param: Y - luminance of \"white\" - defaults to 1.0\n    # param: inverse - calculate XYZ to RGB instead\n    r = xy\['rxy']\n    g = xy\['gxy']\n    b = xy\['bxy']\n    w = xy\['wxy']\n\n    X = w.x * Y / w.y\n    Z = (1 - w.x - w.y) * Y / w.y\n\n    # Scale factors for matrix rows\n    d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y)\n\n    Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1) + \\\n            g.y * (X + Z))) / d\n    \n    Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1) +  \\\n            r.y * (X + Z))) / d\n\n    Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1) +  \\\n            r.y * (X + Z))) / d\n\n    # Assemble the matrix\n    M = float3x3()\n    M.set(  Sr * r.x, Sr * r.y, Sr * (1 - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1 - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1 - b.x - b.y))\n    if inverse:\n        M = M.inverse()\n        return M\n    else:\n        return M\n\n\ndef start():\n    node = nuke.thisNode()\n    \n    invert = node\['invert'].getValue()\n    label = node\['label']\n    \n    if invert:\n        # Convert from XYZ colorspace to Src RGB\n        mtx = RGBtoXYZ(get_primaries(node), inverse=True)\n        label.setValue('XYZ to \{0\}'.format(node\['src_colorspace_name'].getValue()))\n    else:\n        # Convert from Src RGB colorspace to XYZ\n        mtx = RGBtoXYZ(get_primaries(node))\n        label.setValue('\{0\} to XYZ'.format(node\['src_colorspace_name'].getValue()))\n\n    node\['matrix'].setValue((mtx))\n    \n   \n\nif __name__=='__main__':\n    start()" +STARTLINE}
 addUserKnob {22 create_matrix_node l "Create Matrix" t "Create ColorMatrix node with the current values." -STARTLINE T "node = nuke.thisNode()\nnode\['calculate_matrix'].execute()\nnuke.root().begin()\n_ = \[n.setSelected(False) for n in nuke.allNodes(recurseGroups=True)]\nm = nuke.createNode('ColorMatrix')\nm\['matrix'].setValue(node\['matrix'].getValue())\nm.setXYpos(node.xpos()-120, node.ypos())\nm\['label'].setValue(node\['label'].getValue())"}
 addUserKnob {41 matrix T ColorMatrix.matrix}
 addUserKnob {22 clear l Clear T "n = nuke.thisNode()\nn\['matrix'].setValue(\[1,0,0,0,1,0,0,0,1])\nn\['label'].setValue('')" +STARTLINE}
}
 Input {
  inputs 0
  name Input
  xpos -40
  ypos 206
 }
 ColorMatrix {
  matrix {
      {1.009929895 -0.01972960308 -0.03755422309}
      {0.3892438412 0.7234188318 -0.112662673}
      {-0.347163409 -0.04603575915 1.402024388}
    }
  name ColorMatrix
  xpos -40
  ypos 254
 }
 Output {
  name Output
  xpos -40
  ypos 302
 }
end_group
ColorMatrix {
 inputs 0
 matrix {
     {0.952552 0 9.36786e-05}
     {0.343966 0.728166 -0.0721325}
     {-3.86393e-08 0 1.00883}
   }
 name ColorMatrix8
 label "AP0 to XYZ"
 xpos -611
 ypos 263
}
Group {
 inputs 0
 name GamutToXYZ1
 tile_color 0xbd91c9ff
 label "APS4 to XYZ"
 xpos -612
 ypos 209
 addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
 addUserKnob {35 colorspace_presets l preset M {colorspace/ACES "knobs this \{rxy \{0.73470 0.26530\} gxy \{0.00000 1.00000\} bxy \{0.00010 -0.07700\} wxy \{0.32168 0.33767\} src_colorspace_name \{ACES\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ACEScg "knobs this \{rxy \{0.713 0.293\} gxy \{0.165 0.830\} bxy \{0.128 0.044\} wxy \{0.32168 0.33767\} src_colorspace_name \{ACEScg\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/Filmlight E-Gamut" "knobs this \{rxy \{0.8 0.3177\} gxy \{0.18 0.9\} bxy \{0.065 -0.0805\} wxy \{0.3127 0.329\} src_colorspace_name \{Filmlight E-Gamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/Rec709 "knobs this \{rxy \{0.64000 0.33000\} gxy \{0.30000 0.60000\} bxy \{0.15000 0.06000\} wxy \{0.3127 0.329\} src_colorspace_name \{Rec709\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/Rec2020 "knobs this \{rxy \{0.70800 0.29200\} gxy \{0.17000 0.79700\} bxy \{0.13100 0.04600\} wxy \{0.3127 0.329\} src_colorspace_name \{Rec2020\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/P3D60 "knobs this \{rxy \{0.68000 0.32000\} gxy \{0.26500 0.69000\} bxy \{0.15000 0.06000\} wxy \{0.32168 0.33767\} src_colorspace_name \{P3D60\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/P3D65 "knobs this \{rxy \{0.68000 0.32000\} gxy \{0.26500 0.69000\} bxy \{0.15000 0.06000\} wxy \{0.3127 0.329\} src_colorspace_name \{P3D65\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/P3DCI "knobs this \{rxy \{0.68000 0.32000\} gxy \{0.26500 0.69000\} bxy \{0.15000 0.06000\} wxy \{0.314 0.351\} src_colorspace_name \{P3DCI\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/Arri AlexaWideGamut" "knobs this \{rxy \{0.68400 0.31300\} gxy \{0.22100 0.84800\} bxy \{0.08610 -0.10200\} wxy \{0.3127 0.329\} src_colorspace_name \{Arri AlexaWideGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDDRAGONcolor "knobs this \{rxy \{0.753044222785 0.327830576682\} gxy \{0.299570228481 0.700699321956\} bxy \{0.079642066735 -0.0549379510888\} wxy \{0.321683187724 0.337673316035\} src_colorspace_name \{REDDRAGONcolor\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDDRAGONcolor2 "knobs this \{rxy \{0.753044491143 0.327831029513\} gxy \{0.299570490451 0.700699415614\} bxy \{0.145011584278 0.0510971250879\} wxy \{0.321683210353 0.337673610062\} src_colorspace_name \{REDDRAGONcolor2\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor "knobs this \{rxy \{0.699747001291 0.329046930313\} gxy \{0.304264039024 0.623641145129\} bxy \{0.134913961296 0.0347174412813\} wxy \{0.321683289449 0.337673447208\} src_colorspace_name \{REDcolor\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor2 "knobs this \{rxy \{0.878682510476 0.32496400741\} gxy \{0.300888714367 0.679054755791\} bxy \{0.0953986946056 -0.0293793268343\} wxy \{0.321683289449 0.337673447208\} src_colorspace_name \{REDcolor2\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor3 "knobs this \{rxy \{0.701181035906 0.329014155583\} gxy \{0.300600304652 0.683788834269\} bxy \{0.108154455624 -0.00868817578666\} wxy \{0.321683210353 0.337673610062\} src_colorspace_name \{REDcolor3\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDcolor4 "knobs this \{rxy \{0.701180591892 0.329013699116\} gxy \{0.300600395529 0.683788824257\} bxy \{0.145331946229 0.0516168036226\} wxy \{0.321683289449 0.337673447208\} src_colorspace_name \{REDcolor4\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/REDWideGamutRGB "knobs this \{rxy \{0.780308 0.304253\} gxy \{0.121595 1.493994\} bxy \{0.095612 -0.084589\} wxy \{0.3127 0.329\} src_colorspace_name \{REDWideGamutRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/GoPro Protune Native" "knobs this \{rxy \{0.69848046 0.19302645\} gxy \{0.32955538 1.02459662\} bxy \{0.10844263 -0.03467857\} wxy \{0.3127 0.329\} src_colorspace_name \{GoPro Protune Native\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/CanonCinemaGamut "knobs this \{rxy \{0.74 0.27\} gxy \{0.17 1.14\} bxy \{0.08 -0.1\} wxy \{0.3127 0.329\} src_colorspace_name \{CanonCinemaGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/SonySGamut "knobs this \{rxy \{0.73 0.28\} gxy \{0.14 0.855\} bxy \{0.1 -0.05\} wxy \{0.3127 0.329\} src_colorspace_name \{SonySGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/SonySGamut3Cine "knobs this \{rxy \{0.766 0.275\} gxy \{0.225 0.8\} bxy \{0.089 -0.087\} wxy \{0.3127 0.329\} src_colorspace_name \{SonySGamut3Cine\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/PanasonicVGamut "knobs this \{rxy \{0.730 0.280\} gxy \{0.165 0.840\} bxy \{0.100 -0.030\} wxy \{0.3127 0.329\} src_colorspace_name \{PanasonicVGamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/DJI D-Gamut" "knobs this \{rxy \{0.71 0.31\} gxy \{0.21 0.88\} bxy \{0.09 -0.08\} wxy \{0.3127 0.329\} src_colorspace_name \{DJI D-Gamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/Fujifilm F-Gamut" "knobs this \{rxy \{0.70800 0.29200\} gxy \{0.17000 0.79700\} bxy \{0.13100 0.04600\} wxy \{0.3127 0.329\} src_colorspace_name \{Fujifilm F-Gamut\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMDFilmV1 "knobs this \{rxy \{0.9173 0.2502\} gxy \{0.2833 1.7072\} bxy \{0.0856 -0.0708\} wxy \{0.3135 0.3305\} src_colorspace_name \{BMDFilmV1\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD4kFilmV1 "knobs this \{rxy \{0.7422 0.2859\} gxy \{0.4140 1.3035\} bxy \{0.0342 -0.0833\} wxy \{0.3135 0.3305\} src_colorspace_name \{BMD4kFilmV1\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD4kFilmV3 "knobs this \{rxy \{1.0625 0.3948\} gxy \{0.3689 0.7775\} bxy \{0.0956 -0.0332\} wxy \{0.3135 0.3305\} src_colorspace_name \{BMD4kFilmV3\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD46kFilmV1 "knobs this \{rxy \{0.9175 0.2983\} gxy \{0.2983 1.2835\} bxy \{0.0756 -0.0860\} wxy \{0.3127 0.329\} src_colorspace_name \{BMD46kFilmV1\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMD46kFilmV3 "knobs this \{rxy \{0.8608 0.3689\} gxy \{0.3282 0.6156\} bxy \{0.0783 -0.0233\} wxy \{0.3127 0.329\} src_colorspace_name \{BMD46kFilmV3\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BMDWideGamutV4 "knobs this \{rxy \{0.7177 0.3171\} gxy \{0.2280 0.8616\} bxy \{0.1006 -0.0820\} wxy \{0.3127 0.329\} src_colorspace_name \{BMDWideGamutV4\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" "colorspace/AdobeRGB\t" "knobs this \{rxy \{0.6400 0.3300\} gxy \{0.2100 0.7100\} bxy \{0.1500 0.0600\} wxy \{0.3127 0.329\} src_colorspace_name \{AdobeRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/AdobeWideGamutRGB "knobs this \{rxy \{0.7347 0.2653\} gxy \{0.1152 0.8264\} bxy \{0.1566 0.0177\} wxy \{0.3457 0.3585\} src_colorspace_name \{AdobeWideGamutRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ROMM "knobs this \{rxy \{7.34700000e-01 2.65300000e-01\} gxy \{1.59600000e-01  8.40400000e-01\} bxy \{3.66000000e-02 1.00000000e-04\} wxy \{0.3457 0.3585\} src_colorspace_name \{ROMM\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/RIMM "knobs this \{rxy \{7.34700000e-01 2.65300000e-01\} gxy \{1.59600000e-01 8.40400000e-01\} bxy \{3.66000000e-02 1.00000000e-04\} wxy \{0.3457 0.3585\} src_colorspace_name \{RIMM\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ERIMM "knobs this \{rxy \{7.34700000e-01 2.65300000e-01\} gxy \{1.59600000e-01 8.40400000e-01\} bxy \{3.66000000e-02 1.00000000e-04\} wxy \{0.3457 0.3585\} src_colorspace_name \{ERIMM\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/ProPhotoRGB "knobs this \{rxy \{0.734699 0.265301\} gxy \{0.159597 0.840403\} bxy \{0.036598 0.000105\} wxy \{0.345704 0.358540\} src_colorspace_name \{ProPhotoRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/RusselRGB "knobs this \{rxy \{0.6900 0.3100\} gxy \{0.1800 0.7700\} bxy \{0.1000 0.0200\} wxy \{0.33243 0.34744\} src_colorspace_name \{RusselRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/SharpRGB "knobs this \{rxy \{0.6898 0.3206\} gxy \{0.0736 0.9003\} bxy \{0.1166 0.0374\} wxy \{0.33333333 0.33333333\} src_colorspace_name \{SharpRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/AppleRGB "knobs this \{rxy \{0.6250 0.3400\} gxy \{0.2800 0.5950\} bxy \{0.1550 0.0700\} wxy \{0.3127 0.329\} src_colorspace_name \{AppleRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/BestRGB "knobs this \{rxy \{0.735191637630662 0.264808362369338\} gxy \{0.215336134453781 0.774159663865546\} bxy \{0.130122950819672 0.034836065573770\} wxy \{0.3457 0.3585\} src_colorspace_name \{BestRGB\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()" colorspace/XYZ "knobs this \{rxy \{0 0\} gxy \{0 0\} bxy \{0 0\} wxy \{0 0\} src_colorspace_name \{XYZ\}\}; python -exec nuke.thisNode().knob('calculate_matrix').execute()"}}
 addUserKnob {26 colorspace_chromaticities_label l " " T "<b>Colorspace Chromaticities</b>"}
 addUserKnob {12 rxy l r t "Red xy chromaticity coordinates in CIE 1931 colorspace."}
 rxy {0.96 0.37}
 addUserKnob {12 gxy l g t "Green xy chromaticity coordinates in CIE 1931 colorspace."}
 gxy {-0.03 1.1}
 addUserKnob {12 bxy l b t "Blue xy chromaticity coordinates in CIE 1931 colorspace."}
 bxy {{gxy.x} -0.09}
 addUserKnob {12 wxy l w t "Whitepoint xy chromaticity coordinates in CIE 1931 colorspace."}
 wxy {0.32168 0.33767}
 addUserKnob {1 src_colorspace_name l src}
 src_colorspace_name APS4
 addUserKnob {26 ""}
 addUserKnob {6 invert t "Invert direction of matrix: XYZtoRGB" +STARTLINE}
 addUserKnob {22 calculate_matrix l "Calculate Matrix" t "Calculate 3x3 matrix based on the specified colorspace chromaticities." T "import nuke\nfloat2 = nuke.math.Vector2\nfloat3 = nuke.math.Vector3\nfloat3x3 = nuke.math.Matrix3\nfloat4x4 = nuke.math.Matrix4\n\n\ndef get_primaries(node, dst=False):\n    # get xy coordinates from node\n    dst_pri = \['drxy', 'dgxy', 'dbxy', 'dwxy']\n    pri = \['rxy', 'gxy', 'bxy', 'wxy']\n    d = \{\}\n    for i, p in enumerate(pri):\n        if dst:\n            d\[p] = float2(node\[dst_pri\[i]].getValue()\[0], node\[dst_pri\[i]].getValue()\[1])\n        else:\n            d\[p] = float2(node\[p].getValue()\[0], node\[p].getValue()\[1])\n    return d\n\n\ndef RGBtoXYZ(xy, Y=1.0, inverse=False):\n    # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    # based on CtlColorSpace.cpp from the CTL source code : 77\n    # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    # param: Y - luminance of \"white\" - defaults to 1.0\n    # param: inverse - calculate XYZ to RGB instead\n    r = xy\['rxy']\n    g = xy\['gxy']\n    b = xy\['bxy']\n    w = xy\['wxy']\n\n    X = w.x * Y / w.y\n    Z = (1 - w.x - w.y) * Y / w.y\n\n    # Scale factors for matrix rows\n    d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y)\n\n    Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1) + \\\n            g.y * (X + Z))) / d\n    \n    Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1) +  \\\n            r.y * (X + Z))) / d\n\n    Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1) +  \\\n            r.y * (X + Z))) / d\n\n    # Assemble the matrix\n    M = float3x3()\n    M.set(  Sr * r.x, Sr * r.y, Sr * (1 - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1 - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1 - b.x - b.y))\n    if inverse:\n        M = M.inverse()\n        return M\n    else:\n        return M\n\n\ndef start():\n    node = nuke.thisNode()\n    \n    invert = node\['invert'].getValue()\n    label = node\['label']\n    \n    if invert:\n        # Convert from XYZ colorspace to Src RGB\n        mtx = RGBtoXYZ(get_primaries(node), inverse=True)\n        label.setValue('XYZ to \{0\}'.format(node\['src_colorspace_name'].getValue()))\n    else:\n        # Convert from Src RGB colorspace to XYZ\n        mtx = RGBtoXYZ(get_primaries(node))\n        label.setValue('\{0\} to XYZ'.format(node\['src_colorspace_name'].getValue()))\n\n    node\['matrix'].setValue((mtx))\n    \n   \n\nif __name__=='__main__':\n    start()" +STARTLINE}
 addUserKnob {22 create_matrix_node l "Create Matrix" t "Create ColorMatrix node with the current values." -STARTLINE T "node = nuke.thisNode()\nnode\['calculate_matrix'].execute()\nnuke.root().begin()\n_ = \[n.setSelected(False) for n in nuke.allNodes(recurseGroups=True)]\nm = nuke.createNode('ColorMatrix')\nm\['matrix'].setValue(node\['matrix'].getValue())\nm.setXYpos(node.xpos()-120, node.ypos())\nm\['label'].setValue(node\['label'].getValue())"}
 addUserKnob {41 matrix T ColorMatrix.matrix}
 addUserKnob {22 clear l Clear T "n = nuke.thisNode()\nn\['matrix'].setValue(\[1,0,0,0,1,0,0,0,1])\nn\['label'].setValue('')" +STARTLINE}
}
 Input {
  inputs 0
  name Input
  xpos -40
  ypos 206
 }
 ColorMatrix {
  matrix {
      {1.009929895 -0.01972960308 -0.03755422309}
      {0.3892438412 0.7234188318 -0.112662673}
      {-0.347163409 -0.04603575915 1.402024388}
    }
  name ColorMatrix
  xpos -40
  ypos 254
 }
 Output {
  name Output
  xpos -40
  ypos 302
 }
end_group
CMSTestPattern {
 inputs 0
 cube_size 65
 name CMSTestPattern1
 xpos -19
 ypos -146
}
Dot {
 name Dot6
 xpos 16
 ypos -51
}
set Nb128c200 [stack 0]
Dot {
 name Dot5
 xpos 84
 ypos -4
}
push $Nb128c200
Expression {
 temp_name0 cut_lin
 temp_expr0 0.0078125
 temp_name1 cut_log
 temp_expr1 0.155251141552511
 temp_name2 A
 temp_expr2 10.5402377416545
 temp_name3 B
 temp_expr3 0.0729055341958355
 expr0 r<=cut_log?(r-B)/A:pow(2,r*17.52-9.72)
 expr1 g<=cut_log?(g-B)/A:pow(2,g*17.52-9.72)
 expr2 b<=cut_log?(b-B)/A:pow(2,b*17.52-9.72)
 channel3 none
 name log2lin
 label ACEScct
 xpos -18
 ypos -7
}
Switch {
 inputs 2
 which {{master.inverseMode}}
 name Switch2
 xpos -18
 ypos 39
}
Dot {
 name Dot1
 xpos 16
 ypos 103
}
Dot {
 name Dot4
 xpos 15
 ypos 174
}
Reformat {
 type scale
 scale 0.1428571429
 filter impulse
 name Reformat1
 label "scale down 1/7 for speed"
 xpos -19
 ypos 192
}
set Nb301dc00 [stack 0]
Dot {
 name Dot3
 xpos 154
 ypos 284
}
push $Nb301dc00
ColorMatrix {
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 name ColorMatrix12
 label "APS4 to XYZ"
 xpos -19
 ypos 263
 disable true
}
Colorspace {
 colorspace_in CIE-XYZ
 illuminant_out ACES
 primary_out ACES
 name Colorspace4
 label "XYZ to AP0"
 xpos -19
 ypos 295
 disable true
}
Switch {
 inputs 2
 which {{master.inverseMode}}
 name Switch1
 xpos -19
 ypos 369
}
Dot {
 name Dot2
 xpos 15
 ypos 411
}
set Nb2fce800 [stack 0]
Group {
 name DRT_CAMv10
 label "Input: \[value encoding_in]  / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value white_limit] / \[value peak_luminance]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 17
 ypos 555
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {6 ap1_clamp l "AP1 clamp" t "Clamp input chromaticities to AP1 rendering space" +STARTLINE}
 ap1_clamp true
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {7 peak_luminance l "Peak Luminance" t "Target peak luminance in cd/m^2" R 0 1000}
 peak_luminance 100
 addUserKnob {6 monochrome t "Output monochrome image" +STARTLINE}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 applyInGamutExpansion l "apply in gamut expansion" t "Expands colorfulness to increase saturation" +STARTLINE}
 applyInGamutExpansion true
 addUserKnob {6 applyInGamutCompression l "apply in gamut compression" +STARTLINE}
 applyInGamutCompression true
 addUserKnob {6 applyReachClamp l "apply reach mode clamp" t "Clamp the chroma compressed result to the rendering space" +STARTLINE}
 addUserKnob {7 compress l "chroma compression" t "Chroma compression amount" R 2 10}
 compress 2.4
 addUserKnob {7 chroma_compress_fact l HDR t "Chroma compression scaling factor for SDR/HDR appearance match.  Smaller values will compress less as peak luminance goes highger, higher values compress more.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 2 6}
 chroma_compress_fact 3.3
 addUserKnob {7 chroma_expand l "chroma expansion" t "Chroma expansion to increase saturation in shadows and mid-tones" R 1 4}
 chroma_expand 1.3
 addUserKnob {7 chroma_expand_fact l HDR t "Chroma expansion scaling factor for SDR/HDR appearance match.  Smaller values will have more saturation as peak luminance goes highger, higher values will have less saturation.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 0.5 0.9}
 chroma_expand_fact 0.69
 addUserKnob {7 chroma_expand_thr l "chroma expansion threshold" t "Threshold for starting chroma expansion, meant to avoid expanding noise floor" R 0.5 1}
 chroma_expand_thr 0.5
 addUserKnob {4 ccReachPrimaries l "reach primaries" t "Primaries that define how far chroma compression and expansion reaches." M {"Chroma Compression Space" AP0-ACES AP1-ACES Rec.2020-D65 ""}}
 ccReachPrimaries AP1-ACES
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" "" "" ""}}
 et None
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 primaries_limit sRGB/Rec.709
 addUserKnob {4 white_limit l "white point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." -STARTLINE M {"ACES White" D65 "" "" ""}}
 white_limit D65
 addUserKnob {4 primaries_reach l "reach primaries" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "Spectral Locus" "Chroma Compression Space"}}
 primaries_reach AP1-ACES
 addUserKnob {6 reachCompressMode l "Reach Compression Mode" -STARTLINE}
 reachCompressMode true
 addUserKnob {4 boundryIntersectionMethod M {"Original Pekka" "Oct 19" "New From Nick" ""}}
 boundryIntersectionMethod "New From Nick"
 addUserKnob {41 DRT_CAM_Kernel_reachNick l "Use Nick method for reach" -STARTLINE T BlinkScript1.DRT_CAM_Kernel_reachNick}
 addUserKnob {41 DRT_CAM_Kernel_disableUpperHullGamma l disableUpperHullGamma T BlinkScript1.DRT_CAM_Kernel_disableUpperHullGamma}
 addUserKnob {7 upperHullGamma -STARTLINE R 0 2}
 upperHullGamma 1
 addUserKnob {41 DRT_CAM_Kernel_disableLowerHullGamma l disableLowerHullGamma T BlinkScript1.DRT_CAM_Kernel_disableLowerHullGamma}
 addUserKnob {7 lowerHullGamma -STARTLINE R 0 2}
 lowerHullGamma 1.14
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue and mid J.  higher cusps will closer to the cusp lightness, lower cusps will be closer to midJ" R 0.6 2}
 cusp_mid_blend 1.3
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic." R 1.1 2}
 focus_distance 1.35
 addUserKnob {7 focusdistscaling l HDR t "Focus distance scaling factor as peak luminance gets higher for SDR/HDR appearance match.  The projection gets less steep with higher projection\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 1 2}
 focusdistscaling 1.75
 addUserKnob {41 DRT_CAM_Kernel_disableFocusGain l disableFocusGain T BlinkScript1.DRT_CAM_Kernel_disableFocusGain}
 addUserKnob {7 focus_gain_blend l "focus gain blend" t "Blend between cusp J and limitJmax to determine the point where the focus gain is applied.\n\n0 = cuspJ\n1 = limitJmax"}
 focus_gain_blend 0.3
 addUserKnob {7 focusgain l "focus gain" -STARTLINE}
 focusgain 0.55
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.1 1.3 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.12
 addUserKnob {7 smoothJ l "smooth J" t "Smoothing scaling factor for cusp J" R 0 0.1}
 addUserKnob {7 smoothM l "smooth M" t "Smoothing scaling factor for cusp M" -STARTLINE R 0 0.25}
 smoothM 0.27
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 fit_white l "fit white" t "Scale the output so the maximum RGB channel for the creative white becomes 100%. Prevents clipping when the creative and encoding whites do not match." +STARTLINE}
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" -STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 invert {{master.inverseMode}}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {26 "" l " "}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v060.blink
  recompileCount 4092
  ProgramGroup 1
  KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 925e58f9470501a7d899ac9a2a52d4f33d9c5f59bd24740acef8f1ed9e380ede 2 \"src\" Read Point \"dst\" Write Point 97 \"encodingIn\" Int 1 AAAAAA== \"AP1Clamp\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"peakLuminance\" Float 1 AAAAAA== \"applyChromaCompression\" Bool 1 AA== \"applyInGamutExpansion\" Bool 1 AA== \"applyInGamutCompression\" Bool 1 AA== \"applyReachClamp\" Bool 1 AA== \"monochrome\" Bool 1 AA== \"chroma_compress\" Float 1 AAAAAA== \"Chroma Compress Factor\" Float 1 AACgQA== \"chroma_expand\" Float 1 AAAAAA== \"Chroma Expansion Factor\" Float 1 FK5HPw== \"chroma_expand_thr\" Float 1 AAAAAA== \"cc_et\" Int 1 AAAAAA== \"ccReach\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"primariesLimit\" Int 1 AAAAAA== \"whiteLimit\" Int 1 AAAAAA== \"primariesReach\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"focusAdjustGain\" Float 1 AAAAAA== \"focusGainBlend\" Float 1 AAAAAA== \"disableFocusGain\" Bool 1 AA== \"disableFocusDistScaling\" Bool 1 AA== \"focusDistScaling\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Reachcompressmode\" Bool 1 AA== \"reachNick\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"boundryIntersectionMethod\" Int 1 AAAAAA== \"disableUpperHullGamma\" Bool 1 AA== \"disableLowerHullGamma\" Bool 1 AA== \"lowerHullGamma\" Float 1 AAAAAA== \"upperHullGamma\" Float 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"Smoothing factor cusp J\" Float 1 rkdhPQ== \"Smoothing factor cust M\" Float 1 WmQ7Pg== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"fitWhite\" Bool 1 AA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 97 \"encodingIn\" 1 1 Default \"AP1Clamp\" 1 1 Default \"primariesIn\" 1 1 Default \"toneScaleMode\" 1 1 Default \"discountIlluminant_in\" 1 1 Default \"discountIlluminant_mid\" 1 1 Default \"discountIlluminant_out\" 1 1 Default \"HK_mode_in\" 1 1 Default \"HK_mode_mid\" 1 1 Default \"HK_mode_out\" 1 1 Default \"compressMode\" 1 1 Default \"referenceLuminance\" 1 1 Default \"viewingConditions\" 1 1 Default \"outputViewingConditions\" 1 1 Default \"applyTonecurve\" 1 1 Default \"peakLuminance\" 1 1 Default \"applyChromaCompression\" 1 1 Default \"applyInGamutExpansion\" 1 1 Default \"applyInGamutCompression\" 1 1 Default \"applyReachClamp\" 1 1 Default \"monochrome\" 1 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"cc_et\" 1 1 Default \"ccReach\" 1 1 Default \"crxy\" 2 1 Default \"cgxy\" 2 1 Default \"cbxy\" 2 1 Default \"cwxy\" 2 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"primariesReach\" 1 1 Default \"applyGamutCompression\" 1 1 Default \"cuspMidBlend\" 1 1 Default \"focusDistance\" 1 1 Default \"focusAdjustGain\" 1 1 Default \"focusGainBlend\" 1 1 Default \"disableFocusGain\" 1 1 Default \"disableFocusDistScaling\" 1 1 Default \"focusDistScaling\" 1 1 Default \"compressionFuncParams\" 4 1 Default \"sixAxisCompressionMode\" 1 1 Default \"compressionFuncParamsR\" 4 1 Default \"compressionFuncParamsY\" 4 1 Default \"compressionFuncParamsG\" 4 1 Default \"compressionFuncParamsC\" 4 1 Default \"compressionFuncParamsB\" 4 1 Default \"compressionFuncParamsM\" 4 1 Default \"Reachcompressmode\" 1 1 Default \"reachNick\" 1 1 Default \"Locuscompressmode\" 1 1 Default \"boundryIntersectionMethod\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"smoothCusps\" 1 1 Default \"smoothJ\" 1 1 Default \"smoothM\" 1 1 Default \"encodingOut\" 1 1 Default \"primariesOut\" 1 1 Default \"fitWhite\" 1 1 Default \"clampOutput\" 1 1 Default \"softclampOutput\" 1 1 Default \"clamp_thr\" 1 1 Default \"clamp_dist\" 1 1 Default \"invert\" 1 1 Default \"diagnosticMode\" 1 1 Default \"mmScaleFactor\" 1 1 Default \"daniele_n\" 1 1 Default \"daniele_n_r\" 1 1 Default \"daniele_g\" 1 1 Default \"daniele_c\" 1 1 Default \"daniele_c_d\" 1 1 Default \"daniele_w_g\" 1 1 Default \"daniele_t_1\" 1 1 Default \"daniele_r_hit_min\" 1 1 Default \"daniele_r_hit_max\" 1 1 Default \"catDataSelection\" 1 1 Default \"rxy\" 2 1 Default \"gxy\" 2 1 Default \"bxy\" 2 1 Default \"wxy\" 2 1 Default \"ra\" 1 1 Default \"ba\" 1 1 Default \"XYZ_w\" 3 1 Default \"XYZ_w_scaler\" 1 1 Default \"L_A\" 1 1 Default \"Y_b\" 1 1 Default \"L_B\" 3 1 Default \"userSurround\" 3 1 Default \"discount_illuminant\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default 52 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"compr\" Float 1 1 AAAAAA== \"sat\" Float 1 1 AAAAAA== \"sat_thr\" Float 1 1 AAAAAA== \"focusDist\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"model_gamma\" Float 1 1 AAAAAA== \"gamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutCuspTableReach\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutReachTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"LocusLimitMTable\" Float 1 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingIn;\n\n  // AP1 clamp\n  bool AP1Clamp;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesIn;\n\n  // Tonescale mode\n  // 0: Linear\n  // 1: Daniele Evo Curve\n  int toneScaleMode;\n\n  // Disable Degree of Adaptation\n  // This is only effective if the limit primaries have a non-D65 white point\n  // since the input conversion is assumed to be fully adapted\n  // and the output conversion does not apply a CAT\n  bool discountIlluminant_in;\n  bool discountIlluminant_mid;\n  bool discountIlluminant_out;\n\n  // Toggles for Hellwig 2022 specific params\n  bool HK_mode_in;\n  bool HK_mode_mid;\n  bool HK_mode_out;\n  int  compressMode;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int viewingConditions;\n  int outputViewingConditions;\n\n  // Toggle Tone Mapping\n  bool applyTonecurve;\n\n  // Target Peak Luminance\n  float peakLuminance;\n\n  // Toggle chroma compression\n  bool applyChromaCompression;\n  bool applyInGamutExpansion;\n  bool applyInGamutCompression;\n  bool applyReachClamp;\n  bool monochrome;\n\n  // Chroma compression params\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n  int   cc_et;\n  int   ccReach;\n  // xy coordinates for chroma compression gamut\n  float2 crxy;\n  float2 cgxy;\n  float2 cbxy;\n  float2 cwxy;\n\n  //\n  // Gamut Mapping Parameters\n  //\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Primaries of the Gamut reached by the gamut compressor\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: Spectral Locus\n  // 7: Chroma Compression Space\n  int primariesReach;\n\n  // Toggle Gamut Compression\n  bool applyGamutCompression;\n\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n  #define gamutCuspTableSize 360*1\n\n  // Blend Between Compressing towards\n  // Target Gamut Cusp Luminance (0.0)\n  // and Mid Luminance (1.0)\n  float cuspMidBlend;\n\n  // Focus distance of the compression focal point from the achromatic axis\n  float focusDistance;\n  float focusAdjustGain;\n  float focusGainBlend;\n  bool  disableFocusGain;\n  bool  disableFocusDistScaling;\n  float focusDistScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 compressionFuncParams;\n  bool   sixAxisCompressionMode;\n  float4 compressionFuncParamsR;\n  float4 compressionFuncParamsY;\n  float4 compressionFuncParamsG;\n  float4 compressionFuncParamsC;\n  float4 compressionFuncParamsB;\n  float4 compressionFuncParamsM;\n  bool   Reachcompressmode;\n  bool   reachNick;\n  bool   Locuscompressmode;\n\n  int   boundryIntersectionMethod;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n  float lowerHullGamma;\n  float upperHullGamma;\n\n  // How much the edges of the target RGB cube are smoothed when finding the gamut boundary\n  // in order to reduce visible contours at the gamut cusps\n  float smoothCusps;\n  float smoothJ; // Scaling factor for cusp J\n  float smoothM; // Scaling factor for cusp M\n\n  //\n  // Output Parameters\n  //\n\n  // Encoding of the Output Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingOut;\n\n  // Primaries of the Output Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesOut;\n\n  // Clamp output values to 0.0 - 1.0\n  bool  fitWhite;\n  bool  clampOutput;\n  bool  softclampOutput;\n  float clamp_thr;\n  float clamp_dist;\n\n  //\n  // Extra Parameters\n  //\n\n  // Toggle Inverse Transform\n  bool invert;\n  // Diagnostic path modes\n  int diagnosticMode;\n\n  // DanieleEvoCurve (ACES2 candidate) parameters\n  float mmScaleFactor;\n  float daniele_n;         // peak white\n  float daniele_n_r;       // Normalized white in nits (what 1.0 should be)\n  float daniele_g;         // surround / contrast\n  float daniele_c;         // scene-referred grey\n  float daniele_c_d;       // display-referred grey (in nits)\n  float daniele_w_g;       // grey change between different peak luminance\n  float daniele_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float daniele_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float daniele_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n  // Hellwig 2022 CAM params\n  // the kernel parameters\n\n  // 0 = Stock CAT16\n  // 1 = Thomas's custom primaries\n  // 2 = live from params below\n  int catDataSelection; // original vs modified CAT16 matrix\n  // xy coordinates for custom CAT matrix\n  float2 rxy;\n  float2 gxy;\n  float2 bxy;\n  float2 wxy;\n  float  ra;\n  float  ba;\n\n  // Input vars\n  float3 XYZ_w;\n  float  XYZ_w_scaler;\n  float  L_A;\n  float  Y_b;\n  float3 L_B;\n  float3 userSurround;\n  bool   discount_illuminant;\n  // Output vars\n  float L_A_out;\n  float Y_b_out;\n\nlocal:\n  // Hellwig 2022 constants\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n  float3x3 panlrcm;\n\n  float daniele_r_hit;\n  float daniele_m_0;\n  float daniele_m_1;\n  float daniele_u;\n  float daniele_m;\n  float daniele_w_i;\n  float daniele_c_t;\n  float daniele_g_ip;\n  float daniele_g_ipp2;\n  float daniele_w_2;\n  float daniele_s_2;\n  float daniele_u_2;\n  float daniele_m_2;\n\n  // Chroma compression pre-calculated constants\n  float compr;   // Compression\n  float sat;     // Saturation\n  float sat_thr; // Threshold to start expanding saturation\n\n  // Gamut mapper constants\n  float focusDist; // FocusDistance for projection\n\n  // ST2084 vars\n  float st2084_m_1;\n  float st2084_m_2;\n  float st2084_c_1;\n  float st2084_c_2;\n  float st2084_c_3;\n  float st2084_m_1_d;\n  float st2084_m_2_d;\n  float st2084_L_p;\n\n  // using the float3x3 type to store the array of 6 coefficients\n  // because Blink does not support generic array assignments\n\n  // matrix vars\n  float3x3 identity_matrix;\n\n  float3x3 XYZ_to_RGB_input;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 XYZ_to_RGB_reach;\n  float3x3 XYZ_to_RGB_output;\n\n  float3x3 RGB_to_XYZ_input;\n  float3x3 RGB_to_XYZ_limit;\n  float3x3 RGB_to_XYZ_reach;\n  float3x3 RGB_to_XYZ_output;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n\n  // white points\n  float3 inWhite;\n  float3 outWhite;\n  float3 limitWhite;\n\n  // the maximum RGB value of the limiting gamut\n  float boundaryRGB;\n\n  // the maximum lightness value of the limiting gamut\n  float limitJmax;\n\n  // Middle gray J\n  float midJ;\n\n  // Hellwig model's gamma (1 / cz)\n  float model_gamma;\n\n  // the 'tempTableUnsorted' table is populated\n  // in increments of H of the limiting gamut HSV space starting at H=0.0\n  // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n  // the entries are then wrap-around shifted\n  // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n  // both tables need to be declared here since temporary array variables\n  // in the init() fuction seem to crash Nuke on some systems\n  float3 gamutCuspTable\[gamutCuspTableSize + 1];\n  float3 gamutCuspTableReach\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutReachTable\[gamutCuspTableSize + 1];\n  float2 gamutGammas\[gamutCuspTableSize + 1];\n  float  LocusLimitMTable\[gamutCuspTableSize + 1];\n\n  void define()\n  \{\n    defineParam(chroma_compress_fact, \"Chroma Compress Factor\", 5.0f);\n    defineParam(chroma_expand_fact, \"Chroma Expansion Factor\", 0.78f);\n    defineParam(smoothJ, \"Smoothing factor cusp J\", 0.055f);\n    defineParam(smoothM, \"Smoothing factor cust M\", 0.183f);\n  \}\n\n  // Functions used in ACES 2.0 candidate CAM DRT\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  inline float spow(float base, float exponent)\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ;\n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b)\n\n    // float a_p = sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else\n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if (base < 0.0f && exponent != floor(exponent))\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent);\n    \}\n  \}\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  float3 float3spow(float3 base, float exponent)\n  \{\n    return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  // \"safe\" div\n  float sdiv(float a, float b)\n  \{\n    if (b == 0.0f)\n    \{\n      return 0.0f;\n    \}\n    return a / b;\n  \}\n\n  float degree_of_adaptation(float F, float L_A)\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float  ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d   = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  // basic 3D hypotenuse function, does not deal with under/overflow\n  inline float hypot_float3(float3 xyz)\n  \{\n    return length(xyz);\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float r = R / C;\n    r       = r * r;\n    r       = sqrt(4.0f / r + 1.0f) - 1.0f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float t = 0.5f + sqrt(s * s + r * r / 4.0f);\n    t       = C / t; // t is always >= 0.5f\n\n    xyz_temp = xyz_temp * t + C;\n\n    return xyz_temp;\n  \}\n\n  float3 uncompress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float t = C / R;\n    t       = t - 0.5f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float r = 2 * sqrt(fabs(t * t - s * s)) + 1;\n    r       = sqrt(fabs(r * r - 1));\n    if (r == 0.0)\n      return xyz;\n    r = C * 2 / r;\n\n    xyz_temp = xyz_temp * r + C;\n\n    return xyz_temp;\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float hr)\n  \{\n    return -0.160 * cos(hr) + 0.132 * cos(2 * hr) - 0.405 * sin(hr) + 0.080 * sin(2 * hr) + 0.792;\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n      Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n      Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? spow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n    const float3 F_L_RGB = float3pow(F_L / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, float F_L)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV(float3 RGB)\n  \{\n    float cmax  = max(RGB.x, max(RGB.y, RGB.z));\n    float cmin  = min(RGB.x, min(RGB.y, RGB.z));\n    float delta = cmax - cmin;\n\n    float3 HSV;\n    HSV.x = delta == 0.0f ? 0.0f\n      : cmax == RGB.x     ? (fmod((RGB.y - RGB.z) / delta + 6.0f, 6.0f)) / 6.0f\n      : cmax == RGB.y     ? (((RGB.z - RGB.x) / delta + 2.0f) / 6.0f)\n                          : (((RGB.x - RGB.y) / delta + 4.0f) / 6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a          = JM.y / (focusJ * slope_gain);\n    float b          = 0.0f;\n    float c          = 0.0f;\n    float intersectJ = 0.0f;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      intersectJ = 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      intersectJ = 2.0f * c / (-b + root);\n    \}\n\n    return intersectJ;\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (viewingConditions == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (viewingConditions == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (viewingConditions == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (viewingConditions == 3)\n    \{\n      // Pull from external input\n      newSurround = userSurround;\n    \}\n    return newSurround;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear(float v)\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084(float v)\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f / 2.4f);\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f / 2.6f);\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ          = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh          = XYZ_to_JMh(XYZ, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n    // First matrix to limiting gamut for clamping\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_limit, luminanceXYZ);\n\n    if (fitWhite)\n    \{\n      // Scale to fit maximum creative white channel value\n      float3 creativeWhiteXYZ = vector_dot(RGB_to_XYZ_limit, float3(1.0f, 1.0f, 1.0f)); // TODO: these scaling parameters could be precalculated\n      float3 creativeWhiteRGB = vector_dot(XYZ_to_RGB_output, creativeWhiteXYZ);\n      luminanceRGB *= 1.0f / max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    \}\n\n    if (softclampOutput)\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    if (clampOutput)\n    \{\n      // Clamp to between zero and peak luminance\n      luminanceRGB = clamp3(luminanceRGB, 0.0f, peakLuminance);\n    \}\n\n    // Matrix to output (encoding) gamut (eventually concatenate to a single matrix)\n    luminanceRGB = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceRGB);\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3(encodingOut, luminanceRGB);\n\n    return outputRGB;\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 RGB_to_JMh(const float3 RGB, float3 refWhite, const float3x3& matrix)\n  \{\n    const float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    const float3 XYZ          = vector_dot(matrix, luminanceRGB);\n    const float3 JMh          = XYZ_to_JMh(XYZ, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the given primaries\n  float3 JMh_to_RGB(float3 JMh, float3 refWhite, const float3x3& matrix)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    float3 luminanceRGB = vector_dot(matrix, luminanceXYZ);\n    float3 RGB          = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    XYZ_w = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    if (compressMode)\n    \{\n      RGB_c = compress_bjorn(RGB_c);\n    \}\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n    if (compressMode)\n    \{\n      RGB_a = uncompress_bjorn(RGB_a);\n    \}\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    float R_a = RGB_a.x;\n    float G_a = RGB_a.y;\n    float B_a = RGB_a.z;\n    float a   = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    float b   = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    float hr = atan2(b, a);\n    float h  = wrap_to_360(degrees(hr));\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    float R_a2 = RGB_a.x;\n    float G_a2 = RGB_a.y;\n    float B_a2 = RGB_a.z;\n\n    float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w, surround.y * z);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *chroma* :math:`C`.\n    float C = 35.0f * M / A_w;\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // float s = 100.0f * sdiv(M, Q);\n  \n    if (HK_mode)\n    \{\n      // # *Helmholtz–Kohlrausch* Effect Extension.\n      J = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n      // float Q_HK = (2.0f / surround.y) * (J / 100.0f) * A_w;\n    \}\n    \n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    float J = JMh.x;\n    float M = JMh.y;\n    float h = JMh.z;\n    XYZ_w   = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n    float A_w  = ra * R_aw + G_aw + ba * B_aw;\n\n    float hr = radians(h);\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    float C = (M * 35) / A_w;\n    if (HK_mode)\n    \{\n      J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n    \}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    float P_p_1 = 43.0f * surround.z;\n    float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    float gamma = M / P_p_1;\n    float a     = gamma * cos(hr);\n    float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    if (compressMode)\n    \{\n      RGB_a = compress_bjorn(RGB_a);\n    \}\n\n    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n    if (compressMode)\n    \{\n      RGB_c = uncompress_bjorn(RGB_c);\n    \}\n\n    // # Step 6\n    float3 RGB = RGB_c / D_RGB;\n\n    // # Step 7\n    float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  int find_upper_hue_in_table(float h, float3 table\[], int table_size)\n  \{\n    int low_i  = 0;\n    int high_i = table_size - 1;\n    int i      = hue_position_in_uniform_table(h, table_size);\n\n    while (low_i + 1 < high_i)\n    \{\n      if (h > table\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float2 cuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n    if (h <= gamutCuspTable\[0].z)\n    \{\n      lo   = gamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = gamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > gamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = gamutCuspTable\[high_i - 1];\n      hi = gamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 cuspFromTableLocus(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float lo = LocusLimitMTable\[i_lo];\n    const float hi = LocusLimitMTable\[i_lo + 1];\n\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    const float cuspJ = 69;\n    const float cuspM = lerp(lo, hi, t);\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (h <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  float cReachFromTable(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = cgamutReachTable\[i_lo];\n    const float3 hi = cgamutReachTable\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y       = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float  hr     = radians(h);\n\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + hr) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float _h   = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n             + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    return JMcusp.y * e_t;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f);\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = cusp_with_eccentricity_factor(JMh.z);\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!invert)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      if (applyInGamutCompression)\n      \{\n        // Normalize M with the rendering space cusp M\n        M /= Mnorm;\n\n        // Expand the colorfulness by running the toe function in reverse.  The goal is to\n        // expand less saturated colors less and more saturated colors more.  The expansion\n        // increases saturation in the shadows and mid-tones but not in the highlights.\n        // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n        // the toe less aggressive near black to reduce the expansion of noise.\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n        // Compress the colorfulness.  The goal is to compress less saturated colors more and\n        // more saturated colors less, especially in the highlights.  This step creates the\n        // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n        // mostly affects highlights and mid-tones, and does not compress shadows.\n        M = toe(M, limit, nJ * compr, snJ, 0);\n\n        // Clamp M to the rendering space\n        if (applyReachClamp)\n          M = min(limit, M);\n\n        // Denormalize\n        M *= Mnorm;\n      \}\n    \}\n    else\n    \{\n      if (applyInGamutCompression)\n      \{\n        M /= Mnorm;\n        M = toe(M, limit, nJ * compr, snJ, 1);\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n        M *= Mnorm;\n      \}\n\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    if (AP1Clamp)\n    \{\n      luminanceRGB   = vector_dot(XYZ_to_AP1, luminanceXYZ);\n      luminanceRGB.x = max(0.0f, luminanceRGB.x);\n      luminanceRGB.y = max(0.0f, luminanceRGB.y);\n      luminanceRGB.z = max(0.0f, luminanceRGB.z);\n      luminanceXYZ   = vector_dot(AP1_to_XYZ, luminanceRGB);\n    \}\n\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n    else\n    \{\n      return JMh;\n    \}\n  \}\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB     = luminanceToEncoding3(encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\nfloat Y_to_Hellwig_J(float Y, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n    return sign(Y) * 100.0f * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, surround.y * z);\n  \}\n\n  float Hellwig_J_to_Y(float J, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float A = A_w * pow(fabs(J) / 100.0f, 1.0f / (surround.y * z));\n\n    return sign(J) * 100.0f / F_L * pow((27.13f * A) / (400.0f - A), 1.0f / 0.42f);\n  \}\n\n  float3 forwardTonescale(float3 inputJMh)\n  \{\n    float3 outputJMh;\n    float3 surround    = viewingConditionsToSurround(viewingConditions);\n    float  linear      = Hellwig_J_to_Y(inputJMh.x, surround) / referenceLuminance;\n    float  luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if (toneScaleMode == 1)\n    \{\n      luminanceTS = daniele_evo_fwd(luminanceTS) * mmScaleFactor;\n    \}\n\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, surround);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    if (applyTonecurve)\n    \{\n      outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n      outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    if (monochrome)\n    \{\n      outputJMh.y = 0.0f;\n    \}\n\n    return outputJMh;\n  \}\n\n  float3 inverseTonescale(float3 JMh)\n  \{\n    float3 tonemappedJMh = JMh;\n    float3 surround = viewingConditionsToSurround(viewingConditions);\n\n    if (!applyTonecurve && !applyChromaCompression)\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n\n    float luminance = Hellwig_J_to_Y(tonemappedJMh.x, surround);\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if (toneScaleMode == 1)\n    \{\n      linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n      linear = luminance;\n    \}\n\n    linear = linear * referenceLuminance;\n\n    if (applyTonecurve)\n    \{\n      float untonemappedJ = Y_to_Hellwig_J(linear, surround);\n      untonemappedColourJMh = float3(untonemappedJ, tonemappedJMh.y, tonemappedJMh.z);\n    \}\n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return untonemappedColourJMh;\n  \}\n\n  float2 hueDependantHullGammas(float h)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(h, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    return lerp(gamutGammas\[i_lo], gamutGammas\[i_lo + 1], t);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float gamma_top, float gamma_bottom)\n  \{\n    float2 JM_source = float2(JMh_s.x, JMh_s.y);\n\n    float slope = 0.0f;\n\n    float s = max(0.000001f, smoothness);\n    JM_cusp.x *= 1.0f + smoothJ * s; // J\n    JM_cusp.y *= 1.0f + smoothM * s; // M\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, 1 / gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp)\n      * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), 1.0f / gamma_top) / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, s);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'.\n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.05f, cusp.x / limitJmax), 0.0001f);\n    cusp.y *= 1.0f + 0.18f * s;\n    cusp.x *= 1.0f + 0.07f * s;\n\n    // Line below the cusp is curved with model_gamma\n    float toJ_gamma   = cusp.x * spow(to.x / cusp.x, model_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, model_gamma);\n    t0                = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float2 findCurveIntersection(float c, float2 cusp, float m, float h)\n  \{\n    // based on this desmos plot https://www.desmos.com/calculator/pcsovzirqa\n    float xc = cusp.y;\n    float yc = cusp.x;\n    float f  = 1.0;\n    float mf = m * f;\n    float xi = 1.0f;\n    float g1 = 1.0f / model_gamma;\n    float g2 = hueDependantHullGammas(h).y;\n\n    if (m * xc + c < yc)\n    \{\n      // below cusp\n      xi = spow((1 - mf), (g1 - 1)) * ((yc * spow((c / yc), (1.0 / g1))) / (yc / xc - m));\n    \}\n    else\n    \{\n      // above cusp\n      xi =\n        spow((1 + mf), ((g2 - 1))) * (xc * (limitJmax - yc) * spow(((limitJmax - c) / (limitJmax - yc)), (1 / g2)) / (m * xc + limitJmax - yc));\n    \}\n    float yi = (m * xi) + c;\n    if (yi > limitJmax)\n    \{\n      yi = limitJmax;\n      xi = 0.0f;\n    \}\n    return float2(yi, xi);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus     = cuspFromTableLocus(h);\n    float  cuspTarget100 = cuspLocus.y;\n    float  cuspTarget    = cuspTarget100 * pow((Jmh.x / 100.0f), model_gamma);\n    float  difference    = cuspLocus.y / cuspTarget;\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float3 getReachBoundry(float3 Jmh)\n  \{\n    const float h = Jmh.z;\n\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = gamutCuspTableReach\[i_lo];\n    const float3 hi = gamutCuspTableReach\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n\n    const float reachMaxM = lerp(lo.y, hi.y, t);\n    if (reachNick)\n    \{\n      float2 JMcusp     = cuspFromTable(Jmh.z);\n      float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain = limitJmax * focusDist * getFocusGain(Jmh.x, JMcusp.x);\n      float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n      float  slope;\n      if (intersectJ < focusJ)\n      \{\n        slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      else\n      \{\n        slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      float boundaryNick = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n      return float3(Jmh.x, boundaryNick, Jmh.z);\n    \}\n    float cuspTarget = reachMaxM * pow((Jmh.x / limitJmax), model_gamma);\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n\n    if (Reachcompressmode)\n    \{\n      if (primariesReach != 6) // All of the primary based reach values\n      \{\n        // use primary based reach\n        float locusMax   = getReachBoundry(Jmh).y;\n        float difference = max(1.0001f, locusMax / Jmh.y);\n        float threshold  = max(compressionFuncParams.x, 1.0f / difference);\n        return float4(threshold, difference, difference, compressionFuncParams.w);\n      \}\n      else\n      \{\n        // use locus based reach\n        float locusMax   = getLocusBoundry(Jmh).y;\n        float difference = locusMax / Jmh.y;\n        return float4(compressionFuncParams.x, difference, difference, compressionFuncParams.w);\n      \}\n    \}\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h >= angleR && h < angleY)\n      \{\n        lerpVal = (h - angleR) / (angleY - angleR);\n        return lerp(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h >= angleY && h < angleG)\n      \{\n        lerpVal = (h - angleY) / (angleG - angleY);\n        return lerp(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h >= angleG && h < angleC)\n      \{\n        lerpVal = (h - angleG) / (angleC - angleG);\n        return lerp(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h >= angleC && h < angleB)\n      \{\n        lerpVal = (h - angleC) / (angleB - angleC);\n        return lerp(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h >= angleB && h < angleM)\n      \{\n        lerpVal = (h - angleB) / (angleM - angleB);\n        return lerp(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h >= angleM && h < angleR + 360.0f)\n      \{\n        lerpVal = (h - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h < angleR)\n      \{\n        lerpVal = (h + 360.0f - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  float getFocusGain(float J, float cuspJ)\n  \{\n    if (disableFocusGain)\n      return 1.0f;\n\n    float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J > thr)\n    \{\n      // Approximate inverse required above threshold\n      float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n      return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n    \}\n    else\n    \{\n      // Analytic inverse possible below cusp\n      return 1.0f;\n    \}\n  \}\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    if (disableFocusGain)\n      return compressGamut2(JMh, invert, JMh.x);\n\n    if (!invert)\n    \{\n      return compressGamut2(JMh, 0, JMh.x);\n    \}\n    else\n    \{\n      float2 JMcusp = cuspFromTable(JMh.z);\n      float  Jx     = JMh.x;\n\n      // Analytic inverse below threshold\n      if (Jx <= lerp(JMcusp.x, limitJmax, focusGainBlend))\n        return compressGamut2(JMh, 1, Jx);\n\n      // Approximation above\n      Jx = compressGamut2(JMh, 1, Jx).x;\n      return compressGamut2(JMh, 1, Jx);\n    \}\n  \}\n\n  float3 compressGamut2(float3 JMh, int invert, float Jx)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp       = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDist * JMcusp.y);\n    float a      = max(0.001f, Mratio / focusJ);\n    float b0     = 1.0f - Mratio;\n    float b1     = -(1.0f + Mratio + (a * limitJmax));\n    float b      = project_from.x < focusJ ? b0 : b1;\n    float c0     = -project_from.x;\n    float c1     = project_from.x + limitJmax * Mratio;\n    float c      = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0       = sqrt(b * b - 4 * a * c);\n    float J1       = (-b - J0) / (2 * a);\n    J0             = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    float slope_gain = limitJmax * focusDist * getFocusGain(Jx, JMcusp.x);\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = float2(1.0f, 1.0f);\n    if (boundryIntersectionMethod == 0)\n    \{\n      // Original method implemented by Pekka\n      JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    \}\n    else if (boundryIntersectionMethod == 1)\n    \{\n      // Alternate method shown in Oct 19 meeting\n      float m    = (JMh.x - projectJ) / JMh.y;\n      JMboundary = findCurveIntersection(JMh.x, JMcusp, 0.0f, JMh.z);\n    \}\n    else if (boundryIntersectionMethod == 2)\n    \{\n      const float2 gammas      = hueDependantHullGammas(JMh.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      JMboundary               = float2(nickBoundryReturn.x, nickBoundryReturn.y);\n      project_to               = float2(nickBoundryReturn.z, 0.0f);\n      projectJ                 = nickBoundryReturn.z;\n    \}\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams;\n    if (reachNick)\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMboundary.x, JMboundary.y, JMh.z));\n    \}\n    else\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x, JMboundary.y, JMh.z));\n    \}\n\n    if (!Reachcompressmode)\n      interpolatedCompressionFuncParams.x =\n        1.0f / lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n\n    float lowerMlimit = 0.0001f; // Testing a small value here\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)  // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                                    lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                                    interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 20)\n    \{\n      // return focus point\n      return float3(project_to.x, project_to.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n                            ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit  = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0    = daniele_n / daniele_n_r;\n    daniele_m_1    = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u      = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m      = daniele_m_1 / daniele_u;\n    daniele_w_i    = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t    = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip   = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2    = daniele_c / daniele_g_ipp2;\n    daniele_s_2    = daniele_w_2 * daniele_m_1;\n    daniele_u_2    = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2    = daniele_m_1 / daniele_u_2;\n\n    // 1.0f / (c * z)\n    model_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n\n    // Chroma compression scaling for HDR/SDR appearance match\n    float log_peak = log10(daniele_n / daniele_n_r);\n    compr          = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    sat            = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak);\n    sat_thr        = chroma_expand_thr / daniele_n;\n\n    // Gamut mapper focus distance scaling with peak luminance for\n    // HDR/SDR appearance match.  The projection gets slightly less\n    // steep with higher peak luminance.\n    // https://www.desmos.com/calculator/bnfhjcq5vf\n    if (!disableFocusDistScaling)\n      focusDist = focusDistance + focusDistance * focusDistScaling * log_peak;\n    else\n      focusDist = focusDistance;\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    float CAT_CAT16_data\[] = \{\n      0.401288, 0.650173, -0.051461, -0.250268, 1.204414, 0.045854, -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[] = \{\n      0.656619, 0.342071, 0.00131062, -0.222571, 1.10658, 0.115987, -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[] = \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374,\n      238.0180511, 235.4039917, 233.010849,  230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215,\n      190.9799347, 184.005127,  177.7472992, 172.2332611, 166.6447754, 161.64534,   156.9872284, 152.6203003, 148.3236084, 144.2987976,\n      140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861,\n      114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853,  105.188797,  103.6860809, 102.2319641, 100.8348923, 99.51873779,\n      98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951,  92.03639984, 91.15013885, 90.27630615, 89.43255615,\n      88.63536072, 87.8986969,  87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547,\n      83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156,\n      80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702,\n      80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481,  81.901474,   82.20778656, 82.67211151,\n      83.1408844,  83.62628174, 84.0898056,  84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481,\n      88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783,  94.64561462, 95.68405914, 96.84765625,\n      97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031,\n      113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034,\n      137.8343048, 140.7224121, 143.7820892, 147.23909,   150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272,\n      171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255,\n      199.4234161, 201.3786011, 203.1474609, 205.016037,  206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686,\n      215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463,\n      213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355,\n      195.217453,  193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165,\n      174.445282,  172.4908905, 170.5744934, 168.5490723, 166.459259,  164.4333649, 162.5092621, 160.4579468, 158.491806,  156.6880035,\n      155.0045624, 153.295166,  151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602,\n      139.225174,  137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328,   128.7269897,\n      127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358,  120.9004822,\n      120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039,\n      116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118,\n      114.8510284, 114.8482819, 114.848465,  114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528,  115.7195816,\n      115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586,\n      119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077,  124.071022,  124.9082108, 125.74823,   126.6865311,\n      127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252,  130.1131287, 130.5647278,\n      130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609,  136.6136017, 137.5203552,\n      138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586,\n      150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551,\n      168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373,\n      192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452,  206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306,\n      220.6668701, 223.364151,  226.2115479, 228.9524536, 231.5583954, 234.405304,  237.0275879, 239.5091705, 242.0047455, 242.0177155,\n      244.8230133\};\n\n    // populate the input primaries matrix\n    RGB_to_XYZ_input = generate_RGB_to_XYZ_matrix(primariesIn);\n    XYZ_to_RGB_input = RGB_to_XYZ_input.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(1); // AP1 == 1\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix;\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n    if (whiteLimit == 0)\n    \{\n      limitWhiteForMatrix = float2(0.32168f, 0.33767f);\n    \}\n    else if (whiteLimit == 1)\n    \{\n      limitWhiteForMatrix = float2(0.3127f, 0.3290f);\n    \}\n    else\n    \{\n      limitWhiteForMatrix = float2(0.333333f, 0.333333f);\n    \}\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001, -0.077);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, 0);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    RGB_to_XYZ_reach = generate_RGB_to_XYZ_matrix(primariesReach);\n    XYZ_to_RGB_reach = RGB_to_XYZ_reach.invert();\n\n    RGB_to_XYZ_output = generate_RGB_to_XYZ_matrix(primariesOut);\n    XYZ_to_RGB_output = RGB_to_XYZ_output.invert();\n\n    float3 white(1.0f, 1.0f, 1.0f);\n    inWhite    = vector_dot(RGB_to_XYZ_input, white);\n    outWhite   = vector_dot(RGB_to_XYZ_output, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = peakLuminance / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n      CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n      CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n      CAT_CAT16 = RGBPrimsToXYZMatrix(rxy, gxy, bxy, wxy, 1.0f, 1);\n    \}\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    generate_panlrcm();\n\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    limitJmax = RGB_to_JMh(float3(1.0f), limitWhite, RGB_to_XYZ_limit).x;\n\n    // Cusp table for chroma compression gamut\n    float3x3 RGB_to_XYZ_cgReach;\n    if (ccReach == 0) // Chroma Compression Space (primaries defined in kernel params)\n    \{\n      RGB_to_XYZ_cgReach = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 0);\n\n    \}\n    else if (ccReach == 1)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(0);\n    \}\n    else if (ccReach == 2)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(1);\n    \}\n    else\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(3);\n    \}\n    const float3x3 XYZ_to_RGB_cgReach = RGB_to_XYZ_cgReach.invert();\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, inWhite, RGB_to_XYZ_cgReach);\n    initialise_reach_cusp_table(cgamutReachTable, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_cgReach);\n\n    // With gamut mapper reach mode 7, use the chroma compression reach space with the\n    // gamut mapper.\n    if (primariesReach == 7)\n      XYZ_to_RGB_reach = XYZ_to_RGB_cgReach;\n\n    // Cusp table for limiting gamut\n    initialise_cusp_table(gamutCuspTable, gamutCuspTableSize, limitWhite, RGB_to_XYZ_limit);\n    initialise_reach_cusp_table(gamutCuspTableReach, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_reach);\n\n    midJ = XYZ_to_JMh(inWhite * daniele_c_t * mmScaleFactor, inWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid,\n                      HK_mode_mid)\n             .x;\n\n    initialise_upper_hull_gamma();\n    initialise_lower_hull_gamma();\n  \}\n\n  void initialise_cusp_table(float3 output_table\[], const int table_size, float3 refWhite, const float3x3& matrix)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      tempTableUnsorted\[i] = RGB_to_JMh(RGB, refWhite, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 tableUnsorted\[], const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 output_table\[], const int table_size, const float limitJ, float3 refWhite, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_RGB(float3(limitJ, high, hue), refWhite, matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_RGB(float3(limitJ, sampleM, hue), refWhite, matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, min(1.0, cuspMidBlend - (JMcusp.x / limitJmax)));\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, topGamma, lowerHullGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma()\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        gamutGammas\[i].x =  upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      gamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].x = gamutGammas\[0].x;\n   \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float slope_gain = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n\n      const float3 approxLimit     = findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax,\n                                                                   slope_gain, smoothCusps, upperHullGamma, bottomGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma()\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        gamutGammas\[i].y = lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      gamutGammas\[i].y = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].y = gamutGammas\[0].y;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n    float3 diagnostic;\n\n    if (invert)\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh           = inverseTonescale(tonemappedJMh);\n      diagnostic    = JMh_to_input_RGB(JMh);\n    \}\n    else\n    \{\n      JMh           = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n      diagnostic    = JMh_to_output_RGB(compressedJMh);\n    \}\n\n    if (diagnosticMode == 1 || diagnosticMode == 6)\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if (invert)\n      \{\n        diagnostic = JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic = JMh;\n      \}\n    \}\n    else if (diagnosticMode == 2 || diagnosticMode == 99)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if (diagnosticMode == 3 || diagnosticMode == 5)\n    \{\n      diagnostic = compressedJMh;\n    \}\n    else if (diagnosticMode == 4 || diagnosticMode == 7)\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB     = JMh_to_output_RGB(srcRGB);\n      diagnostic = dstRGB;\n    \}\n    else if (diagnosticMode == 8)\n    \{\n      diagnostic = inWhite;\n    \}\n    else if (diagnosticMode == 9)\n    \{\n      diagnostic = outWhite;\n    \}\n    else if (diagnosticMode == 10)\n    \{\n      diagnostic = limitWhite;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      const float2 JMcusp = cuspFromTable(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      const float2 JMcusp = cuspFromTableLocus(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundary\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundary\n      diagnostic = getReachBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 20)\n    \{\n      // output JMFocus\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 21)\n    \{\n      // output JMFocus\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).y, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 22)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float slope_gain = limitJmax * focusDist;\n      diagnostic       = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 23)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic         = float3(approxLimit.x, approxLimit.y, srcRGB.z);\n    \}\n\n    else if (diagnosticMode == 24)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      float3 newLimitRGB = JMh_to_RGB(float3(approxLimit.x, approxLimit.y, srcRGB.z), limitWhite, XYZ_to_RGB_limit);\n      diagnostic         = newLimitRGB;\n    \}\n\n    else if (diagnosticMode == 25)\n    \{\n      float2 JMcusp            = cuspFromTable(srcRGB.z);\n      float  focusJ            = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain        = limitJmax * focusDist * getFocusGain(JMh.x, JMcusp.x);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(srcRGB, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic               = float3(srcRGB.x, nickBoundryReturn.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 26)\n    \{\n      // XYZ back to luminance RGB\n      float3 JMh = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n      diagnostic = vector_dot(XYZ_to_RGB_limit, JMh);\n    \}\n    else if (diagnosticMode == 27)\n    \{\n      // output\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).x, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 28)\n    \{\n      // output\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      diagnostic    = findGamutBoundaryIntersection(srcRGB, JMcusp, lerp(JMcusp.x, midJ, cuspMidBlend), limitJmax, 10000.0f, 0.0f,\n                                                    gammas.x, gammas.y);\n    \}\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    ////// FORWARD PATHWAY\n\n    else if (diagnosticMode == 100)\n    \{\n      // display encoding to display linear\n      diagnostic      = encodingToLuminance3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 101)\n    \{\n      // convert to linear XYZ luminance values\n      diagnostic = vector_dot(RGB_to_XYZ_input, srcRGB);\n    \}\n    else if (diagnosticMode == 102)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 105)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 106)\n    \{\n      // display luminance XYZ to display linear RGB\n      diagnostic = vector_dot(XYZ_to_RGB_output, srcRGB);\n    \}\n    else if (diagnosticMode == 107)\n    \{\n      // display linear RGB to display encoded RGB\n      diagnostic = luminanceToEncoding3(encodingOut, srcRGB);\n    \}\n\n    ////// INVERSE PATHWAY\n\n    else if (diagnosticMode == 200)\n    \{\n      // output display encoded RGB to display linear RGB\n      diagnostic = encodingToLuminance3(encodingOut, srcRGB);\n    \}\n    else if (diagnosticMode == 201)\n    \{\n      // output display linear RGB to output display linear XYZ\n      diagnostic = vector_dot(RGB_to_XYZ_output, srcRGB);\n    \}\n    else if (diagnosticMode == 202)\n    \{\n      // output XYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 203)\n    \{\n      // uncompress gamut\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 204)\n    \{\n      // inverse tonescale in JMh\n      diagnostic = inverseTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 205)\n    \{\n      // inverted JMh back to XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 206)\n    \{\n      // XYZ back to luminance RGB\n      diagnostic = vector_dot(XYZ_to_RGB_input, srcRGB);\n    \}\n    else if (diagnosticMode == 207)\n    \{\n      // luminance RGB to input encoding RGB\n      diagnostic = luminanceToEncoding3(encodingIn, srcRGB);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_AP1Clamp {{parent.ap1_clamp}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_peakLuminance {{parent.peak_luminance}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_applyInGamutExpansion {{parent.applyInGamutExpansion}}
  DRT_CAM_Kernel_applyInGamutCompression {{parent.applyInGamutCompression}}
  DRT_CAM_Kernel_applyReachClamp {{parent.applyReachClamp}}
  DRT_CAM_Kernel_monochrome {{parent.monochrome}}
  DRT_CAM_Kernel_chroma_compress {{parent.compress}}
  "DRT_CAM_Kernel_Chroma Compress Factor" {{parent.chroma_compress_fact}}
  DRT_CAM_Kernel_chroma_expand {{parent.chroma_expand}}
  "DRT_CAM_Kernel_Chroma Expansion Factor" {{parent.chroma_expand_fact}}
  DRT_CAM_Kernel_chroma_expand_thr {{parent.chroma_expand_thr}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_ccReach {{parent.ccReachPrimaries}}
  DRT_CAM_Kernel_crxy {0.7347 0.2653}
  DRT_CAM_Kernel_cgxy {0.12 0.88}
  DRT_CAM_Kernel_cbxy {0.08 -0.04}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_whiteLimit {{parent.white_limit}}
  DRT_CAM_Kernel_primariesReach {{parent.primaries_reach}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_focusAdjustGain {{parent.focusgain}}
  DRT_CAM_Kernel_focusGainBlend {{parent.focus_gain_blend}}
  DRT_CAM_Kernel_focusDistScaling {{parent.focusdistscaling}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r x272 -1.75} {parent.compression_params.g} {parent.compression_params.b} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR x272 0.21} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Reachcompressmode {{parent.reachCompressMode}}
  DRT_CAM_Kernel_reachNick true
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_boundryIntersectionMethod {{boundryIntersectionMethod}}
  DRT_CAM_Kernel_disableLowerHullGamma true
  DRT_CAM_Kernel_lowerHullGamma {{lowerHullGamma}}
  DRT_CAM_Kernel_upperHullGamma {{parent.upperHullGamma}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  "DRT_CAM_Kernel_Smoothing factor cusp J" {{parent.smoothJ}}
  "DRT_CAM_Kernel_Smoothing factor cust M" {{parent.smoothM}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_fitWhite {{parent.fit_white}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.peak_luminance}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.8336 0.1735}
  DRT_CAM_Kernel_gxy {2.3854 -1.4659}
  DRT_CAM_Kernel_bxy {0.087 -0.125}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Reformat {
 type scale
 scale 7
 filter impulse
 name Reformat2
 label "scale up 7x"
 xpos 17
 ypos 652
}
set Nb028d000 [stack 0]
Group {
 name SDR_to_HDR3
 xpos -309
 ypos 812
}
 Input {
  inputs 0
  name Input1
  xpos 692
  ypos -182
 }
 Colorspace {
  colorspace_in 2.40
  primary_out Rec.2020
  name Colorspace1
  xpos 692
  ypos -142
 }
 Multiply {
  value 100
  name Multiply1
  xpos 692
  ypos -118
 }
 Colorspace {
  colorspace_out st2084
  name Colorspace2
  xpos 692
  ypos -86
 }
 Output {
  name Output1
  xpos 692
  ypos 14
 }
end_group
push $Nb028d000
Dot {
 name Dot7
 xpos 51
 ypos 684
}
set Nb2fb8000 [stack 0]
Expression {
 expr0 isnan(r)?0:r
 expr1 isnan(g)?0:g
 expr2 isnan(b)?0:b
 name killNan
 xpos 63
 ypos 701
}
Clamp {
 minimum -65535
 maximum 65535
 name Clamp6
 xpos 63
 ypos 725
}
Colorspace {
 illuminant_in ACES
 primary_in ACES
 colorspace_out CIE-XYZ
 name Colorspace3
 label "XYZ to AP0"
 xpos 63
 ypos 761
 disable true
}
ColorMatrix {
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 invert true
 name ColorMatrix1
 label "APS4 to XYZ"
 xpos 63
 ypos 793
 disable true
}
Expression {
 temp_name0 cut_lin
 temp_expr0 0.0078125
 temp_name1 cut_log
 temp_expr1 0.155251141552511
 temp_name2 A
 temp_expr2 10.5402377416545
 temp_name3 B
 temp_expr3 0.0729055341958355
 expr0 r<=cut_lin?A*r+B:(log(r)/log(2)+9.72)/17.52
 expr1 g<=cut_lin?A*g+B:(log(g)/log(2)+9.72)/17.52
 expr2 b<=cut_lin?A*b+B:(log(b)/log(2)+9.72)/17.52
 channel3 none
 name lin2log
 label ACEScct
 xpos 63
 ypos 825
}
push $Nb2fb8000
Switch {
 inputs 2
 which {{master.inverseMode}}
 name Switch3
 xpos 17
 ypos 873
}
Group {
 name Write_ResolveACES_ODT_LUT12
 label "\[python nuke.thisNode().knob('cubePath').evaluate().split('/').pop(-1)]"
 xpos 17
 ypos 1003
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate CAMDRT
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target Rec709
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate_\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template_AP0.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template_AP0.fltransform
 addUserKnob {1 dctlColorspaceBufferTag}
 dctlColorspaceBufferTag Rec709_100nits_dim
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev060/ACES2 Candidate CAMDRT rev060 Rec709_inverse.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 283
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $Nb2fce800
Group {
 name DRT_CAMv2
 label "Input: \[value encoding_in]  / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value white_limit] / \[value peak_luminance]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 148
 ypos 559
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {6 ap1_clamp l "AP1 clamp" t "Clamp input chromaticities to AP1 rendering space" +STARTLINE}
 ap1_clamp true
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {7 peak_luminance l "Peak Luminance" t "Target peak luminance in cd/m^2" R 0 1000}
 peak_luminance 100
 addUserKnob {6 monochrome t "Output monochrome image" +STARTLINE}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 applyInGamutExpansion l "apply in gamut expansion" t "Expands colorfulness to increase saturation" +STARTLINE}
 applyInGamutExpansion true
 addUserKnob {6 applyInGamutCompression l "apply in gamut compression" +STARTLINE}
 applyInGamutCompression true
 addUserKnob {6 applyReachClamp l "apply reach mode clamp" t "Clamp the chroma compressed result to the rendering space" +STARTLINE}
 addUserKnob {7 compress l "chroma compression" t "Chroma compression amount" R 2 10}
 compress 2.4
 addUserKnob {7 chroma_compress_fact l HDR t "Chroma compression scaling factor for SDR/HDR appearance match.  Smaller values will compress less as peak luminance goes highger, higher values compress more.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 2 6}
 chroma_compress_fact 3.3
 addUserKnob {7 chroma_expand l "chroma expansion" t "Chroma expansion to increase saturation in shadows and mid-tones" R 1 4}
 chroma_expand 1.3
 addUserKnob {7 chroma_expand_fact l HDR t "Chroma expansion scaling factor for SDR/HDR appearance match.  Smaller values will have more saturation as peak luminance goes highger, higher values will have less saturation.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 0.5 0.9}
 chroma_expand_fact 0.69
 addUserKnob {7 chroma_expand_thr l "chroma expansion threshold" t "Threshold for starting chroma expansion, meant to avoid expanding noise floor" R 0.5 1}
 chroma_expand_thr 0.5
 addUserKnob {4 ccReachPrimaries l "reach primaries" t "Primaries that define how far chroma compression and expansion reaches." M {"Chroma Compression Space" AP0-ACES AP1-ACES Rec.2020-D65 ""}}
 ccReachPrimaries AP1-ACES
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" "" "" ""}}
 et None
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 primaries_limit sRGB/Rec.709
 addUserKnob {4 white_limit l "white point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." -STARTLINE M {"ACES White" D65 "" "" ""}}
 white_limit D65
 addUserKnob {4 primaries_reach l "reach primaries" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "Spectral Locus" "Chroma Compression Space"}}
 primaries_reach AP1-ACES
 addUserKnob {6 reachCompressMode l "Reach Compression Mode" -STARTLINE}
 reachCompressMode true
 addUserKnob {4 boundryIntersectionMethod M {"Original Pekka" "Oct 19" "New From Nick" ""}}
 boundryIntersectionMethod "New From Nick"
 addUserKnob {41 DRT_CAM_Kernel_reachNick l "Use Nick method for reach" -STARTLINE T BlinkScript1.DRT_CAM_Kernel_reachNick}
 addUserKnob {41 DRT_CAM_Kernel_disableUpperHullGamma l disableUpperHullGamma T BlinkScript1.DRT_CAM_Kernel_disableUpperHullGamma}
 addUserKnob {7 upperHullGamma -STARTLINE R 0 2}
 upperHullGamma 1
 addUserKnob {41 DRT_CAM_Kernel_disableLowerHullGamma l disableLowerHullGamma T BlinkScript1.DRT_CAM_Kernel_disableLowerHullGamma}
 addUserKnob {7 lowerHullGamma -STARTLINE R 0 2}
 lowerHullGamma 1.14
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue and mid J.  higher cusps will closer to the cusp lightness, lower cusps will be closer to midJ" R 0.6 2}
 cusp_mid_blend 1.3
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic." R 1.1 2}
 focus_distance 1.35
 addUserKnob {7 focusdistscaling l HDR t "Focus distance scaling factor as peak luminance gets higher for SDR/HDR appearance match.  The projection gets less steep with higher projection\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 1 2}
 focusdistscaling 1.75
 addUserKnob {41 DRT_CAM_Kernel_disableFocusGain l disableFocusGain T BlinkScript1.DRT_CAM_Kernel_disableFocusGain}
 addUserKnob {7 focus_gain_blend l "focus gain blend" t "Blend between cusp J and limitJmax to determine the point where the focus gain is applied.\n\n0 = cuspJ\n1 = limitJmax"}
 focus_gain_blend 0.3
 addUserKnob {7 focusgain l "focus gain" -STARTLINE}
 focusgain 0.55
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.1 1.3 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.12
 addUserKnob {7 smoothJ l "smooth J" t "Smoothing scaling factor for cusp J" R 0 0.1}
 addUserKnob {7 smoothM l "smooth M" t "Smoothing scaling factor for cusp M" -STARTLINE R 0 0.25}
 smoothM 0.27
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out ST2084
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out Rec.2020-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 fit_white l "fit white" t "Scale the output so the maximum RGB channel for the creative white becomes 100%. Prevents clipping when the creative and encoding whites do not match." +STARTLINE}
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" -STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 invert {{master.inverseMode}}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {26 "" l " "}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v060.blink
  recompileCount 4092
  ProgramGroup 1
  KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 925e58f9470501a7d899ac9a2a52d4f33d9c5f59bd24740acef8f1ed9e380ede 2 \"src\" Read Point \"dst\" Write Point 97 \"encodingIn\" Int 1 AAAAAA== \"AP1Clamp\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"peakLuminance\" Float 1 AAAAAA== \"applyChromaCompression\" Bool 1 AA== \"applyInGamutExpansion\" Bool 1 AA== \"applyInGamutCompression\" Bool 1 AA== \"applyReachClamp\" Bool 1 AA== \"monochrome\" Bool 1 AA== \"chroma_compress\" Float 1 AAAAAA== \"Chroma Compress Factor\" Float 1 AACgQA== \"chroma_expand\" Float 1 AAAAAA== \"Chroma Expansion Factor\" Float 1 FK5HPw== \"chroma_expand_thr\" Float 1 AAAAAA== \"cc_et\" Int 1 AAAAAA== \"ccReach\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"primariesLimit\" Int 1 AAAAAA== \"whiteLimit\" Int 1 AAAAAA== \"primariesReach\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"focusAdjustGain\" Float 1 AAAAAA== \"focusGainBlend\" Float 1 AAAAAA== \"disableFocusGain\" Bool 1 AA== \"disableFocusDistScaling\" Bool 1 AA== \"focusDistScaling\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Reachcompressmode\" Bool 1 AA== \"reachNick\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"boundryIntersectionMethod\" Int 1 AAAAAA== \"disableUpperHullGamma\" Bool 1 AA== \"disableLowerHullGamma\" Bool 1 AA== \"lowerHullGamma\" Float 1 AAAAAA== \"upperHullGamma\" Float 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"Smoothing factor cusp J\" Float 1 rkdhPQ== \"Smoothing factor cust M\" Float 1 WmQ7Pg== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"fitWhite\" Bool 1 AA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 97 \"encodingIn\" 1 1 Default \"AP1Clamp\" 1 1 Default \"primariesIn\" 1 1 Default \"toneScaleMode\" 1 1 Default \"discountIlluminant_in\" 1 1 Default \"discountIlluminant_mid\" 1 1 Default \"discountIlluminant_out\" 1 1 Default \"HK_mode_in\" 1 1 Default \"HK_mode_mid\" 1 1 Default \"HK_mode_out\" 1 1 Default \"compressMode\" 1 1 Default \"referenceLuminance\" 1 1 Default \"viewingConditions\" 1 1 Default \"outputViewingConditions\" 1 1 Default \"applyTonecurve\" 1 1 Default \"peakLuminance\" 1 1 Default \"applyChromaCompression\" 1 1 Default \"applyInGamutExpansion\" 1 1 Default \"applyInGamutCompression\" 1 1 Default \"applyReachClamp\" 1 1 Default \"monochrome\" 1 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"cc_et\" 1 1 Default \"ccReach\" 1 1 Default \"crxy\" 2 1 Default \"cgxy\" 2 1 Default \"cbxy\" 2 1 Default \"cwxy\" 2 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"primariesReach\" 1 1 Default \"applyGamutCompression\" 1 1 Default \"cuspMidBlend\" 1 1 Default \"focusDistance\" 1 1 Default \"focusAdjustGain\" 1 1 Default \"focusGainBlend\" 1 1 Default \"disableFocusGain\" 1 1 Default \"disableFocusDistScaling\" 1 1 Default \"focusDistScaling\" 1 1 Default \"compressionFuncParams\" 4 1 Default \"sixAxisCompressionMode\" 1 1 Default \"compressionFuncParamsR\" 4 1 Default \"compressionFuncParamsY\" 4 1 Default \"compressionFuncParamsG\" 4 1 Default \"compressionFuncParamsC\" 4 1 Default \"compressionFuncParamsB\" 4 1 Default \"compressionFuncParamsM\" 4 1 Default \"Reachcompressmode\" 1 1 Default \"reachNick\" 1 1 Default \"Locuscompressmode\" 1 1 Default \"boundryIntersectionMethod\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"smoothCusps\" 1 1 Default \"smoothJ\" 1 1 Default \"smoothM\" 1 1 Default \"encodingOut\" 1 1 Default \"primariesOut\" 1 1 Default \"fitWhite\" 1 1 Default \"clampOutput\" 1 1 Default \"softclampOutput\" 1 1 Default \"clamp_thr\" 1 1 Default \"clamp_dist\" 1 1 Default \"invert\" 1 1 Default \"diagnosticMode\" 1 1 Default \"mmScaleFactor\" 1 1 Default \"daniele_n\" 1 1 Default \"daniele_n_r\" 1 1 Default \"daniele_g\" 1 1 Default \"daniele_c\" 1 1 Default \"daniele_c_d\" 1 1 Default \"daniele_w_g\" 1 1 Default \"daniele_t_1\" 1 1 Default \"daniele_r_hit_min\" 1 1 Default \"daniele_r_hit_max\" 1 1 Default \"catDataSelection\" 1 1 Default \"rxy\" 2 1 Default \"gxy\" 2 1 Default \"bxy\" 2 1 Default \"wxy\" 2 1 Default \"ra\" 1 1 Default \"ba\" 1 1 Default \"XYZ_w\" 3 1 Default \"XYZ_w_scaler\" 1 1 Default \"L_A\" 1 1 Default \"Y_b\" 1 1 Default \"L_B\" 3 1 Default \"userSurround\" 3 1 Default \"discount_illuminant\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default 52 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"compr\" Float 1 1 AAAAAA== \"sat\" Float 1 1 AAAAAA== \"sat_thr\" Float 1 1 AAAAAA== \"focusDist\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"model_gamma\" Float 1 1 AAAAAA== \"gamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutCuspTableReach\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutReachTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"LocusLimitMTable\" Float 1 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingIn;\n\n  // AP1 clamp\n  bool AP1Clamp;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesIn;\n\n  // Tonescale mode\n  // 0: Linear\n  // 1: Daniele Evo Curve\n  int toneScaleMode;\n\n  // Disable Degree of Adaptation\n  // This is only effective if the limit primaries have a non-D65 white point\n  // since the input conversion is assumed to be fully adapted\n  // and the output conversion does not apply a CAT\n  bool discountIlluminant_in;\n  bool discountIlluminant_mid;\n  bool discountIlluminant_out;\n\n  // Toggles for Hellwig 2022 specific params\n  bool HK_mode_in;\n  bool HK_mode_mid;\n  bool HK_mode_out;\n  int  compressMode;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int viewingConditions;\n  int outputViewingConditions;\n\n  // Toggle Tone Mapping\n  bool applyTonecurve;\n\n  // Target Peak Luminance\n  float peakLuminance;\n\n  // Toggle chroma compression\n  bool applyChromaCompression;\n  bool applyInGamutExpansion;\n  bool applyInGamutCompression;\n  bool applyReachClamp;\n  bool monochrome;\n\n  // Chroma compression params\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n  int   cc_et;\n  int   ccReach;\n  // xy coordinates for chroma compression gamut\n  float2 crxy;\n  float2 cgxy;\n  float2 cbxy;\n  float2 cwxy;\n\n  //\n  // Gamut Mapping Parameters\n  //\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Primaries of the Gamut reached by the gamut compressor\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: Spectral Locus\n  // 7: Chroma Compression Space\n  int primariesReach;\n\n  // Toggle Gamut Compression\n  bool applyGamutCompression;\n\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n  #define gamutCuspTableSize 360*1\n\n  // Blend Between Compressing towards\n  // Target Gamut Cusp Luminance (0.0)\n  // and Mid Luminance (1.0)\n  float cuspMidBlend;\n\n  // Focus distance of the compression focal point from the achromatic axis\n  float focusDistance;\n  float focusAdjustGain;\n  float focusGainBlend;\n  bool  disableFocusGain;\n  bool  disableFocusDistScaling;\n  float focusDistScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 compressionFuncParams;\n  bool   sixAxisCompressionMode;\n  float4 compressionFuncParamsR;\n  float4 compressionFuncParamsY;\n  float4 compressionFuncParamsG;\n  float4 compressionFuncParamsC;\n  float4 compressionFuncParamsB;\n  float4 compressionFuncParamsM;\n  bool   Reachcompressmode;\n  bool   reachNick;\n  bool   Locuscompressmode;\n\n  int   boundryIntersectionMethod;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n  float lowerHullGamma;\n  float upperHullGamma;\n\n  // How much the edges of the target RGB cube are smoothed when finding the gamut boundary\n  // in order to reduce visible contours at the gamut cusps\n  float smoothCusps;\n  float smoothJ; // Scaling factor for cusp J\n  float smoothM; // Scaling factor for cusp M\n\n  //\n  // Output Parameters\n  //\n\n  // Encoding of the Output Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingOut;\n\n  // Primaries of the Output Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesOut;\n\n  // Clamp output values to 0.0 - 1.0\n  bool  fitWhite;\n  bool  clampOutput;\n  bool  softclampOutput;\n  float clamp_thr;\n  float clamp_dist;\n\n  //\n  // Extra Parameters\n  //\n\n  // Toggle Inverse Transform\n  bool invert;\n  // Diagnostic path modes\n  int diagnosticMode;\n\n  // DanieleEvoCurve (ACES2 candidate) parameters\n  float mmScaleFactor;\n  float daniele_n;         // peak white\n  float daniele_n_r;       // Normalized white in nits (what 1.0 should be)\n  float daniele_g;         // surround / contrast\n  float daniele_c;         // scene-referred grey\n  float daniele_c_d;       // display-referred grey (in nits)\n  float daniele_w_g;       // grey change between different peak luminance\n  float daniele_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float daniele_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float daniele_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n  // Hellwig 2022 CAM params\n  // the kernel parameters\n\n  // 0 = Stock CAT16\n  // 1 = Thomas's custom primaries\n  // 2 = live from params below\n  int catDataSelection; // original vs modified CAT16 matrix\n  // xy coordinates for custom CAT matrix\n  float2 rxy;\n  float2 gxy;\n  float2 bxy;\n  float2 wxy;\n  float  ra;\n  float  ba;\n\n  // Input vars\n  float3 XYZ_w;\n  float  XYZ_w_scaler;\n  float  L_A;\n  float  Y_b;\n  float3 L_B;\n  float3 userSurround;\n  bool   discount_illuminant;\n  // Output vars\n  float L_A_out;\n  float Y_b_out;\n\nlocal:\n  // Hellwig 2022 constants\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n  float3x3 panlrcm;\n\n  float daniele_r_hit;\n  float daniele_m_0;\n  float daniele_m_1;\n  float daniele_u;\n  float daniele_m;\n  float daniele_w_i;\n  float daniele_c_t;\n  float daniele_g_ip;\n  float daniele_g_ipp2;\n  float daniele_w_2;\n  float daniele_s_2;\n  float daniele_u_2;\n  float daniele_m_2;\n\n  // Chroma compression pre-calculated constants\n  float compr;   // Compression\n  float sat;     // Saturation\n  float sat_thr; // Threshold to start expanding saturation\n\n  // Gamut mapper constants\n  float focusDist; // FocusDistance for projection\n\n  // ST2084 vars\n  float st2084_m_1;\n  float st2084_m_2;\n  float st2084_c_1;\n  float st2084_c_2;\n  float st2084_c_3;\n  float st2084_m_1_d;\n  float st2084_m_2_d;\n  float st2084_L_p;\n\n  // using the float3x3 type to store the array of 6 coefficients\n  // because Blink does not support generic array assignments\n\n  // matrix vars\n  float3x3 identity_matrix;\n\n  float3x3 XYZ_to_RGB_input;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 XYZ_to_RGB_reach;\n  float3x3 XYZ_to_RGB_output;\n\n  float3x3 RGB_to_XYZ_input;\n  float3x3 RGB_to_XYZ_limit;\n  float3x3 RGB_to_XYZ_reach;\n  float3x3 RGB_to_XYZ_output;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n\n  // white points\n  float3 inWhite;\n  float3 outWhite;\n  float3 limitWhite;\n\n  // the maximum RGB value of the limiting gamut\n  float boundaryRGB;\n\n  // the maximum lightness value of the limiting gamut\n  float limitJmax;\n\n  // Middle gray J\n  float midJ;\n\n  // Hellwig model's gamma (1 / cz)\n  float model_gamma;\n\n  // the 'tempTableUnsorted' table is populated\n  // in increments of H of the limiting gamut HSV space starting at H=0.0\n  // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n  // the entries are then wrap-around shifted\n  // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n  // both tables need to be declared here since temporary array variables\n  // in the init() fuction seem to crash Nuke on some systems\n  float3 gamutCuspTable\[gamutCuspTableSize + 1];\n  float3 gamutCuspTableReach\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutReachTable\[gamutCuspTableSize + 1];\n  float2 gamutGammas\[gamutCuspTableSize + 1];\n  float  LocusLimitMTable\[gamutCuspTableSize + 1];\n\n  void define()\n  \{\n    defineParam(chroma_compress_fact, \"Chroma Compress Factor\", 5.0f);\n    defineParam(chroma_expand_fact, \"Chroma Expansion Factor\", 0.78f);\n    defineParam(smoothJ, \"Smoothing factor cusp J\", 0.055f);\n    defineParam(smoothM, \"Smoothing factor cust M\", 0.183f);\n  \}\n\n  // Functions used in ACES 2.0 candidate CAM DRT\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  inline float spow(float base, float exponent)\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ;\n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b)\n\n    // float a_p = sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else\n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if (base < 0.0f && exponent != floor(exponent))\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent);\n    \}\n  \}\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  float3 float3spow(float3 base, float exponent)\n  \{\n    return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  // \"safe\" div\n  float sdiv(float a, float b)\n  \{\n    if (b == 0.0f)\n    \{\n      return 0.0f;\n    \}\n    return a / b;\n  \}\n\n  float degree_of_adaptation(float F, float L_A)\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float  ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d   = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  // basic 3D hypotenuse function, does not deal with under/overflow\n  inline float hypot_float3(float3 xyz)\n  \{\n    return length(xyz);\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float r = R / C;\n    r       = r * r;\n    r       = sqrt(4.0f / r + 1.0f) - 1.0f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float t = 0.5f + sqrt(s * s + r * r / 4.0f);\n    t       = C / t; // t is always >= 0.5f\n\n    xyz_temp = xyz_temp * t + C;\n\n    return xyz_temp;\n  \}\n\n  float3 uncompress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float t = C / R;\n    t       = t - 0.5f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float r = 2 * sqrt(fabs(t * t - s * s)) + 1;\n    r       = sqrt(fabs(r * r - 1));\n    if (r == 0.0)\n      return xyz;\n    r = C * 2 / r;\n\n    xyz_temp = xyz_temp * r + C;\n\n    return xyz_temp;\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float hr)\n  \{\n    return -0.160 * cos(hr) + 0.132 * cos(2 * hr) - 0.405 * sin(hr) + 0.080 * sin(2 * hr) + 0.792;\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n      Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n      Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? spow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n    const float3 F_L_RGB = float3pow(F_L / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, float F_L)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV(float3 RGB)\n  \{\n    float cmax  = max(RGB.x, max(RGB.y, RGB.z));\n    float cmin  = min(RGB.x, min(RGB.y, RGB.z));\n    float delta = cmax - cmin;\n\n    float3 HSV;\n    HSV.x = delta == 0.0f ? 0.0f\n      : cmax == RGB.x     ? (fmod((RGB.y - RGB.z) / delta + 6.0f, 6.0f)) / 6.0f\n      : cmax == RGB.y     ? (((RGB.z - RGB.x) / delta + 2.0f) / 6.0f)\n                          : (((RGB.x - RGB.y) / delta + 4.0f) / 6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a          = JM.y / (focusJ * slope_gain);\n    float b          = 0.0f;\n    float c          = 0.0f;\n    float intersectJ = 0.0f;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      intersectJ = 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      intersectJ = 2.0f * c / (-b + root);\n    \}\n\n    return intersectJ;\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (viewingConditions == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (viewingConditions == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (viewingConditions == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (viewingConditions == 3)\n    \{\n      // Pull from external input\n      newSurround = userSurround;\n    \}\n    return newSurround;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear(float v)\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084(float v)\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f / 2.4f);\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f / 2.6f);\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ          = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh          = XYZ_to_JMh(XYZ, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n    // First matrix to limiting gamut for clamping\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_limit, luminanceXYZ);\n\n    if (fitWhite)\n    \{\n      // Scale to fit maximum creative white channel value\n      float3 creativeWhiteXYZ = vector_dot(RGB_to_XYZ_limit, float3(1.0f, 1.0f, 1.0f)); // TODO: these scaling parameters could be precalculated\n      float3 creativeWhiteRGB = vector_dot(XYZ_to_RGB_output, creativeWhiteXYZ);\n      luminanceRGB *= 1.0f / max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    \}\n\n    if (softclampOutput)\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    if (clampOutput)\n    \{\n      // Clamp to between zero and peak luminance\n      luminanceRGB = clamp3(luminanceRGB, 0.0f, peakLuminance);\n    \}\n\n    // Matrix to output (encoding) gamut (eventually concatenate to a single matrix)\n    luminanceRGB = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceRGB);\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3(encodingOut, luminanceRGB);\n\n    return outputRGB;\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 RGB_to_JMh(const float3 RGB, float3 refWhite, const float3x3& matrix)\n  \{\n    const float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    const float3 XYZ          = vector_dot(matrix, luminanceRGB);\n    const float3 JMh          = XYZ_to_JMh(XYZ, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the given primaries\n  float3 JMh_to_RGB(float3 JMh, float3 refWhite, const float3x3& matrix)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    float3 luminanceRGB = vector_dot(matrix, luminanceXYZ);\n    float3 RGB          = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    XYZ_w = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    if (compressMode)\n    \{\n      RGB_c = compress_bjorn(RGB_c);\n    \}\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n    if (compressMode)\n    \{\n      RGB_a = uncompress_bjorn(RGB_a);\n    \}\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    float R_a = RGB_a.x;\n    float G_a = RGB_a.y;\n    float B_a = RGB_a.z;\n    float a   = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    float b   = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    float hr = atan2(b, a);\n    float h  = wrap_to_360(degrees(hr));\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    float R_a2 = RGB_a.x;\n    float G_a2 = RGB_a.y;\n    float B_a2 = RGB_a.z;\n\n    float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w, surround.y * z);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *chroma* :math:`C`.\n    float C = 35.0f * M / A_w;\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // float s = 100.0f * sdiv(M, Q);\n  \n    if (HK_mode)\n    \{\n      // # *Helmholtz–Kohlrausch* Effect Extension.\n      J = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n      // float Q_HK = (2.0f / surround.y) * (J / 100.0f) * A_w;\n    \}\n    \n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    float J = JMh.x;\n    float M = JMh.y;\n    float h = JMh.z;\n    XYZ_w   = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n    float A_w  = ra * R_aw + G_aw + ba * B_aw;\n\n    float hr = radians(h);\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    float C = (M * 35) / A_w;\n    if (HK_mode)\n    \{\n      J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n    \}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    float P_p_1 = 43.0f * surround.z;\n    float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    float gamma = M / P_p_1;\n    float a     = gamma * cos(hr);\n    float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    if (compressMode)\n    \{\n      RGB_a = compress_bjorn(RGB_a);\n    \}\n\n    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n    if (compressMode)\n    \{\n      RGB_c = uncompress_bjorn(RGB_c);\n    \}\n\n    // # Step 6\n    float3 RGB = RGB_c / D_RGB;\n\n    // # Step 7\n    float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  int find_upper_hue_in_table(float h, float3 table\[], int table_size)\n  \{\n    int low_i  = 0;\n    int high_i = table_size - 1;\n    int i      = hue_position_in_uniform_table(h, table_size);\n\n    while (low_i + 1 < high_i)\n    \{\n      if (h > table\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float2 cuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n    if (h <= gamutCuspTable\[0].z)\n    \{\n      lo   = gamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = gamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > gamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = gamutCuspTable\[high_i - 1];\n      hi = gamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 cuspFromTableLocus(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float lo = LocusLimitMTable\[i_lo];\n    const float hi = LocusLimitMTable\[i_lo + 1];\n\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    const float cuspJ = 69;\n    const float cuspM = lerp(lo, hi, t);\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (h <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  float cReachFromTable(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = cgamutReachTable\[i_lo];\n    const float3 hi = cgamutReachTable\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y       = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float  hr     = radians(h);\n\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + hr) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float _h   = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n             + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    return JMcusp.y * e_t;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f);\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = cusp_with_eccentricity_factor(JMh.z);\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!invert)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      if (applyInGamutCompression)\n      \{\n        // Normalize M with the rendering space cusp M\n        M /= Mnorm;\n\n        // Expand the colorfulness by running the toe function in reverse.  The goal is to\n        // expand less saturated colors less and more saturated colors more.  The expansion\n        // increases saturation in the shadows and mid-tones but not in the highlights.\n        // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n        // the toe less aggressive near black to reduce the expansion of noise.\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n        // Compress the colorfulness.  The goal is to compress less saturated colors more and\n        // more saturated colors less, especially in the highlights.  This step creates the\n        // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n        // mostly affects highlights and mid-tones, and does not compress shadows.\n        M = toe(M, limit, nJ * compr, snJ, 0);\n\n        // Clamp M to the rendering space\n        if (applyReachClamp)\n          M = min(limit, M);\n\n        // Denormalize\n        M *= Mnorm;\n      \}\n    \}\n    else\n    \{\n      if (applyInGamutCompression)\n      \{\n        M /= Mnorm;\n        M = toe(M, limit, nJ * compr, snJ, 1);\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n        M *= Mnorm;\n      \}\n\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    if (AP1Clamp)\n    \{\n      luminanceRGB   = vector_dot(XYZ_to_AP1, luminanceXYZ);\n      luminanceRGB.x = max(0.0f, luminanceRGB.x);\n      luminanceRGB.y = max(0.0f, luminanceRGB.y);\n      luminanceRGB.z = max(0.0f, luminanceRGB.z);\n      luminanceXYZ   = vector_dot(AP1_to_XYZ, luminanceRGB);\n    \}\n\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n    else\n    \{\n      return JMh;\n    \}\n  \}\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB     = luminanceToEncoding3(encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\nfloat Y_to_Hellwig_J(float Y, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n    return sign(Y) * 100.0f * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, surround.y * z);\n  \}\n\n  float Hellwig_J_to_Y(float J, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float A = A_w * pow(fabs(J) / 100.0f, 1.0f / (surround.y * z));\n\n    return sign(J) * 100.0f / F_L * pow((27.13f * A) / (400.0f - A), 1.0f / 0.42f);\n  \}\n\n  float3 forwardTonescale(float3 inputJMh)\n  \{\n    float3 outputJMh;\n    float3 surround    = viewingConditionsToSurround(viewingConditions);\n    float  linear      = Hellwig_J_to_Y(inputJMh.x, surround) / referenceLuminance;\n    float  luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if (toneScaleMode == 1)\n    \{\n      luminanceTS = daniele_evo_fwd(luminanceTS) * mmScaleFactor;\n    \}\n\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, surround);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    if (applyTonecurve)\n    \{\n      outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n      outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    if (monochrome)\n    \{\n      outputJMh.y = 0.0f;\n    \}\n\n    return outputJMh;\n  \}\n\n  float3 inverseTonescale(float3 JMh)\n  \{\n    float3 tonemappedJMh = JMh;\n    float3 surround = viewingConditionsToSurround(viewingConditions);\n\n    if (!applyTonecurve && !applyChromaCompression)\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n\n    float luminance = Hellwig_J_to_Y(tonemappedJMh.x, surround);\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if (toneScaleMode == 1)\n    \{\n      linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n      linear = luminance;\n    \}\n\n    linear = linear * referenceLuminance;\n\n    if (applyTonecurve)\n    \{\n      float untonemappedJ = Y_to_Hellwig_J(linear, surround);\n      untonemappedColourJMh = float3(untonemappedJ, tonemappedJMh.y, tonemappedJMh.z);\n    \}\n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return untonemappedColourJMh;\n  \}\n\n  float2 hueDependantHullGammas(float h)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(h, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    return lerp(gamutGammas\[i_lo], gamutGammas\[i_lo + 1], t);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float gamma_top, float gamma_bottom)\n  \{\n    float2 JM_source = float2(JMh_s.x, JMh_s.y);\n\n    float slope = 0.0f;\n\n    float s = max(0.000001f, smoothness);\n    JM_cusp.x *= 1.0f + smoothJ * s; // J\n    JM_cusp.y *= 1.0f + smoothM * s; // M\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, 1 / gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp)\n      * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), 1.0f / gamma_top) / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, s);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'.\n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.05f, cusp.x / limitJmax), 0.0001f);\n    cusp.y *= 1.0f + 0.18f * s;\n    cusp.x *= 1.0f + 0.07f * s;\n\n    // Line below the cusp is curved with model_gamma\n    float toJ_gamma   = cusp.x * spow(to.x / cusp.x, model_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, model_gamma);\n    t0                = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float2 findCurveIntersection(float c, float2 cusp, float m, float h)\n  \{\n    // based on this desmos plot https://www.desmos.com/calculator/pcsovzirqa\n    float xc = cusp.y;\n    float yc = cusp.x;\n    float f  = 1.0;\n    float mf = m * f;\n    float xi = 1.0f;\n    float g1 = 1.0f / model_gamma;\n    float g2 = hueDependantHullGammas(h).y;\n\n    if (m * xc + c < yc)\n    \{\n      // below cusp\n      xi = spow((1 - mf), (g1 - 1)) * ((yc * spow((c / yc), (1.0 / g1))) / (yc / xc - m));\n    \}\n    else\n    \{\n      // above cusp\n      xi =\n        spow((1 + mf), ((g2 - 1))) * (xc * (limitJmax - yc) * spow(((limitJmax - c) / (limitJmax - yc)), (1 / g2)) / (m * xc + limitJmax - yc));\n    \}\n    float yi = (m * xi) + c;\n    if (yi > limitJmax)\n    \{\n      yi = limitJmax;\n      xi = 0.0f;\n    \}\n    return float2(yi, xi);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus     = cuspFromTableLocus(h);\n    float  cuspTarget100 = cuspLocus.y;\n    float  cuspTarget    = cuspTarget100 * pow((Jmh.x / 100.0f), model_gamma);\n    float  difference    = cuspLocus.y / cuspTarget;\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float3 getReachBoundry(float3 Jmh)\n  \{\n    const float h = Jmh.z;\n\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = gamutCuspTableReach\[i_lo];\n    const float3 hi = gamutCuspTableReach\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n\n    const float reachMaxM = lerp(lo.y, hi.y, t);\n    if (reachNick)\n    \{\n      float2 JMcusp     = cuspFromTable(Jmh.z);\n      float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain = limitJmax * focusDist * getFocusGain(Jmh.x, JMcusp.x);\n      float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n      float  slope;\n      if (intersectJ < focusJ)\n      \{\n        slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      else\n      \{\n        slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      float boundaryNick = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n      return float3(Jmh.x, boundaryNick, Jmh.z);\n    \}\n    float cuspTarget = reachMaxM * pow((Jmh.x / limitJmax), model_gamma);\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n\n    if (Reachcompressmode)\n    \{\n      if (primariesReach != 6) // All of the primary based reach values\n      \{\n        // use primary based reach\n        float locusMax   = getReachBoundry(Jmh).y;\n        float difference = max(1.0001f, locusMax / Jmh.y);\n        float threshold  = max(compressionFuncParams.x, 1.0f / difference);\n        return float4(threshold, difference, difference, compressionFuncParams.w);\n      \}\n      else\n      \{\n        // use locus based reach\n        float locusMax   = getLocusBoundry(Jmh).y;\n        float difference = locusMax / Jmh.y;\n        return float4(compressionFuncParams.x, difference, difference, compressionFuncParams.w);\n      \}\n    \}\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h >= angleR && h < angleY)\n      \{\n        lerpVal = (h - angleR) / (angleY - angleR);\n        return lerp(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h >= angleY && h < angleG)\n      \{\n        lerpVal = (h - angleY) / (angleG - angleY);\n        return lerp(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h >= angleG && h < angleC)\n      \{\n        lerpVal = (h - angleG) / (angleC - angleG);\n        return lerp(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h >= angleC && h < angleB)\n      \{\n        lerpVal = (h - angleC) / (angleB - angleC);\n        return lerp(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h >= angleB && h < angleM)\n      \{\n        lerpVal = (h - angleB) / (angleM - angleB);\n        return lerp(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h >= angleM && h < angleR + 360.0f)\n      \{\n        lerpVal = (h - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h < angleR)\n      \{\n        lerpVal = (h + 360.0f - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  float getFocusGain(float J, float cuspJ)\n  \{\n    if (disableFocusGain)\n      return 1.0f;\n\n    float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J > thr)\n    \{\n      // Approximate inverse required above threshold\n      float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n      return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n    \}\n    else\n    \{\n      // Analytic inverse possible below cusp\n      return 1.0f;\n    \}\n  \}\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    if (disableFocusGain)\n      return compressGamut2(JMh, invert, JMh.x);\n\n    if (!invert)\n    \{\n      return compressGamut2(JMh, 0, JMh.x);\n    \}\n    else\n    \{\n      float2 JMcusp = cuspFromTable(JMh.z);\n      float  Jx     = JMh.x;\n\n      // Analytic inverse below threshold\n      if (Jx <= lerp(JMcusp.x, limitJmax, focusGainBlend))\n        return compressGamut2(JMh, 1, Jx);\n\n      // Approximation above\n      Jx = compressGamut2(JMh, 1, Jx).x;\n      return compressGamut2(JMh, 1, Jx);\n    \}\n  \}\n\n  float3 compressGamut2(float3 JMh, int invert, float Jx)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp       = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDist * JMcusp.y);\n    float a      = max(0.001f, Mratio / focusJ);\n    float b0     = 1.0f - Mratio;\n    float b1     = -(1.0f + Mratio + (a * limitJmax));\n    float b      = project_from.x < focusJ ? b0 : b1;\n    float c0     = -project_from.x;\n    float c1     = project_from.x + limitJmax * Mratio;\n    float c      = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0       = sqrt(b * b - 4 * a * c);\n    float J1       = (-b - J0) / (2 * a);\n    J0             = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    float slope_gain = limitJmax * focusDist * getFocusGain(Jx, JMcusp.x);\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = float2(1.0f, 1.0f);\n    if (boundryIntersectionMethod == 0)\n    \{\n      // Original method implemented by Pekka\n      JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    \}\n    else if (boundryIntersectionMethod == 1)\n    \{\n      // Alternate method shown in Oct 19 meeting\n      float m    = (JMh.x - projectJ) / JMh.y;\n      JMboundary = findCurveIntersection(JMh.x, JMcusp, 0.0f, JMh.z);\n    \}\n    else if (boundryIntersectionMethod == 2)\n    \{\n      const float2 gammas      = hueDependantHullGammas(JMh.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      JMboundary               = float2(nickBoundryReturn.x, nickBoundryReturn.y);\n      project_to               = float2(nickBoundryReturn.z, 0.0f);\n      projectJ                 = nickBoundryReturn.z;\n    \}\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams;\n    if (reachNick)\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMboundary.x, JMboundary.y, JMh.z));\n    \}\n    else\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x, JMboundary.y, JMh.z));\n    \}\n\n    if (!Reachcompressmode)\n      interpolatedCompressionFuncParams.x =\n        1.0f / lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n\n    float lowerMlimit = 0.0001f; // Testing a small value here\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)  // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                                    lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                                    interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 20)\n    \{\n      // return focus point\n      return float3(project_to.x, project_to.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n                            ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit  = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0    = daniele_n / daniele_n_r;\n    daniele_m_1    = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u      = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m      = daniele_m_1 / daniele_u;\n    daniele_w_i    = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t    = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip   = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2    = daniele_c / daniele_g_ipp2;\n    daniele_s_2    = daniele_w_2 * daniele_m_1;\n    daniele_u_2    = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2    = daniele_m_1 / daniele_u_2;\n\n    // 1.0f / (c * z)\n    model_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n\n    // Chroma compression scaling for HDR/SDR appearance match\n    float log_peak = log10(daniele_n / daniele_n_r);\n    compr          = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    sat            = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak);\n    sat_thr        = chroma_expand_thr / daniele_n;\n\n    // Gamut mapper focus distance scaling with peak luminance for\n    // HDR/SDR appearance match.  The projection gets slightly less\n    // steep with higher peak luminance.\n    // https://www.desmos.com/calculator/bnfhjcq5vf\n    if (!disableFocusDistScaling)\n      focusDist = focusDistance + focusDistance * focusDistScaling * log_peak;\n    else\n      focusDist = focusDistance;\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    float CAT_CAT16_data\[] = \{\n      0.401288, 0.650173, -0.051461, -0.250268, 1.204414, 0.045854, -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[] = \{\n      0.656619, 0.342071, 0.00131062, -0.222571, 1.10658, 0.115987, -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[] = \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374,\n      238.0180511, 235.4039917, 233.010849,  230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215,\n      190.9799347, 184.005127,  177.7472992, 172.2332611, 166.6447754, 161.64534,   156.9872284, 152.6203003, 148.3236084, 144.2987976,\n      140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861,\n      114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853,  105.188797,  103.6860809, 102.2319641, 100.8348923, 99.51873779,\n      98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951,  92.03639984, 91.15013885, 90.27630615, 89.43255615,\n      88.63536072, 87.8986969,  87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547,\n      83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156,\n      80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702,\n      80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481,  81.901474,   82.20778656, 82.67211151,\n      83.1408844,  83.62628174, 84.0898056,  84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481,\n      88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783,  94.64561462, 95.68405914, 96.84765625,\n      97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031,\n      113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034,\n      137.8343048, 140.7224121, 143.7820892, 147.23909,   150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272,\n      171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255,\n      199.4234161, 201.3786011, 203.1474609, 205.016037,  206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686,\n      215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463,\n      213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355,\n      195.217453,  193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165,\n      174.445282,  172.4908905, 170.5744934, 168.5490723, 166.459259,  164.4333649, 162.5092621, 160.4579468, 158.491806,  156.6880035,\n      155.0045624, 153.295166,  151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602,\n      139.225174,  137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328,   128.7269897,\n      127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358,  120.9004822,\n      120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039,\n      116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118,\n      114.8510284, 114.8482819, 114.848465,  114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528,  115.7195816,\n      115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586,\n      119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077,  124.071022,  124.9082108, 125.74823,   126.6865311,\n      127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252,  130.1131287, 130.5647278,\n      130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609,  136.6136017, 137.5203552,\n      138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586,\n      150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551,\n      168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373,\n      192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452,  206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306,\n      220.6668701, 223.364151,  226.2115479, 228.9524536, 231.5583954, 234.405304,  237.0275879, 239.5091705, 242.0047455, 242.0177155,\n      244.8230133\};\n\n    // populate the input primaries matrix\n    RGB_to_XYZ_input = generate_RGB_to_XYZ_matrix(primariesIn);\n    XYZ_to_RGB_input = RGB_to_XYZ_input.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(1); // AP1 == 1\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix;\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n    if (whiteLimit == 0)\n    \{\n      limitWhiteForMatrix = float2(0.32168f, 0.33767f);\n    \}\n    else if (whiteLimit == 1)\n    \{\n      limitWhiteForMatrix = float2(0.3127f, 0.3290f);\n    \}\n    else\n    \{\n      limitWhiteForMatrix = float2(0.333333f, 0.333333f);\n    \}\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001, -0.077);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, 0);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    RGB_to_XYZ_reach = generate_RGB_to_XYZ_matrix(primariesReach);\n    XYZ_to_RGB_reach = RGB_to_XYZ_reach.invert();\n\n    RGB_to_XYZ_output = generate_RGB_to_XYZ_matrix(primariesOut);\n    XYZ_to_RGB_output = RGB_to_XYZ_output.invert();\n\n    float3 white(1.0f, 1.0f, 1.0f);\n    inWhite    = vector_dot(RGB_to_XYZ_input, white);\n    outWhite   = vector_dot(RGB_to_XYZ_output, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = peakLuminance / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n      CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n      CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n      CAT_CAT16 = RGBPrimsToXYZMatrix(rxy, gxy, bxy, wxy, 1.0f, 1);\n    \}\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    generate_panlrcm();\n\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    limitJmax = RGB_to_JMh(float3(1.0f), limitWhite, RGB_to_XYZ_limit).x;\n\n    // Cusp table for chroma compression gamut\n    float3x3 RGB_to_XYZ_cgReach;\n    if (ccReach == 0) // Chroma Compression Space (primaries defined in kernel params)\n    \{\n      RGB_to_XYZ_cgReach = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 0);\n\n    \}\n    else if (ccReach == 1)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(0);\n    \}\n    else if (ccReach == 2)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(1);\n    \}\n    else\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(3);\n    \}\n    const float3x3 XYZ_to_RGB_cgReach = RGB_to_XYZ_cgReach.invert();\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, inWhite, RGB_to_XYZ_cgReach);\n    initialise_reach_cusp_table(cgamutReachTable, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_cgReach);\n\n    // With gamut mapper reach mode 7, use the chroma compression reach space with the\n    // gamut mapper.\n    if (primariesReach == 7)\n      XYZ_to_RGB_reach = XYZ_to_RGB_cgReach;\n\n    // Cusp table for limiting gamut\n    initialise_cusp_table(gamutCuspTable, gamutCuspTableSize, limitWhite, RGB_to_XYZ_limit);\n    initialise_reach_cusp_table(gamutCuspTableReach, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_reach);\n\n    midJ = XYZ_to_JMh(inWhite * daniele_c_t * mmScaleFactor, inWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid,\n                      HK_mode_mid)\n             .x;\n\n    initialise_upper_hull_gamma();\n    initialise_lower_hull_gamma();\n  \}\n\n  void initialise_cusp_table(float3 output_table\[], const int table_size, float3 refWhite, const float3x3& matrix)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      tempTableUnsorted\[i] = RGB_to_JMh(RGB, refWhite, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 tableUnsorted\[], const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 output_table\[], const int table_size, const float limitJ, float3 refWhite, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_RGB(float3(limitJ, high, hue), refWhite, matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_RGB(float3(limitJ, sampleM, hue), refWhite, matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, min(1.0, cuspMidBlend - (JMcusp.x / limitJmax)));\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, topGamma, lowerHullGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma()\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        gamutGammas\[i].x =  upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      gamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].x = gamutGammas\[0].x;\n   \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float slope_gain = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n\n      const float3 approxLimit     = findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax,\n                                                                   slope_gain, smoothCusps, upperHullGamma, bottomGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma()\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        gamutGammas\[i].y = lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      gamutGammas\[i].y = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].y = gamutGammas\[0].y;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n    float3 diagnostic;\n\n    if (invert)\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh           = inverseTonescale(tonemappedJMh);\n      diagnostic    = JMh_to_input_RGB(JMh);\n    \}\n    else\n    \{\n      JMh           = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n      diagnostic    = JMh_to_output_RGB(compressedJMh);\n    \}\n\n    if (diagnosticMode == 1 || diagnosticMode == 6)\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if (invert)\n      \{\n        diagnostic = JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic = JMh;\n      \}\n    \}\n    else if (diagnosticMode == 2 || diagnosticMode == 99)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if (diagnosticMode == 3 || diagnosticMode == 5)\n    \{\n      diagnostic = compressedJMh;\n    \}\n    else if (diagnosticMode == 4 || diagnosticMode == 7)\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB     = JMh_to_output_RGB(srcRGB);\n      diagnostic = dstRGB;\n    \}\n    else if (diagnosticMode == 8)\n    \{\n      diagnostic = inWhite;\n    \}\n    else if (diagnosticMode == 9)\n    \{\n      diagnostic = outWhite;\n    \}\n    else if (diagnosticMode == 10)\n    \{\n      diagnostic = limitWhite;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      const float2 JMcusp = cuspFromTable(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      const float2 JMcusp = cuspFromTableLocus(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundary\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundary\n      diagnostic = getReachBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 20)\n    \{\n      // output JMFocus\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 21)\n    \{\n      // output JMFocus\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).y, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 22)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float slope_gain = limitJmax * focusDist;\n      diagnostic       = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 23)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic         = float3(approxLimit.x, approxLimit.y, srcRGB.z);\n    \}\n\n    else if (diagnosticMode == 24)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      float3 newLimitRGB = JMh_to_RGB(float3(approxLimit.x, approxLimit.y, srcRGB.z), limitWhite, XYZ_to_RGB_limit);\n      diagnostic         = newLimitRGB;\n    \}\n\n    else if (diagnosticMode == 25)\n    \{\n      float2 JMcusp            = cuspFromTable(srcRGB.z);\n      float  focusJ            = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain        = limitJmax * focusDist * getFocusGain(JMh.x, JMcusp.x);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(srcRGB, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic               = float3(srcRGB.x, nickBoundryReturn.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 26)\n    \{\n      // XYZ back to luminance RGB\n      float3 JMh = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n      diagnostic = vector_dot(XYZ_to_RGB_limit, JMh);\n    \}\n    else if (diagnosticMode == 27)\n    \{\n      // output\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).x, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 28)\n    \{\n      // output\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      diagnostic    = findGamutBoundaryIntersection(srcRGB, JMcusp, lerp(JMcusp.x, midJ, cuspMidBlend), limitJmax, 10000.0f, 0.0f,\n                                                    gammas.x, gammas.y);\n    \}\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    ////// FORWARD PATHWAY\n\n    else if (diagnosticMode == 100)\n    \{\n      // display encoding to display linear\n      diagnostic      = encodingToLuminance3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 101)\n    \{\n      // convert to linear XYZ luminance values\n      diagnostic = vector_dot(RGB_to_XYZ_input, srcRGB);\n    \}\n    else if (diagnosticMode == 102)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 105)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 106)\n    \{\n      // display luminance XYZ to display linear RGB\n      diagnostic = vector_dot(XYZ_to_RGB_output, srcRGB);\n    \}\n    else if (diagnosticMode == 107)\n    \{\n      // display linear RGB to display encoded RGB\n      diagnostic = luminanceToEncoding3(encodingOut, srcRGB);\n    \}\n\n    ////// INVERSE PATHWAY\n\n    else if (diagnosticMode == 200)\n    \{\n      // output display encoded RGB to display linear RGB\n      diagnostic = encodingToLuminance3(encodingOut, srcRGB);\n    \}\n    else if (diagnosticMode == 201)\n    \{\n      // output display linear RGB to output display linear XYZ\n      diagnostic = vector_dot(RGB_to_XYZ_output, srcRGB);\n    \}\n    else if (diagnosticMode == 202)\n    \{\n      // output XYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 203)\n    \{\n      // uncompress gamut\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 204)\n    \{\n      // inverse tonescale in JMh\n      diagnostic = inverseTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 205)\n    \{\n      // inverted JMh back to XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 206)\n    \{\n      // XYZ back to luminance RGB\n      diagnostic = vector_dot(XYZ_to_RGB_input, srcRGB);\n    \}\n    else if (diagnosticMode == 207)\n    \{\n      // luminance RGB to input encoding RGB\n      diagnostic = luminanceToEncoding3(encodingIn, srcRGB);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_AP1Clamp {{parent.ap1_clamp}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_peakLuminance {{parent.peak_luminance}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_applyInGamutExpansion {{parent.applyInGamutExpansion}}
  DRT_CAM_Kernel_applyInGamutCompression {{parent.applyInGamutCompression}}
  DRT_CAM_Kernel_applyReachClamp {{parent.applyReachClamp}}
  DRT_CAM_Kernel_monochrome {{parent.monochrome}}
  DRT_CAM_Kernel_chroma_compress {{parent.compress}}
  "DRT_CAM_Kernel_Chroma Compress Factor" {{parent.chroma_compress_fact}}
  DRT_CAM_Kernel_chroma_expand {{parent.chroma_expand}}
  "DRT_CAM_Kernel_Chroma Expansion Factor" {{parent.chroma_expand_fact}}
  DRT_CAM_Kernel_chroma_expand_thr {{parent.chroma_expand_thr}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_ccReach {{parent.ccReachPrimaries}}
  DRT_CAM_Kernel_crxy {0.7347 0.2653}
  DRT_CAM_Kernel_cgxy {0.12 0.88}
  DRT_CAM_Kernel_cbxy {0.08 -0.04}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_whiteLimit {{parent.white_limit}}
  DRT_CAM_Kernel_primariesReach {{parent.primaries_reach}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_focusAdjustGain {{parent.focusgain}}
  DRT_CAM_Kernel_focusGainBlend {{parent.focus_gain_blend}}
  DRT_CAM_Kernel_focusDistScaling {{parent.focusdistscaling}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r x272 -1.75} {parent.compression_params.g} {parent.compression_params.b} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR x272 0.21} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Reachcompressmode {{parent.reachCompressMode}}
  DRT_CAM_Kernel_reachNick true
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_boundryIntersectionMethod {{boundryIntersectionMethod}}
  DRT_CAM_Kernel_disableLowerHullGamma true
  DRT_CAM_Kernel_lowerHullGamma {{lowerHullGamma}}
  DRT_CAM_Kernel_upperHullGamma {{parent.upperHullGamma}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  "DRT_CAM_Kernel_Smoothing factor cusp J" {{parent.smoothJ}}
  "DRT_CAM_Kernel_Smoothing factor cust M" {{parent.smoothM}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_fitWhite {{parent.fit_white}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.peak_luminance}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.8336 0.1735}
  DRT_CAM_Kernel_gxy {2.3854 -1.4659}
  DRT_CAM_Kernel_bxy {0.087 -0.125}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Reformat {
 type scale
 scale 7
 filter impulse
 name Reformat7
 label "scale up 7x"
 xpos 148
 ypos 656
}
Dot {
 name Dot8
 xpos 182
 ypos 688
}
set Nb12dca00 [stack 0]
Expression {
 expr0 isnan(r)?0:r
 expr1 isnan(g)?0:g
 expr2 isnan(b)?0:b
 name killNan1
 xpos 194
 ypos 705
}
Clamp {
 minimum -65535
 maximum 65535
 name Clamp5
 xpos 194
 ypos 729
}
Colorspace {
 illuminant_in ACES
 primary_in ACES
 colorspace_out CIE-XYZ
 name Colorspace5
 label "XYZ to AP0"
 xpos 194
 ypos 765
 disable true
}
ColorMatrix {
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 invert true
 name ColorMatrix2
 label "APS4 to XYZ"
 xpos 194
 ypos 797
 disable true
}
Expression {
 temp_name0 cut_lin
 temp_expr0 0.0078125
 temp_name1 cut_log
 temp_expr1 0.155251141552511
 temp_name2 A
 temp_expr2 10.5402377416545
 temp_name3 B
 temp_expr3 0.0729055341958355
 expr0 r<=cut_lin?A*r+B:(log(r)/log(2)+9.72)/17.52
 expr1 g<=cut_lin?A*g+B:(log(g)/log(2)+9.72)/17.52
 expr2 b<=cut_lin?A*b+B:(log(b)/log(2)+9.72)/17.52
 channel3 none
 name lin2log1
 label ACEScct
 xpos 194
 ypos 829
}
push $Nb12dca00
Switch {
 inputs 2
 which {{master.inverseMode}}
 name Switch4
 xpos 148
 ypos 874
}
Group {
 name Write_ResolveACES_ODT_LUT5
 label "\[python nuke.thisNode().knob('cubePath').evaluate().split('/').pop(-1)]"
 xpos 148
 ypos 1004
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate CAMDRT
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target "Rec2100 (Rec709 sim)"
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate_\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template_AP0.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template_AP0.fltransform
 addUserKnob {1 dctlColorspaceBufferTag}
 dctlColorspaceBufferTag Rec2020_1000nits_15nits_ST2084
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev060/ACES2 Candidate CAMDRT rev060 Rec2100 (Rec709 sim)_inverse.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
Colorspace {
 inputs 0
 primary_out DCI-P3
 name Colorspace12
 xpos 1335
 ypos 267
}
Colorspace {
 inputs 0
 illuminant_in ACES
 primary_in ACES
 colorspace_out CIE-XYZ
 name Colorspace10
 label "AP0 to XYZ"
 xpos -724
 ypos 259
}
ColorMatrix {
 inputs 0
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 name ColorMatrix10
 label "APS4 to XYZ"
 xpos -517
 ypos 259
}
ColorMatrix {
 inputs 0
 matrix {
     {0.9519507289 0.02097472921 0.02707409859}
     {-2.548474004e-05 1.001204967 -0.001179553568}
     {0.2357172072 0.03806844354 0.7262175083}
   }
 name ColorMatrix9
 label "AP0 to APS4"
 xpos -418
 ypos 258
}
ColorMatrix {
 inputs 0
 matrix {
     {0.9889673591 0.02880487405 0.02880487405}
     {-0.4965269566 1.374968052 0.09718866646}
     {0.2285804003 0.05227990076 0.7235780358}
   }
 name ColorMatrix7
 label "XYZ to APS4"
 xpos -609
 ypos 303
}
Group {
 inputs 0
 name MatrixTools
 xpos -509
 ypos 212
 addUserKnob {20 MatrixTools_tab l MatrixTools}
 addUserKnob {22 calculate_matrix l Calculate t "Select 2 or more matrix nodes with or without invert knobs checked.\n\nEach matrix will be multiplied and this node will have the result set.\n\nIf 1 node is selected, that matrix value will be copied to this node (inverted if the invert knob is checked)." T "import nuke\nfloat3x3 = nuke.math.Matrix3\n\ndef matrix_from_node(node):\n    # return 3x3 matrix object from node\n    if not 'matrix' in node.knobs():\n        print('Error: node \{0\} does not contain a matrix knob.'.format(\n            node.fullName()))\n        return None\n    mtx_list = node\['matrix'].getValue()\n    M = float3x3()\n    for i in range(9):\n        M\[i] = mtx_list\[i]\n    if node\['invert'].getValue():\n        M = M.inverse()\n    return M\n    \ndef start():\n    node = nuke.thisNode()\n    selected_nodes = nuke.root().selectedNodes()\n    matrices = \[matrix_from_node(n) for n in selected_nodes if 'matrix' in n.knobs()]\n    if len(matrices) > 1:\n        M = float3x3()\n        num = len(matrices)\n        for i in range(num-1):\n            A = matrices\[i]\n            if i == 0:\n                M = A\n            B = matrices\[i+1]\n            M = M * B\n        node\['matrix'].setValue(M)\n    elif len(matrices) == 1:\n        # Set the matrix \n        node\['matrix'].setValue(matrices\[0])\n        node\['invert'].setValue(0)\n    \n    \nif __name__=='__main__':\n    start()" +STARTLINE}
 addUserKnob {22 create_matrix_node l "Create Matrix" t "Create ColorMatrix node with the current values." -STARTLINE T "node = nuke.thisNode()\n\nnuke.root().begin()\n_ = \[n.setSelected(False) for n in nuke.allNodes(recurseGroups=True)]\nm = nuke.createNode('ColorMatrix')\nm\['matrix'].setValue(node\['matrix'].getValue())\nm.setXYpos(node.xpos()-120, node.ypos())\nm\['label'].setValue(node\['label'].getValue())"}
 addUserKnob {41 matrix T ColorMatrix.matrix}
 addUserKnob {41 invert -STARTLINE T ColorMatrix.invert}
 addUserKnob {22 clear l Clear T "n = nuke.thisNode()\nn\['matrix'].setValue(\[1,0,0,0,1,0,0,0,1])\nn\['label'].setValue('')" +STARTLINE}
 addUserKnob {22 show_matrix l Show t "Show matrix values in a popup window for copying." T "node = nuke.thisNode()\nshow_4x4 = node\['show_matrix_4x4'].getValue()\nshow_commas = node\['show_matrix_commas'].getValue()\n\nif show_commas:\n    sep = ', '\nelse:\n    sep = ' '\n\nmtx = \[format(i, '.8f') for i in node\['matrix'].getValue()]\n\nif show_4x4:\n    z = \['0']\n    mtx = mtx\[0:3] + z + mtx\[3:6] + z + mtx\[6:9] + z*4 + \['1']\n\nnuke.message(sep.join(mtx))" +STARTLINE}
 addUserKnob {6 show_matrix_4x4 l "show 4x4" t "present values in a 4x4 matrix (useful for ocio)" -STARTLINE}
 addUserKnob {6 show_matrix_commas l "show comma sep" t "show matrix comma separated." -STARTLINE}
 addUserKnob {22 save_spimtx l "Save spimtx" T "# inspired by ColorMatrixPlus by hpd\ndef write_spimtx(mtx_node, spimtx_file):\n    mtx_vals = mtx_node\['matrix'].getValue()\n    with open(spimtx_file, \"w\") as f:\n        f.write( \"%3.6f %3.6f %3.6f 0.0\\n\" % (\n            mtx_vals\[0], mtx_vals\[1], mtx_vals\[2]) )\n        f.write( \"%3.6f %3.6f %3.6f 0.0\\n\" % (\n            mtx_vals\[3], mtx_vals\[4], mtx_vals\[5]) )\n        f.write( \"%3.6f %3.6f %3.6f 0.0\\n\" % (\n            mtx_vals\[6], mtx_vals\[7], mtx_vals\[8]) )\n\nnode = nuke.thisNode()\nfilepath = nuke.getFilename('Save Matrix', '*.spimtx')\n\nif filepath:\n    if not filepath.endswith('.spimtx'):\n        filepath = filepath + '.spimtx'\n    write_spimtx(node, filepath)" +STARTLINE}
 addUserKnob {22 load_spimtx l "Load spimtx" -STARTLINE T "# Inspired by ColorMatrixPlus by hpd\ndef load_spimtx(spimtx, mtx_node):\n    with open( spimtx, 'r') as file:\n        lines = file.readlines()\n    matrix_values = list()\n    for line in lines:\n        matrix_values.extend( map(float, line.strip().split(' ')\[0:3]) )\n    mtx_node\['matrix'].setValue(matrix_values)\n\nspimtx = nuke.getFilename('Load SPIMTX', '*.spimtx')\nif spimtx:\n    load_spimtx( spimtx, nuke.thisNode() )\n"}
}
 Input {
  inputs 0
  name Input
  xpos -40
  ypos 206
 }
 ColorMatrix {
  matrix {
      {0.9519507289 0.02097472921 0.02707409859}
      {-2.548474004e-05 1.001204967 -0.001179553568}
      {0.2357172072 0.03806844354 0.7262175083}
    }
  name ColorMatrix
  xpos -40
  ypos 254
 }
 Output {
  name Output
  xpos -40
  ypos 302
 }
end_group
Group {
 inputs 0
 name LogConvert_ACESLog
 xpos -303
 ypos 893
 addUserKnob {20 ACESLog_tab l ACESLog}
 addUserKnob {4 operation M {log2lin lin2log}}
 operation lin2log
 addUserKnob {4 type M {ACEScct ACEScc ACESproxy}}
}
 Input {
  inputs 0
  name Input
  xpos -40
  ypos -10
 }
 Dot {
  name Dot1
  xpos -6
  ypos 74
 }
set Nb2fe1e00 [stack 0]
 Dot {
  name Dot2
  xpos 234
  ypos 74
 }
set Nb2fe2200 [stack 0]
 Dot {
  name Dot3
  xpos 474
  ypos 74
 }
set Nb2fe2600 [stack 0]
 Expression {
  expr0 r<0?0:((log(r)/log(2)+2.5)*50+425)/1023
  expr1 g<0?0:((log(g)/log(2)+2.5)*50+425)/1023
  expr2 b<0?0:((log(b)/log(2)+2.5)*50+425)/1023
  channel3 none
  name lin2log3
  label ACESproxy
  xpos 440
  ypos 108
 }
push $Nb2fe2600
 Expression {
  expr0 pow(2,((r*1023)-425)/50-2.5)
  expr1 pow(2,((g*1023)-425)/50-2.5)
  expr2 pow(2,((b*1023)-425)/50-2.5)
  channel3 none
  name log2lin2
  label ACESproxy
  xpos 322
  ypos 107
 }
 Switch {
  inputs 2
  which {{parent.operation}}
  name Operation2
  xpos 440
  ypos 190
 }
push $Nb2fe2200
 Expression {
  expr0 r<0?(log(pow(2,-16))/log(2)+9.72)/17.52:r<pow(2,-15)?(log(pow(2,-16)+r*0.5)/log(2)+9.72)/17.52:(log(r)/log(2)+9.72)/17.52
  expr1 g<0?(log(pow(2,-16))/log(2)+9.72)/17.52:g<pow(2,-15)?(log(pow(2,-16)+g*0.5)/log(2)+9.72)/17.52:(log(g)/log(2)+9.72)/17.52
  expr2 b<0?(log(pow(2,-16))/log(2)+9.72)/17.52:b<pow(2,-15)?(log(pow(2,-16)+b*0.5)/log(2)+9.72)/17.52:(log(b)/log(2)+9.72)/17.52
  channel3 none
  name lin2log1
  label ACEScc
  xpos 200
  ypos 104
 }
push $Nb2fe2200
 Expression {
  expr0 r<(9.72-15)/17.52?(pow(2,(r*17.52-9.72))-pow(2,-16))*2:pow(2,(r*17.52-9.72))
  expr1 g<(9.72-15)/17.52?(pow(2,(g*17.52-9.72))-pow(2,-16))*2:pow(2,(g*17.52-9.72))
  expr2 b<(9.72-15)/17.52?(pow(2,(b*17.52-9.72))-pow(2,-16))*2:pow(2,(b*17.52-9.72))
  channel3 none
  name log2lin1
  label ACEScc
  xpos 80
  ypos 104
 }
 Switch {
  inputs 2
  which {{parent.operation}}
  name Operation1
  xpos 200
  ypos 190
 }
push $Nb2fe1e00
 Expression {
  temp_name0 cut_lin
  temp_expr0 0.0078125
  temp_name1 cut_log
  temp_expr1 0.155251141552511
  temp_name2 A
  temp_expr2 10.5402377416545
  temp_name3 B
  temp_expr3 0.0729055341958355
  expr0 r<=cut_lin?A*r+B:(log(r)/log(2)+9.72)/17.52
  expr1 g<=cut_lin?A*g+B:(log(g)/log(2)+9.72)/17.52
  expr2 b<=cut_lin?A*b+B:(log(b)/log(2)+9.72)/17.52
  channel3 none
  name lin2log
  label ACEScct
  xpos -40
  ypos 108
 }
push $Nb2fe1e00
 Expression {
  temp_name0 cut_lin
  temp_expr0 0.0078125
  temp_name1 cut_log
  temp_expr1 0.155251141552511
  temp_name2 A
  temp_expr2 10.5402377416545
  temp_name3 B
  temp_expr3 0.0729055341958355
  expr0 r<=cut_log?(r-B)/A:pow(2,r*17.52-9.72)
  expr1 g<=cut_log?(g-B)/A:pow(2,g*17.52-9.72)
  expr2 b<=cut_log?(b-B)/A:pow(2,b*17.52-9.72)
  channel3 none
  name log2lin
  label ACEScct
  xpos -159
  ypos 105
 }
 Switch {
  inputs 2
  which {{parent.operation}}
  name Operation
  xpos -40
  ypos 190
 }
 Switch {
  inputs 3
  which {{parent.type}}
  name Type
  xpos -40
  ypos 312
 }
 Output {
  name Output
  xpos -40
  ypos 430
 }
push $Nb2fe2600
 Expression {
  temp_name0 StepsPerStop
  temp_expr0 50
  temp_name1 MidCVoffset
  temp_expr1 425
  temp_name2 CVmin
  temp_expr2 64
  temp_name3 CVmax
  temp_expr3 940
  expr0 (r<=pow(2,-9.72)?CVmin:max(CVmin,min(CVmax,rint(((log(r)/log(2)+2.5)*StepsPerStop+MidCVoffset)))))/1023
  channel3 none
  name lin2log2
  label "ACESproxy Matching CTL"
  xpos 557
  ypos 104
 }
end_group
push $Nb2fce800
Group {
 name DRT_CAMv5
 label "Input: \[value encoding_in]  / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value white_limit] / \[value peak_luminance]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 611
 ypos 563
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {6 ap1_clamp l "AP1 clamp" t "Clamp input chromaticities to AP1 rendering space" +STARTLINE}
 ap1_clamp true
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {7 peak_luminance l "Peak Luminance" t "Target peak luminance in cd/m^2" R 0 1000}
 peak_luminance 1000
 addUserKnob {6 monochrome t "Output monochrome image" +STARTLINE}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 applyInGamutExpansion l "apply in gamut expansion" t "Expands colorfulness to increase saturation" +STARTLINE}
 applyInGamutExpansion true
 addUserKnob {6 applyInGamutCompression l "apply in gamut compression" +STARTLINE}
 applyInGamutCompression true
 addUserKnob {6 applyReachClamp l "apply reach mode clamp" t "Clamp the chroma compressed result to the rendering space" +STARTLINE}
 addUserKnob {7 compress l "chroma compression" t "Chroma compression amount" R 2 10}
 compress 2.4
 addUserKnob {7 chroma_compress_fact l HDR t "Chroma compression scaling factor for SDR/HDR appearance match.  Smaller values will compress less as peak luminance goes highger, higher values compress more.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 2 6}
 chroma_compress_fact 3.3
 addUserKnob {7 chroma_expand l "chroma expansion" t "Chroma expansion to increase saturation in shadows and mid-tones" R 1 4}
 chroma_expand 1.3
 addUserKnob {7 chroma_expand_fact l HDR t "Chroma expansion scaling factor for SDR/HDR appearance match.  Smaller values will have more saturation as peak luminance goes highger, higher values will have less saturation.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 0.5 0.9}
 chroma_expand_fact 0.69
 addUserKnob {7 chroma_expand_thr l "chroma expansion threshold" t "Threshold for starting chroma expansion, meant to avoid expanding noise floor" R 0.5 1}
 chroma_expand_thr 0.5
 addUserKnob {4 ccReachPrimaries l "reach primaries" t "Primaries that define how far chroma compression and expansion reaches." M {"Chroma Compression Space" AP0-ACES AP1-ACES Rec.2020-D65 ""}}
 ccReachPrimaries AP1-ACES
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" "" "" ""}}
 et None
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 primaries_limit P3
 addUserKnob {4 white_limit l "white point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." -STARTLINE M {"ACES White" D65 "" "" ""}}
 white_limit D65
 addUserKnob {4 primaries_reach l "reach primaries" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "Spectral Locus" "Chroma Compression Space"}}
 primaries_reach AP1-ACES
 addUserKnob {6 reachCompressMode l "Reach Compression Mode" -STARTLINE}
 reachCompressMode true
 addUserKnob {4 boundryIntersectionMethod M {"Original Pekka" "Oct 19" "New From Nick" ""}}
 boundryIntersectionMethod "New From Nick"
 addUserKnob {41 DRT_CAM_Kernel_reachNick l "Use Nick method for reach" -STARTLINE T BlinkScript1.DRT_CAM_Kernel_reachNick}
 addUserKnob {41 DRT_CAM_Kernel_disableUpperHullGamma l disableUpperHullGamma T BlinkScript1.DRT_CAM_Kernel_disableUpperHullGamma}
 addUserKnob {7 upperHullGamma -STARTLINE R 0 2}
 upperHullGamma 1
 addUserKnob {41 DRT_CAM_Kernel_disableLowerHullGamma l disableLowerHullGamma T BlinkScript1.DRT_CAM_Kernel_disableLowerHullGamma}
 addUserKnob {7 lowerHullGamma -STARTLINE R 0 2}
 lowerHullGamma 1.14
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue and mid J.  higher cusps will closer to the cusp lightness, lower cusps will be closer to midJ" R 0.6 2}
 cusp_mid_blend 1.3
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic." R 1.1 2}
 focus_distance 1.35
 addUserKnob {7 focusdistscaling l HDR t "Focus distance scaling factor as peak luminance gets higher for SDR/HDR appearance match.  The projection gets less steep with higher projection\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 1 2}
 focusdistscaling 1.75
 addUserKnob {41 DRT_CAM_Kernel_disableFocusGain l disableFocusGain T BlinkScript1.DRT_CAM_Kernel_disableFocusGain}
 addUserKnob {7 focus_gain_blend l "focus gain blend" t "Blend between cusp J and limitJmax to determine the point where the focus gain is applied.\n\n0 = cuspJ\n1 = limitJmax"}
 focus_gain_blend 0.3
 addUserKnob {7 focusgain l "focus gain" -STARTLINE}
 focusgain 0.55
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.1 1.3 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.12
 addUserKnob {7 smoothJ l "smooth J" t "Smoothing scaling factor for cusp J" R 0 0.1}
 addUserKnob {7 smoothM l "smooth M" t "Smoothing scaling factor for cusp M" -STARTLINE R 0 0.25}
 smoothM 0.27
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out ST2084
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out Rec.2020-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 fit_white l "fit white" t "Scale the output so the maximum RGB channel for the creative white becomes 100%. Prevents clipping when the creative and encoding whites do not match." +STARTLINE}
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" -STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 invert {{master.inverseMode}}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {26 "" l " "}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v060.blink
  recompileCount 4092
  ProgramGroup 1
  KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 925e58f9470501a7d899ac9a2a52d4f33d9c5f59bd24740acef8f1ed9e380ede 2 \"src\" Read Point \"dst\" Write Point 97 \"encodingIn\" Int 1 AAAAAA== \"AP1Clamp\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"peakLuminance\" Float 1 AAAAAA== \"applyChromaCompression\" Bool 1 AA== \"applyInGamutExpansion\" Bool 1 AA== \"applyInGamutCompression\" Bool 1 AA== \"applyReachClamp\" Bool 1 AA== \"monochrome\" Bool 1 AA== \"chroma_compress\" Float 1 AAAAAA== \"Chroma Compress Factor\" Float 1 AACgQA== \"chroma_expand\" Float 1 AAAAAA== \"Chroma Expansion Factor\" Float 1 FK5HPw== \"chroma_expand_thr\" Float 1 AAAAAA== \"cc_et\" Int 1 AAAAAA== \"ccReach\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"primariesLimit\" Int 1 AAAAAA== \"whiteLimit\" Int 1 AAAAAA== \"primariesReach\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"focusAdjustGain\" Float 1 AAAAAA== \"focusGainBlend\" Float 1 AAAAAA== \"disableFocusGain\" Bool 1 AA== \"disableFocusDistScaling\" Bool 1 AA== \"focusDistScaling\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Reachcompressmode\" Bool 1 AA== \"reachNick\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"boundryIntersectionMethod\" Int 1 AAAAAA== \"disableUpperHullGamma\" Bool 1 AA== \"disableLowerHullGamma\" Bool 1 AA== \"lowerHullGamma\" Float 1 AAAAAA== \"upperHullGamma\" Float 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"Smoothing factor cusp J\" Float 1 rkdhPQ== \"Smoothing factor cust M\" Float 1 WmQ7Pg== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"fitWhite\" Bool 1 AA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 97 \"encodingIn\" 1 1 Default \"AP1Clamp\" 1 1 Default \"primariesIn\" 1 1 Default \"toneScaleMode\" 1 1 Default \"discountIlluminant_in\" 1 1 Default \"discountIlluminant_mid\" 1 1 Default \"discountIlluminant_out\" 1 1 Default \"HK_mode_in\" 1 1 Default \"HK_mode_mid\" 1 1 Default \"HK_mode_out\" 1 1 Default \"compressMode\" 1 1 Default \"referenceLuminance\" 1 1 Default \"viewingConditions\" 1 1 Default \"outputViewingConditions\" 1 1 Default \"applyTonecurve\" 1 1 Default \"peakLuminance\" 1 1 Default \"applyChromaCompression\" 1 1 Default \"applyInGamutExpansion\" 1 1 Default \"applyInGamutCompression\" 1 1 Default \"applyReachClamp\" 1 1 Default \"monochrome\" 1 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"cc_et\" 1 1 Default \"ccReach\" 1 1 Default \"crxy\" 2 1 Default \"cgxy\" 2 1 Default \"cbxy\" 2 1 Default \"cwxy\" 2 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"primariesReach\" 1 1 Default \"applyGamutCompression\" 1 1 Default \"cuspMidBlend\" 1 1 Default \"focusDistance\" 1 1 Default \"focusAdjustGain\" 1 1 Default \"focusGainBlend\" 1 1 Default \"disableFocusGain\" 1 1 Default \"disableFocusDistScaling\" 1 1 Default \"focusDistScaling\" 1 1 Default \"compressionFuncParams\" 4 1 Default \"sixAxisCompressionMode\" 1 1 Default \"compressionFuncParamsR\" 4 1 Default \"compressionFuncParamsY\" 4 1 Default \"compressionFuncParamsG\" 4 1 Default \"compressionFuncParamsC\" 4 1 Default \"compressionFuncParamsB\" 4 1 Default \"compressionFuncParamsM\" 4 1 Default \"Reachcompressmode\" 1 1 Default \"reachNick\" 1 1 Default \"Locuscompressmode\" 1 1 Default \"boundryIntersectionMethod\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"smoothCusps\" 1 1 Default \"smoothJ\" 1 1 Default \"smoothM\" 1 1 Default \"encodingOut\" 1 1 Default \"primariesOut\" 1 1 Default \"fitWhite\" 1 1 Default \"clampOutput\" 1 1 Default \"softclampOutput\" 1 1 Default \"clamp_thr\" 1 1 Default \"clamp_dist\" 1 1 Default \"invert\" 1 1 Default \"diagnosticMode\" 1 1 Default \"mmScaleFactor\" 1 1 Default \"daniele_n\" 1 1 Default \"daniele_n_r\" 1 1 Default \"daniele_g\" 1 1 Default \"daniele_c\" 1 1 Default \"daniele_c_d\" 1 1 Default \"daniele_w_g\" 1 1 Default \"daniele_t_1\" 1 1 Default \"daniele_r_hit_min\" 1 1 Default \"daniele_r_hit_max\" 1 1 Default \"catDataSelection\" 1 1 Default \"rxy\" 2 1 Default \"gxy\" 2 1 Default \"bxy\" 2 1 Default \"wxy\" 2 1 Default \"ra\" 1 1 Default \"ba\" 1 1 Default \"XYZ_w\" 3 1 Default \"XYZ_w_scaler\" 1 1 Default \"L_A\" 1 1 Default \"Y_b\" 1 1 Default \"L_B\" 3 1 Default \"userSurround\" 3 1 Default \"discount_illuminant\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default 52 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"compr\" Float 1 1 AAAAAA== \"sat\" Float 1 1 AAAAAA== \"sat_thr\" Float 1 1 AAAAAA== \"focusDist\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"model_gamma\" Float 1 1 AAAAAA== \"gamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutCuspTableReach\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutReachTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"LocusLimitMTable\" Float 1 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingIn;\n\n  // AP1 clamp\n  bool AP1Clamp;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesIn;\n\n  // Tonescale mode\n  // 0: Linear\n  // 1: Daniele Evo Curve\n  int toneScaleMode;\n\n  // Disable Degree of Adaptation\n  // This is only effective if the limit primaries have a non-D65 white point\n  // since the input conversion is assumed to be fully adapted\n  // and the output conversion does not apply a CAT\n  bool discountIlluminant_in;\n  bool discountIlluminant_mid;\n  bool discountIlluminant_out;\n\n  // Toggles for Hellwig 2022 specific params\n  bool HK_mode_in;\n  bool HK_mode_mid;\n  bool HK_mode_out;\n  int  compressMode;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int viewingConditions;\n  int outputViewingConditions;\n\n  // Toggle Tone Mapping\n  bool applyTonecurve;\n\n  // Target Peak Luminance\n  float peakLuminance;\n\n  // Toggle chroma compression\n  bool applyChromaCompression;\n  bool applyInGamutExpansion;\n  bool applyInGamutCompression;\n  bool applyReachClamp;\n  bool monochrome;\n\n  // Chroma compression params\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n  int   cc_et;\n  int   ccReach;\n  // xy coordinates for chroma compression gamut\n  float2 crxy;\n  float2 cgxy;\n  float2 cbxy;\n  float2 cwxy;\n\n  //\n  // Gamut Mapping Parameters\n  //\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Primaries of the Gamut reached by the gamut compressor\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: Spectral Locus\n  // 7: Chroma Compression Space\n  int primariesReach;\n\n  // Toggle Gamut Compression\n  bool applyGamutCompression;\n\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n  #define gamutCuspTableSize 360*1\n\n  // Blend Between Compressing towards\n  // Target Gamut Cusp Luminance (0.0)\n  // and Mid Luminance (1.0)\n  float cuspMidBlend;\n\n  // Focus distance of the compression focal point from the achromatic axis\n  float focusDistance;\n  float focusAdjustGain;\n  float focusGainBlend;\n  bool  disableFocusGain;\n  bool  disableFocusDistScaling;\n  float focusDistScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 compressionFuncParams;\n  bool   sixAxisCompressionMode;\n  float4 compressionFuncParamsR;\n  float4 compressionFuncParamsY;\n  float4 compressionFuncParamsG;\n  float4 compressionFuncParamsC;\n  float4 compressionFuncParamsB;\n  float4 compressionFuncParamsM;\n  bool   Reachcompressmode;\n  bool   reachNick;\n  bool   Locuscompressmode;\n\n  int   boundryIntersectionMethod;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n  float lowerHullGamma;\n  float upperHullGamma;\n\n  // How much the edges of the target RGB cube are smoothed when finding the gamut boundary\n  // in order to reduce visible contours at the gamut cusps\n  float smoothCusps;\n  float smoothJ; // Scaling factor for cusp J\n  float smoothM; // Scaling factor for cusp M\n\n  //\n  // Output Parameters\n  //\n\n  // Encoding of the Output Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingOut;\n\n  // Primaries of the Output Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesOut;\n\n  // Clamp output values to 0.0 - 1.0\n  bool  fitWhite;\n  bool  clampOutput;\n  bool  softclampOutput;\n  float clamp_thr;\n  float clamp_dist;\n\n  //\n  // Extra Parameters\n  //\n\n  // Toggle Inverse Transform\n  bool invert;\n  // Diagnostic path modes\n  int diagnosticMode;\n\n  // DanieleEvoCurve (ACES2 candidate) parameters\n  float mmScaleFactor;\n  float daniele_n;         // peak white\n  float daniele_n_r;       // Normalized white in nits (what 1.0 should be)\n  float daniele_g;         // surround / contrast\n  float daniele_c;         // scene-referred grey\n  float daniele_c_d;       // display-referred grey (in nits)\n  float daniele_w_g;       // grey change between different peak luminance\n  float daniele_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float daniele_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float daniele_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n  // Hellwig 2022 CAM params\n  // the kernel parameters\n\n  // 0 = Stock CAT16\n  // 1 = Thomas's custom primaries\n  // 2 = live from params below\n  int catDataSelection; // original vs modified CAT16 matrix\n  // xy coordinates for custom CAT matrix\n  float2 rxy;\n  float2 gxy;\n  float2 bxy;\n  float2 wxy;\n  float  ra;\n  float  ba;\n\n  // Input vars\n  float3 XYZ_w;\n  float  XYZ_w_scaler;\n  float  L_A;\n  float  Y_b;\n  float3 L_B;\n  float3 userSurround;\n  bool   discount_illuminant;\n  // Output vars\n  float L_A_out;\n  float Y_b_out;\n\nlocal:\n  // Hellwig 2022 constants\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n  float3x3 panlrcm;\n\n  float daniele_r_hit;\n  float daniele_m_0;\n  float daniele_m_1;\n  float daniele_u;\n  float daniele_m;\n  float daniele_w_i;\n  float daniele_c_t;\n  float daniele_g_ip;\n  float daniele_g_ipp2;\n  float daniele_w_2;\n  float daniele_s_2;\n  float daniele_u_2;\n  float daniele_m_2;\n\n  // Chroma compression pre-calculated constants\n  float compr;   // Compression\n  float sat;     // Saturation\n  float sat_thr; // Threshold to start expanding saturation\n\n  // Gamut mapper constants\n  float focusDist; // FocusDistance for projection\n\n  // ST2084 vars\n  float st2084_m_1;\n  float st2084_m_2;\n  float st2084_c_1;\n  float st2084_c_2;\n  float st2084_c_3;\n  float st2084_m_1_d;\n  float st2084_m_2_d;\n  float st2084_L_p;\n\n  // using the float3x3 type to store the array of 6 coefficients\n  // because Blink does not support generic array assignments\n\n  // matrix vars\n  float3x3 identity_matrix;\n\n  float3x3 XYZ_to_RGB_input;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 XYZ_to_RGB_reach;\n  float3x3 XYZ_to_RGB_output;\n\n  float3x3 RGB_to_XYZ_input;\n  float3x3 RGB_to_XYZ_limit;\n  float3x3 RGB_to_XYZ_reach;\n  float3x3 RGB_to_XYZ_output;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n\n  // white points\n  float3 inWhite;\n  float3 outWhite;\n  float3 limitWhite;\n\n  // the maximum RGB value of the limiting gamut\n  float boundaryRGB;\n\n  // the maximum lightness value of the limiting gamut\n  float limitJmax;\n\n  // Middle gray J\n  float midJ;\n\n  // Hellwig model's gamma (1 / cz)\n  float model_gamma;\n\n  // the 'tempTableUnsorted' table is populated\n  // in increments of H of the limiting gamut HSV space starting at H=0.0\n  // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n  // the entries are then wrap-around shifted\n  // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n  // both tables need to be declared here since temporary array variables\n  // in the init() fuction seem to crash Nuke on some systems\n  float3 gamutCuspTable\[gamutCuspTableSize + 1];\n  float3 gamutCuspTableReach\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutReachTable\[gamutCuspTableSize + 1];\n  float2 gamutGammas\[gamutCuspTableSize + 1];\n  float  LocusLimitMTable\[gamutCuspTableSize + 1];\n\n  void define()\n  \{\n    defineParam(chroma_compress_fact, \"Chroma Compress Factor\", 5.0f);\n    defineParam(chroma_expand_fact, \"Chroma Expansion Factor\", 0.78f);\n    defineParam(smoothJ, \"Smoothing factor cusp J\", 0.055f);\n    defineParam(smoothM, \"Smoothing factor cust M\", 0.183f);\n  \}\n\n  // Functions used in ACES 2.0 candidate CAM DRT\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  inline float spow(float base, float exponent)\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ;\n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b)\n\n    // float a_p = sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else\n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if (base < 0.0f && exponent != floor(exponent))\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent);\n    \}\n  \}\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  float3 float3spow(float3 base, float exponent)\n  \{\n    return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  // \"safe\" div\n  float sdiv(float a, float b)\n  \{\n    if (b == 0.0f)\n    \{\n      return 0.0f;\n    \}\n    return a / b;\n  \}\n\n  float degree_of_adaptation(float F, float L_A)\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float  ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d   = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  // basic 3D hypotenuse function, does not deal with under/overflow\n  inline float hypot_float3(float3 xyz)\n  \{\n    return length(xyz);\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float r = R / C;\n    r       = r * r;\n    r       = sqrt(4.0f / r + 1.0f) - 1.0f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float t = 0.5f + sqrt(s * s + r * r / 4.0f);\n    t       = C / t; // t is always >= 0.5f\n\n    xyz_temp = xyz_temp * t + C;\n\n    return xyz_temp;\n  \}\n\n  float3 uncompress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float t = C / R;\n    t       = t - 0.5f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float r = 2 * sqrt(fabs(t * t - s * s)) + 1;\n    r       = sqrt(fabs(r * r - 1));\n    if (r == 0.0)\n      return xyz;\n    r = C * 2 / r;\n\n    xyz_temp = xyz_temp * r + C;\n\n    return xyz_temp;\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float hr)\n  \{\n    return -0.160 * cos(hr) + 0.132 * cos(2 * hr) - 0.405 * sin(hr) + 0.080 * sin(2 * hr) + 0.792;\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n      Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n      Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? spow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n    const float3 F_L_RGB = float3pow(F_L / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, float F_L)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV(float3 RGB)\n  \{\n    float cmax  = max(RGB.x, max(RGB.y, RGB.z));\n    float cmin  = min(RGB.x, min(RGB.y, RGB.z));\n    float delta = cmax - cmin;\n\n    float3 HSV;\n    HSV.x = delta == 0.0f ? 0.0f\n      : cmax == RGB.x     ? (fmod((RGB.y - RGB.z) / delta + 6.0f, 6.0f)) / 6.0f\n      : cmax == RGB.y     ? (((RGB.z - RGB.x) / delta + 2.0f) / 6.0f)\n                          : (((RGB.x - RGB.y) / delta + 4.0f) / 6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a          = JM.y / (focusJ * slope_gain);\n    float b          = 0.0f;\n    float c          = 0.0f;\n    float intersectJ = 0.0f;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      intersectJ = 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      intersectJ = 2.0f * c / (-b + root);\n    \}\n\n    return intersectJ;\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (viewingConditions == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (viewingConditions == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (viewingConditions == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (viewingConditions == 3)\n    \{\n      // Pull from external input\n      newSurround = userSurround;\n    \}\n    return newSurround;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear(float v)\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084(float v)\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f / 2.4f);\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f / 2.6f);\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ          = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh          = XYZ_to_JMh(XYZ, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n    // First matrix to limiting gamut for clamping\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_limit, luminanceXYZ);\n\n    if (fitWhite)\n    \{\n      // Scale to fit maximum creative white channel value\n      float3 creativeWhiteXYZ = vector_dot(RGB_to_XYZ_limit, float3(1.0f, 1.0f, 1.0f)); // TODO: these scaling parameters could be precalculated\n      float3 creativeWhiteRGB = vector_dot(XYZ_to_RGB_output, creativeWhiteXYZ);\n      luminanceRGB *= 1.0f / max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    \}\n\n    if (softclampOutput)\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    if (clampOutput)\n    \{\n      // Clamp to between zero and peak luminance\n      luminanceRGB = clamp3(luminanceRGB, 0.0f, peakLuminance);\n    \}\n\n    // Matrix to output (encoding) gamut (eventually concatenate to a single matrix)\n    luminanceRGB = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceRGB);\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3(encodingOut, luminanceRGB);\n\n    return outputRGB;\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 RGB_to_JMh(const float3 RGB, float3 refWhite, const float3x3& matrix)\n  \{\n    const float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    const float3 XYZ          = vector_dot(matrix, luminanceRGB);\n    const float3 JMh          = XYZ_to_JMh(XYZ, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the given primaries\n  float3 JMh_to_RGB(float3 JMh, float3 refWhite, const float3x3& matrix)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    float3 luminanceRGB = vector_dot(matrix, luminanceXYZ);\n    float3 RGB          = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    XYZ_w = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    if (compressMode)\n    \{\n      RGB_c = compress_bjorn(RGB_c);\n    \}\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n    if (compressMode)\n    \{\n      RGB_a = uncompress_bjorn(RGB_a);\n    \}\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    float R_a = RGB_a.x;\n    float G_a = RGB_a.y;\n    float B_a = RGB_a.z;\n    float a   = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    float b   = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    float hr = atan2(b, a);\n    float h  = wrap_to_360(degrees(hr));\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    float R_a2 = RGB_a.x;\n    float G_a2 = RGB_a.y;\n    float B_a2 = RGB_a.z;\n\n    float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w, surround.y * z);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *chroma* :math:`C`.\n    float C = 35.0f * M / A_w;\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // float s = 100.0f * sdiv(M, Q);\n  \n    if (HK_mode)\n    \{\n      // # *Helmholtz–Kohlrausch* Effect Extension.\n      J = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n      // float Q_HK = (2.0f / surround.y) * (J / 100.0f) * A_w;\n    \}\n    \n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    float J = JMh.x;\n    float M = JMh.y;\n    float h = JMh.z;\n    XYZ_w   = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n    float A_w  = ra * R_aw + G_aw + ba * B_aw;\n\n    float hr = radians(h);\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    float C = (M * 35) / A_w;\n    if (HK_mode)\n    \{\n      J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n    \}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    float P_p_1 = 43.0f * surround.z;\n    float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    float gamma = M / P_p_1;\n    float a     = gamma * cos(hr);\n    float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    if (compressMode)\n    \{\n      RGB_a = compress_bjorn(RGB_a);\n    \}\n\n    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n    if (compressMode)\n    \{\n      RGB_c = uncompress_bjorn(RGB_c);\n    \}\n\n    // # Step 6\n    float3 RGB = RGB_c / D_RGB;\n\n    // # Step 7\n    float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  int find_upper_hue_in_table(float h, float3 table\[], int table_size)\n  \{\n    int low_i  = 0;\n    int high_i = table_size - 1;\n    int i      = hue_position_in_uniform_table(h, table_size);\n\n    while (low_i + 1 < high_i)\n    \{\n      if (h > table\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float2 cuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n    if (h <= gamutCuspTable\[0].z)\n    \{\n      lo   = gamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = gamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > gamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = gamutCuspTable\[high_i - 1];\n      hi = gamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 cuspFromTableLocus(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float lo = LocusLimitMTable\[i_lo];\n    const float hi = LocusLimitMTable\[i_lo + 1];\n\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    const float cuspJ = 69;\n    const float cuspM = lerp(lo, hi, t);\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (h <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  float cReachFromTable(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = cgamutReachTable\[i_lo];\n    const float3 hi = cgamutReachTable\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y       = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float  hr     = radians(h);\n\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + hr) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float _h   = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n             + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    return JMcusp.y * e_t;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f);\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = cusp_with_eccentricity_factor(JMh.z);\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!invert)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      if (applyInGamutCompression)\n      \{\n        // Normalize M with the rendering space cusp M\n        M /= Mnorm;\n\n        // Expand the colorfulness by running the toe function in reverse.  The goal is to\n        // expand less saturated colors less and more saturated colors more.  The expansion\n        // increases saturation in the shadows and mid-tones but not in the highlights.\n        // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n        // the toe less aggressive near black to reduce the expansion of noise.\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n        // Compress the colorfulness.  The goal is to compress less saturated colors more and\n        // more saturated colors less, especially in the highlights.  This step creates the\n        // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n        // mostly affects highlights and mid-tones, and does not compress shadows.\n        M = toe(M, limit, nJ * compr, snJ, 0);\n\n        // Clamp M to the rendering space\n        if (applyReachClamp)\n          M = min(limit, M);\n\n        // Denormalize\n        M *= Mnorm;\n      \}\n    \}\n    else\n    \{\n      if (applyInGamutCompression)\n      \{\n        M /= Mnorm;\n        M = toe(M, limit, nJ * compr, snJ, 1);\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n        M *= Mnorm;\n      \}\n\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    if (AP1Clamp)\n    \{\n      luminanceRGB   = vector_dot(XYZ_to_AP1, luminanceXYZ);\n      luminanceRGB.x = max(0.0f, luminanceRGB.x);\n      luminanceRGB.y = max(0.0f, luminanceRGB.y);\n      luminanceRGB.z = max(0.0f, luminanceRGB.z);\n      luminanceXYZ   = vector_dot(AP1_to_XYZ, luminanceRGB);\n    \}\n\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n    else\n    \{\n      return JMh;\n    \}\n  \}\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB     = luminanceToEncoding3(encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\nfloat Y_to_Hellwig_J(float Y, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n    return sign(Y) * 100.0f * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, surround.y * z);\n  \}\n\n  float Hellwig_J_to_Y(float J, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float A = A_w * pow(fabs(J) / 100.0f, 1.0f / (surround.y * z));\n\n    return sign(J) * 100.0f / F_L * pow((27.13f * A) / (400.0f - A), 1.0f / 0.42f);\n  \}\n\n  float3 forwardTonescale(float3 inputJMh)\n  \{\n    float3 outputJMh;\n    float3 surround    = viewingConditionsToSurround(viewingConditions);\n    float  linear      = Hellwig_J_to_Y(inputJMh.x, surround) / referenceLuminance;\n    float  luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if (toneScaleMode == 1)\n    \{\n      luminanceTS = daniele_evo_fwd(luminanceTS) * mmScaleFactor;\n    \}\n\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, surround);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    if (applyTonecurve)\n    \{\n      outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n      outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    if (monochrome)\n    \{\n      outputJMh.y = 0.0f;\n    \}\n\n    return outputJMh;\n  \}\n\n  float3 inverseTonescale(float3 JMh)\n  \{\n    float3 tonemappedJMh = JMh;\n    float3 surround = viewingConditionsToSurround(viewingConditions);\n\n    if (!applyTonecurve && !applyChromaCompression)\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n\n    float luminance = Hellwig_J_to_Y(tonemappedJMh.x, surround);\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if (toneScaleMode == 1)\n    \{\n      linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n      linear = luminance;\n    \}\n\n    linear = linear * referenceLuminance;\n\n    if (applyTonecurve)\n    \{\n      float untonemappedJ = Y_to_Hellwig_J(linear, surround);\n      untonemappedColourJMh = float3(untonemappedJ, tonemappedJMh.y, tonemappedJMh.z);\n    \}\n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return untonemappedColourJMh;\n  \}\n\n  float2 hueDependantHullGammas(float h)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(h, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    return lerp(gamutGammas\[i_lo], gamutGammas\[i_lo + 1], t);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float gamma_top, float gamma_bottom)\n  \{\n    float2 JM_source = float2(JMh_s.x, JMh_s.y);\n\n    float slope = 0.0f;\n\n    float s = max(0.000001f, smoothness);\n    JM_cusp.x *= 1.0f + smoothJ * s; // J\n    JM_cusp.y *= 1.0f + smoothM * s; // M\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, 1 / gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp)\n      * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), 1.0f / gamma_top) / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, s);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'.\n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.05f, cusp.x / limitJmax), 0.0001f);\n    cusp.y *= 1.0f + 0.18f * s;\n    cusp.x *= 1.0f + 0.07f * s;\n\n    // Line below the cusp is curved with model_gamma\n    float toJ_gamma   = cusp.x * spow(to.x / cusp.x, model_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, model_gamma);\n    t0                = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float2 findCurveIntersection(float c, float2 cusp, float m, float h)\n  \{\n    // based on this desmos plot https://www.desmos.com/calculator/pcsovzirqa\n    float xc = cusp.y;\n    float yc = cusp.x;\n    float f  = 1.0;\n    float mf = m * f;\n    float xi = 1.0f;\n    float g1 = 1.0f / model_gamma;\n    float g2 = hueDependantHullGammas(h).y;\n\n    if (m * xc + c < yc)\n    \{\n      // below cusp\n      xi = spow((1 - mf), (g1 - 1)) * ((yc * spow((c / yc), (1.0 / g1))) / (yc / xc - m));\n    \}\n    else\n    \{\n      // above cusp\n      xi =\n        spow((1 + mf), ((g2 - 1))) * (xc * (limitJmax - yc) * spow(((limitJmax - c) / (limitJmax - yc)), (1 / g2)) / (m * xc + limitJmax - yc));\n    \}\n    float yi = (m * xi) + c;\n    if (yi > limitJmax)\n    \{\n      yi = limitJmax;\n      xi = 0.0f;\n    \}\n    return float2(yi, xi);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus     = cuspFromTableLocus(h);\n    float  cuspTarget100 = cuspLocus.y;\n    float  cuspTarget    = cuspTarget100 * pow((Jmh.x / 100.0f), model_gamma);\n    float  difference    = cuspLocus.y / cuspTarget;\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float3 getReachBoundry(float3 Jmh)\n  \{\n    const float h = Jmh.z;\n\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = gamutCuspTableReach\[i_lo];\n    const float3 hi = gamutCuspTableReach\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n\n    const float reachMaxM = lerp(lo.y, hi.y, t);\n    if (reachNick)\n    \{\n      float2 JMcusp     = cuspFromTable(Jmh.z);\n      float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain = limitJmax * focusDist * getFocusGain(Jmh.x, JMcusp.x);\n      float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n      float  slope;\n      if (intersectJ < focusJ)\n      \{\n        slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      else\n      \{\n        slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      float boundaryNick = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n      return float3(Jmh.x, boundaryNick, Jmh.z);\n    \}\n    float cuspTarget = reachMaxM * pow((Jmh.x / limitJmax), model_gamma);\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n\n    if (Reachcompressmode)\n    \{\n      if (primariesReach != 6) // All of the primary based reach values\n      \{\n        // use primary based reach\n        float locusMax   = getReachBoundry(Jmh).y;\n        float difference = max(1.0001f, locusMax / Jmh.y);\n        float threshold  = max(compressionFuncParams.x, 1.0f / difference);\n        return float4(threshold, difference, difference, compressionFuncParams.w);\n      \}\n      else\n      \{\n        // use locus based reach\n        float locusMax   = getLocusBoundry(Jmh).y;\n        float difference = locusMax / Jmh.y;\n        return float4(compressionFuncParams.x, difference, difference, compressionFuncParams.w);\n      \}\n    \}\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h >= angleR && h < angleY)\n      \{\n        lerpVal = (h - angleR) / (angleY - angleR);\n        return lerp(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h >= angleY && h < angleG)\n      \{\n        lerpVal = (h - angleY) / (angleG - angleY);\n        return lerp(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h >= angleG && h < angleC)\n      \{\n        lerpVal = (h - angleG) / (angleC - angleG);\n        return lerp(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h >= angleC && h < angleB)\n      \{\n        lerpVal = (h - angleC) / (angleB - angleC);\n        return lerp(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h >= angleB && h < angleM)\n      \{\n        lerpVal = (h - angleB) / (angleM - angleB);\n        return lerp(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h >= angleM && h < angleR + 360.0f)\n      \{\n        lerpVal = (h - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h < angleR)\n      \{\n        lerpVal = (h + 360.0f - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  float getFocusGain(float J, float cuspJ)\n  \{\n    if (disableFocusGain)\n      return 1.0f;\n\n    float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J > thr)\n    \{\n      // Approximate inverse required above threshold\n      float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n      return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n    \}\n    else\n    \{\n      // Analytic inverse possible below cusp\n      return 1.0f;\n    \}\n  \}\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    if (disableFocusGain)\n      return compressGamut2(JMh, invert, JMh.x);\n\n    if (!invert)\n    \{\n      return compressGamut2(JMh, 0, JMh.x);\n    \}\n    else\n    \{\n      float2 JMcusp = cuspFromTable(JMh.z);\n      float  Jx     = JMh.x;\n\n      // Analytic inverse below threshold\n      if (Jx <= lerp(JMcusp.x, limitJmax, focusGainBlend))\n        return compressGamut2(JMh, 1, Jx);\n\n      // Approximation above\n      Jx = compressGamut2(JMh, 1, Jx).x;\n      return compressGamut2(JMh, 1, Jx);\n    \}\n  \}\n\n  float3 compressGamut2(float3 JMh, int invert, float Jx)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp       = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDist * JMcusp.y);\n    float a      = max(0.001f, Mratio / focusJ);\n    float b0     = 1.0f - Mratio;\n    float b1     = -(1.0f + Mratio + (a * limitJmax));\n    float b      = project_from.x < focusJ ? b0 : b1;\n    float c0     = -project_from.x;\n    float c1     = project_from.x + limitJmax * Mratio;\n    float c      = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0       = sqrt(b * b - 4 * a * c);\n    float J1       = (-b - J0) / (2 * a);\n    J0             = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    float slope_gain = limitJmax * focusDist * getFocusGain(Jx, JMcusp.x);\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = float2(1.0f, 1.0f);\n    if (boundryIntersectionMethod == 0)\n    \{\n      // Original method implemented by Pekka\n      JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    \}\n    else if (boundryIntersectionMethod == 1)\n    \{\n      // Alternate method shown in Oct 19 meeting\n      float m    = (JMh.x - projectJ) / JMh.y;\n      JMboundary = findCurveIntersection(JMh.x, JMcusp, 0.0f, JMh.z);\n    \}\n    else if (boundryIntersectionMethod == 2)\n    \{\n      const float2 gammas      = hueDependantHullGammas(JMh.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      JMboundary               = float2(nickBoundryReturn.x, nickBoundryReturn.y);\n      project_to               = float2(nickBoundryReturn.z, 0.0f);\n      projectJ                 = nickBoundryReturn.z;\n    \}\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams;\n    if (reachNick)\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMboundary.x, JMboundary.y, JMh.z));\n    \}\n    else\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x, JMboundary.y, JMh.z));\n    \}\n\n    if (!Reachcompressmode)\n      interpolatedCompressionFuncParams.x =\n        1.0f / lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n\n    float lowerMlimit = 0.0001f; // Testing a small value here\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)  // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                                    lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                                    interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 20)\n    \{\n      // return focus point\n      return float3(project_to.x, project_to.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n                            ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit  = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0    = daniele_n / daniele_n_r;\n    daniele_m_1    = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u      = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m      = daniele_m_1 / daniele_u;\n    daniele_w_i    = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t    = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip   = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2    = daniele_c / daniele_g_ipp2;\n    daniele_s_2    = daniele_w_2 * daniele_m_1;\n    daniele_u_2    = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2    = daniele_m_1 / daniele_u_2;\n\n    // 1.0f / (c * z)\n    model_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n\n    // Chroma compression scaling for HDR/SDR appearance match\n    float log_peak = log10(daniele_n / daniele_n_r);\n    compr          = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    sat            = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak);\n    sat_thr        = chroma_expand_thr / daniele_n;\n\n    // Gamut mapper focus distance scaling with peak luminance for\n    // HDR/SDR appearance match.  The projection gets slightly less\n    // steep with higher peak luminance.\n    // https://www.desmos.com/calculator/bnfhjcq5vf\n    if (!disableFocusDistScaling)\n      focusDist = focusDistance + focusDistance * focusDistScaling * log_peak;\n    else\n      focusDist = focusDistance;\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    float CAT_CAT16_data\[] = \{\n      0.401288, 0.650173, -0.051461, -0.250268, 1.204414, 0.045854, -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[] = \{\n      0.656619, 0.342071, 0.00131062, -0.222571, 1.10658, 0.115987, -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[] = \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374,\n      238.0180511, 235.4039917, 233.010849,  230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215,\n      190.9799347, 184.005127,  177.7472992, 172.2332611, 166.6447754, 161.64534,   156.9872284, 152.6203003, 148.3236084, 144.2987976,\n      140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861,\n      114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853,  105.188797,  103.6860809, 102.2319641, 100.8348923, 99.51873779,\n      98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951,  92.03639984, 91.15013885, 90.27630615, 89.43255615,\n      88.63536072, 87.8986969,  87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547,\n      83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156,\n      80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702,\n      80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481,  81.901474,   82.20778656, 82.67211151,\n      83.1408844,  83.62628174, 84.0898056,  84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481,\n      88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783,  94.64561462, 95.68405914, 96.84765625,\n      97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031,\n      113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034,\n      137.8343048, 140.7224121, 143.7820892, 147.23909,   150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272,\n      171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255,\n      199.4234161, 201.3786011, 203.1474609, 205.016037,  206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686,\n      215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463,\n      213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355,\n      195.217453,  193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165,\n      174.445282,  172.4908905, 170.5744934, 168.5490723, 166.459259,  164.4333649, 162.5092621, 160.4579468, 158.491806,  156.6880035,\n      155.0045624, 153.295166,  151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602,\n      139.225174,  137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328,   128.7269897,\n      127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358,  120.9004822,\n      120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039,\n      116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118,\n      114.8510284, 114.8482819, 114.848465,  114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528,  115.7195816,\n      115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586,\n      119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077,  124.071022,  124.9082108, 125.74823,   126.6865311,\n      127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252,  130.1131287, 130.5647278,\n      130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609,  136.6136017, 137.5203552,\n      138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586,\n      150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551,\n      168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373,\n      192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452,  206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306,\n      220.6668701, 223.364151,  226.2115479, 228.9524536, 231.5583954, 234.405304,  237.0275879, 239.5091705, 242.0047455, 242.0177155,\n      244.8230133\};\n\n    // populate the input primaries matrix\n    RGB_to_XYZ_input = generate_RGB_to_XYZ_matrix(primariesIn);\n    XYZ_to_RGB_input = RGB_to_XYZ_input.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(1); // AP1 == 1\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix;\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n    if (whiteLimit == 0)\n    \{\n      limitWhiteForMatrix = float2(0.32168f, 0.33767f);\n    \}\n    else if (whiteLimit == 1)\n    \{\n      limitWhiteForMatrix = float2(0.3127f, 0.3290f);\n    \}\n    else\n    \{\n      limitWhiteForMatrix = float2(0.333333f, 0.333333f);\n    \}\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001, -0.077);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, 0);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    RGB_to_XYZ_reach = generate_RGB_to_XYZ_matrix(primariesReach);\n    XYZ_to_RGB_reach = RGB_to_XYZ_reach.invert();\n\n    RGB_to_XYZ_output = generate_RGB_to_XYZ_matrix(primariesOut);\n    XYZ_to_RGB_output = RGB_to_XYZ_output.invert();\n\n    float3 white(1.0f, 1.0f, 1.0f);\n    inWhite    = vector_dot(RGB_to_XYZ_input, white);\n    outWhite   = vector_dot(RGB_to_XYZ_output, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = peakLuminance / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n      CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n      CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n      CAT_CAT16 = RGBPrimsToXYZMatrix(rxy, gxy, bxy, wxy, 1.0f, 1);\n    \}\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    generate_panlrcm();\n\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    limitJmax = RGB_to_JMh(float3(1.0f), limitWhite, RGB_to_XYZ_limit).x;\n\n    // Cusp table for chroma compression gamut\n    float3x3 RGB_to_XYZ_cgReach;\n    if (ccReach == 0) // Chroma Compression Space (primaries defined in kernel params)\n    \{\n      RGB_to_XYZ_cgReach = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 0);\n\n    \}\n    else if (ccReach == 1)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(0);\n    \}\n    else if (ccReach == 2)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(1);\n    \}\n    else\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(3);\n    \}\n    const float3x3 XYZ_to_RGB_cgReach = RGB_to_XYZ_cgReach.invert();\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, inWhite, RGB_to_XYZ_cgReach);\n    initialise_reach_cusp_table(cgamutReachTable, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_cgReach);\n\n    // With gamut mapper reach mode 7, use the chroma compression reach space with the\n    // gamut mapper.\n    if (primariesReach == 7)\n      XYZ_to_RGB_reach = XYZ_to_RGB_cgReach;\n\n    // Cusp table for limiting gamut\n    initialise_cusp_table(gamutCuspTable, gamutCuspTableSize, limitWhite, RGB_to_XYZ_limit);\n    initialise_reach_cusp_table(gamutCuspTableReach, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_reach);\n\n    midJ = XYZ_to_JMh(inWhite * daniele_c_t * mmScaleFactor, inWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid,\n                      HK_mode_mid)\n             .x;\n\n    initialise_upper_hull_gamma();\n    initialise_lower_hull_gamma();\n  \}\n\n  void initialise_cusp_table(float3 output_table\[], const int table_size, float3 refWhite, const float3x3& matrix)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      tempTableUnsorted\[i] = RGB_to_JMh(RGB, refWhite, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 tableUnsorted\[], const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 output_table\[], const int table_size, const float limitJ, float3 refWhite, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_RGB(float3(limitJ, high, hue), refWhite, matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_RGB(float3(limitJ, sampleM, hue), refWhite, matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, min(1.0, cuspMidBlend - (JMcusp.x / limitJmax)));\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, topGamma, lowerHullGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma()\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        gamutGammas\[i].x =  upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      gamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].x = gamutGammas\[0].x;\n   \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float slope_gain = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n\n      const float3 approxLimit     = findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax,\n                                                                   slope_gain, smoothCusps, upperHullGamma, bottomGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma()\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        gamutGammas\[i].y = lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      gamutGammas\[i].y = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].y = gamutGammas\[0].y;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n    float3 diagnostic;\n\n    if (invert)\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh           = inverseTonescale(tonemappedJMh);\n      diagnostic    = JMh_to_input_RGB(JMh);\n    \}\n    else\n    \{\n      JMh           = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n      diagnostic    = JMh_to_output_RGB(compressedJMh);\n    \}\n\n    if (diagnosticMode == 1 || diagnosticMode == 6)\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if (invert)\n      \{\n        diagnostic = JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic = JMh;\n      \}\n    \}\n    else if (diagnosticMode == 2 || diagnosticMode == 99)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if (diagnosticMode == 3 || diagnosticMode == 5)\n    \{\n      diagnostic = compressedJMh;\n    \}\n    else if (diagnosticMode == 4 || diagnosticMode == 7)\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB     = JMh_to_output_RGB(srcRGB);\n      diagnostic = dstRGB;\n    \}\n    else if (diagnosticMode == 8)\n    \{\n      diagnostic = inWhite;\n    \}\n    else if (diagnosticMode == 9)\n    \{\n      diagnostic = outWhite;\n    \}\n    else if (diagnosticMode == 10)\n    \{\n      diagnostic = limitWhite;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      const float2 JMcusp = cuspFromTable(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      const float2 JMcusp = cuspFromTableLocus(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundary\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundary\n      diagnostic = getReachBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 20)\n    \{\n      // output JMFocus\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 21)\n    \{\n      // output JMFocus\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).y, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 22)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float slope_gain = limitJmax * focusDist;\n      diagnostic       = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 23)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic         = float3(approxLimit.x, approxLimit.y, srcRGB.z);\n    \}\n\n    else if (diagnosticMode == 24)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      float3 newLimitRGB = JMh_to_RGB(float3(approxLimit.x, approxLimit.y, srcRGB.z), limitWhite, XYZ_to_RGB_limit);\n      diagnostic         = newLimitRGB;\n    \}\n\n    else if (diagnosticMode == 25)\n    \{\n      float2 JMcusp            = cuspFromTable(srcRGB.z);\n      float  focusJ            = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain        = limitJmax * focusDist * getFocusGain(JMh.x, JMcusp.x);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(srcRGB, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic               = float3(srcRGB.x, nickBoundryReturn.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 26)\n    \{\n      // XYZ back to luminance RGB\n      float3 JMh = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n      diagnostic = vector_dot(XYZ_to_RGB_limit, JMh);\n    \}\n    else if (diagnosticMode == 27)\n    \{\n      // output\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).x, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 28)\n    \{\n      // output\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      diagnostic    = findGamutBoundaryIntersection(srcRGB, JMcusp, lerp(JMcusp.x, midJ, cuspMidBlend), limitJmax, 10000.0f, 0.0f,\n                                                    gammas.x, gammas.y);\n    \}\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    ////// FORWARD PATHWAY\n\n    else if (diagnosticMode == 100)\n    \{\n      // display encoding to display linear\n      diagnostic      = encodingToLuminance3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 101)\n    \{\n      // convert to linear XYZ luminance values\n      diagnostic = vector_dot(RGB_to_XYZ_input, srcRGB);\n    \}\n    else if (diagnosticMode == 102)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 105)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 106)\n    \{\n      // display luminance XYZ to display linear RGB\n      diagnostic = vector_dot(XYZ_to_RGB_output, srcRGB);\n    \}\n    else if (diagnosticMode == 107)\n    \{\n      // display linear RGB to display encoded RGB\n      diagnostic = luminanceToEncoding3(encodingOut, srcRGB);\n    \}\n\n    ////// INVERSE PATHWAY\n\n    else if (diagnosticMode == 200)\n    \{\n      // output display encoded RGB to display linear RGB\n      diagnostic = encodingToLuminance3(encodingOut, srcRGB);\n    \}\n    else if (diagnosticMode == 201)\n    \{\n      // output display linear RGB to output display linear XYZ\n      diagnostic = vector_dot(RGB_to_XYZ_output, srcRGB);\n    \}\n    else if (diagnosticMode == 202)\n    \{\n      // output XYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 203)\n    \{\n      // uncompress gamut\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 204)\n    \{\n      // inverse tonescale in JMh\n      diagnostic = inverseTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 205)\n    \{\n      // inverted JMh back to XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 206)\n    \{\n      // XYZ back to luminance RGB\n      diagnostic = vector_dot(XYZ_to_RGB_input, srcRGB);\n    \}\n    else if (diagnosticMode == 207)\n    \{\n      // luminance RGB to input encoding RGB\n      diagnostic = luminanceToEncoding3(encodingIn, srcRGB);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_AP1Clamp {{parent.ap1_clamp}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_peakLuminance {{parent.peak_luminance}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_applyInGamutExpansion {{parent.applyInGamutExpansion}}
  DRT_CAM_Kernel_applyInGamutCompression {{parent.applyInGamutCompression}}
  DRT_CAM_Kernel_applyReachClamp {{parent.applyReachClamp}}
  DRT_CAM_Kernel_monochrome {{parent.monochrome}}
  DRT_CAM_Kernel_chroma_compress {{parent.compress}}
  "DRT_CAM_Kernel_Chroma Compress Factor" {{parent.chroma_compress_fact}}
  DRT_CAM_Kernel_chroma_expand {{parent.chroma_expand}}
  "DRT_CAM_Kernel_Chroma Expansion Factor" {{parent.chroma_expand_fact}}
  DRT_CAM_Kernel_chroma_expand_thr {{parent.chroma_expand_thr}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_ccReach {{parent.ccReachPrimaries}}
  DRT_CAM_Kernel_crxy {0.7347 0.2653}
  DRT_CAM_Kernel_cgxy {0.12 0.88}
  DRT_CAM_Kernel_cbxy {0.08 -0.04}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_whiteLimit {{parent.white_limit}}
  DRT_CAM_Kernel_primariesReach {{parent.primaries_reach}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_focusAdjustGain {{parent.focusgain}}
  DRT_CAM_Kernel_focusGainBlend {{parent.focus_gain_blend}}
  DRT_CAM_Kernel_focusDistScaling {{parent.focusdistscaling}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r x272 -1.75} {parent.compression_params.g} {parent.compression_params.b} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR x272 0.21} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Reachcompressmode {{parent.reachCompressMode}}
  DRT_CAM_Kernel_reachNick true
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_boundryIntersectionMethod {{boundryIntersectionMethod}}
  DRT_CAM_Kernel_disableLowerHullGamma true
  DRT_CAM_Kernel_lowerHullGamma {{lowerHullGamma}}
  DRT_CAM_Kernel_upperHullGamma {{parent.upperHullGamma}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  "DRT_CAM_Kernel_Smoothing factor cusp J" {{parent.smoothJ}}
  "DRT_CAM_Kernel_Smoothing factor cust M" {{parent.smoothM}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_fitWhite {{parent.fit_white}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.peak_luminance}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.8336 0.1735}
  DRT_CAM_Kernel_gxy {2.3854 -1.4659}
  DRT_CAM_Kernel_bxy {0.087 -0.125}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
set Nb2fe8e00 [stack 0]
Reformat {
 type scale
 scale 7
 filter impulse
 name Reformat3
 label "scale up 7x"
 xpos 611
 ypos 653
}
Dot {
 name Dot11
 xpos 645
 ypos 685
}
set Nb0345000 [stack 0]
Expression {
 expr0 isnan(r)?0:r
 expr1 isnan(g)?0:g
 expr2 isnan(b)?0:b
 name killNan4
 xpos 657
 ypos 702
}
Clamp {
 minimum -65535
 maximum 65535
 name Clamp2
 xpos 657
 ypos 726
}
Colorspace {
 illuminant_in ACES
 primary_in ACES
 colorspace_out CIE-XYZ
 name Colorspace8
 label "XYZ to AP0"
 xpos 657
 ypos 762
 disable true
}
ColorMatrix {
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 invert true
 name ColorMatrix5
 label "APS4 to XYZ"
 xpos 657
 ypos 794
 disable true
}
Expression {
 temp_name0 cut_lin
 temp_expr0 0.0078125
 temp_name1 cut_log
 temp_expr1 0.155251141552511
 temp_name2 A
 temp_expr2 10.5402377416545
 temp_name3 B
 temp_expr3 0.0729055341958355
 expr0 r<=cut_lin?A*r+B:(log(r)/log(2)+9.72)/17.52
 expr1 g<=cut_lin?A*g+B:(log(g)/log(2)+9.72)/17.52
 expr2 b<=cut_lin?A*b+B:(log(b)/log(2)+9.72)/17.52
 channel3 none
 name lin2log4
 label ACEScct
 xpos 657
 ypos 826
}
push $Nb0345000
Switch {
 inputs 2
 which {{master.inverseMode}}
 name Switch7
 xpos 611
 ypos 875
}
Group {
 name Write_ResolveACES_ODT_LUT10
 label "\[python nuke.thisNode().knob('cubePath').evaluate().split('/').pop(-1)]"
 xpos 611
 ypos 1000
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate CAMDRT
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target "Rec2100 (P3D65 1000nit Limited)"
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate_\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template_AP0.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template_AP0.fltransform
 addUserKnob {1 dctlColorspaceBufferTag}
 dctlColorspaceBufferTag Rec2020_1000nits_15nits_ST2084
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev060/ACES2 Candidate CAMDRT rev060 Rec2100 (P3D65 1000nit Limited)_inverse.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $Nb2fce800
Group {
 name DRT_CAMv4
 label "Input: \[value encoding_in]  / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value white_limit] / \[value peak_luminance]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 458
 ypos 554
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {6 ap1_clamp l "AP1 clamp" t "Clamp input chromaticities to AP1 rendering space" +STARTLINE}
 ap1_clamp true
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {7 peak_luminance l "Peak Luminance" t "Target peak luminance in cd/m^2" R 0 1000}
 peak_luminance 100
 addUserKnob {6 monochrome t "Output monochrome image" +STARTLINE}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 applyInGamutExpansion l "apply in gamut expansion" t "Expands colorfulness to increase saturation" +STARTLINE}
 applyInGamutExpansion true
 addUserKnob {6 applyInGamutCompression l "apply in gamut compression" +STARTLINE}
 applyInGamutCompression true
 addUserKnob {6 applyReachClamp l "apply reach mode clamp" t "Clamp the chroma compressed result to the rendering space" +STARTLINE}
 addUserKnob {7 compress l "chroma compression" t "Chroma compression amount" R 2 10}
 compress 2.4
 addUserKnob {7 chroma_compress_fact l HDR t "Chroma compression scaling factor for SDR/HDR appearance match.  Smaller values will compress less as peak luminance goes highger, higher values compress more.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 2 6}
 chroma_compress_fact 3.3
 addUserKnob {7 chroma_expand l "chroma expansion" t "Chroma expansion to increase saturation in shadows and mid-tones" R 1 4}
 chroma_expand 1.3
 addUserKnob {7 chroma_expand_fact l HDR t "Chroma expansion scaling factor for SDR/HDR appearance match.  Smaller values will have more saturation as peak luminance goes highger, higher values will have less saturation.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 0.5 0.9}
 chroma_expand_fact 0.69
 addUserKnob {7 chroma_expand_thr l "chroma expansion threshold" t "Threshold for starting chroma expansion, meant to avoid expanding noise floor" R 0.5 1}
 chroma_expand_thr 0.5
 addUserKnob {4 ccReachPrimaries l "reach primaries" t "Primaries that define how far chroma compression and expansion reaches." M {"Chroma Compression Space" AP0-ACES AP1-ACES Rec.2020-D65 ""}}
 ccReachPrimaries AP1-ACES
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" "" "" ""}}
 et None
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 primaries_limit P3
 addUserKnob {4 white_limit l "white point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." -STARTLINE M {"ACES White" D65 "" "" ""}}
 white_limit D65
 addUserKnob {4 primaries_reach l "reach primaries" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "Spectral Locus" "Chroma Compression Space"}}
 primaries_reach AP1-ACES
 addUserKnob {6 reachCompressMode l "Reach Compression Mode" -STARTLINE}
 reachCompressMode true
 addUserKnob {4 boundryIntersectionMethod M {"Original Pekka" "Oct 19" "New From Nick" ""}}
 boundryIntersectionMethod "New From Nick"
 addUserKnob {41 DRT_CAM_Kernel_reachNick l "Use Nick method for reach" -STARTLINE T BlinkScript1.DRT_CAM_Kernel_reachNick}
 addUserKnob {41 DRT_CAM_Kernel_disableUpperHullGamma l disableUpperHullGamma T BlinkScript1.DRT_CAM_Kernel_disableUpperHullGamma}
 addUserKnob {7 upperHullGamma -STARTLINE R 0 2}
 upperHullGamma 1
 addUserKnob {41 DRT_CAM_Kernel_disableLowerHullGamma l disableLowerHullGamma T BlinkScript1.DRT_CAM_Kernel_disableLowerHullGamma}
 addUserKnob {7 lowerHullGamma -STARTLINE R 0 2}
 lowerHullGamma 1.14
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue and mid J.  higher cusps will closer to the cusp lightness, lower cusps will be closer to midJ" R 0.6 2}
 cusp_mid_blend 1.3
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic." R 1.1 2}
 focus_distance 1.35
 addUserKnob {7 focusdistscaling l HDR t "Focus distance scaling factor as peak luminance gets higher for SDR/HDR appearance match.  The projection gets less steep with higher projection\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 1 2}
 focusdistscaling 1.75
 addUserKnob {41 DRT_CAM_Kernel_disableFocusGain l disableFocusGain T BlinkScript1.DRT_CAM_Kernel_disableFocusGain}
 addUserKnob {7 focus_gain_blend l "focus gain blend" t "Blend between cusp J and limitJmax to determine the point where the focus gain is applied.\n\n0 = cuspJ\n1 = limitJmax"}
 focus_gain_blend 0.3
 addUserKnob {7 focusgain l "focus gain" -STARTLINE}
 focusgain 0.55
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.1 1.3 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.12
 addUserKnob {7 smoothJ l "smooth J" t "Smoothing scaling factor for cusp J" R 0 0.1}
 addUserKnob {7 smoothM l "smooth M" t "Smoothing scaling factor for cusp M" -STARTLINE R 0 0.25}
 smoothM 0.27
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out "Gamma 2.6"
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 fit_white l "fit white" t "Scale the output so the maximum RGB channel for the creative white becomes 100%. Prevents clipping when the creative and encoding whites do not match." +STARTLINE}
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" -STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 invert {{master.inverseMode}}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {26 "" l " "}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v060.blink
  recompileCount 4092
  ProgramGroup 1
  KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 925e58f9470501a7d899ac9a2a52d4f33d9c5f59bd24740acef8f1ed9e380ede 2 \"src\" Read Point \"dst\" Write Point 97 \"encodingIn\" Int 1 AAAAAA== \"AP1Clamp\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"peakLuminance\" Float 1 AAAAAA== \"applyChromaCompression\" Bool 1 AA== \"applyInGamutExpansion\" Bool 1 AA== \"applyInGamutCompression\" Bool 1 AA== \"applyReachClamp\" Bool 1 AA== \"monochrome\" Bool 1 AA== \"chroma_compress\" Float 1 AAAAAA== \"Chroma Compress Factor\" Float 1 AACgQA== \"chroma_expand\" Float 1 AAAAAA== \"Chroma Expansion Factor\" Float 1 FK5HPw== \"chroma_expand_thr\" Float 1 AAAAAA== \"cc_et\" Int 1 AAAAAA== \"ccReach\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"primariesLimit\" Int 1 AAAAAA== \"whiteLimit\" Int 1 AAAAAA== \"primariesReach\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"focusAdjustGain\" Float 1 AAAAAA== \"focusGainBlend\" Float 1 AAAAAA== \"disableFocusGain\" Bool 1 AA== \"disableFocusDistScaling\" Bool 1 AA== \"focusDistScaling\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Reachcompressmode\" Bool 1 AA== \"reachNick\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"boundryIntersectionMethod\" Int 1 AAAAAA== \"disableUpperHullGamma\" Bool 1 AA== \"disableLowerHullGamma\" Bool 1 AA== \"lowerHullGamma\" Float 1 AAAAAA== \"upperHullGamma\" Float 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"Smoothing factor cusp J\" Float 1 rkdhPQ== \"Smoothing factor cust M\" Float 1 WmQ7Pg== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"fitWhite\" Bool 1 AA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 97 \"encodingIn\" 1 1 Default \"AP1Clamp\" 1 1 Default \"primariesIn\" 1 1 Default \"toneScaleMode\" 1 1 Default \"discountIlluminant_in\" 1 1 Default \"discountIlluminant_mid\" 1 1 Default \"discountIlluminant_out\" 1 1 Default \"HK_mode_in\" 1 1 Default \"HK_mode_mid\" 1 1 Default \"HK_mode_out\" 1 1 Default \"compressMode\" 1 1 Default \"referenceLuminance\" 1 1 Default \"viewingConditions\" 1 1 Default \"outputViewingConditions\" 1 1 Default \"applyTonecurve\" 1 1 Default \"peakLuminance\" 1 1 Default \"applyChromaCompression\" 1 1 Default \"applyInGamutExpansion\" 1 1 Default \"applyInGamutCompression\" 1 1 Default \"applyReachClamp\" 1 1 Default \"monochrome\" 1 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"cc_et\" 1 1 Default \"ccReach\" 1 1 Default \"crxy\" 2 1 Default \"cgxy\" 2 1 Default \"cbxy\" 2 1 Default \"cwxy\" 2 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"primariesReach\" 1 1 Default \"applyGamutCompression\" 1 1 Default \"cuspMidBlend\" 1 1 Default \"focusDistance\" 1 1 Default \"focusAdjustGain\" 1 1 Default \"focusGainBlend\" 1 1 Default \"disableFocusGain\" 1 1 Default \"disableFocusDistScaling\" 1 1 Default \"focusDistScaling\" 1 1 Default \"compressionFuncParams\" 4 1 Default \"sixAxisCompressionMode\" 1 1 Default \"compressionFuncParamsR\" 4 1 Default \"compressionFuncParamsY\" 4 1 Default \"compressionFuncParamsG\" 4 1 Default \"compressionFuncParamsC\" 4 1 Default \"compressionFuncParamsB\" 4 1 Default \"compressionFuncParamsM\" 4 1 Default \"Reachcompressmode\" 1 1 Default \"reachNick\" 1 1 Default \"Locuscompressmode\" 1 1 Default \"boundryIntersectionMethod\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"smoothCusps\" 1 1 Default \"smoothJ\" 1 1 Default \"smoothM\" 1 1 Default \"encodingOut\" 1 1 Default \"primariesOut\" 1 1 Default \"fitWhite\" 1 1 Default \"clampOutput\" 1 1 Default \"softclampOutput\" 1 1 Default \"clamp_thr\" 1 1 Default \"clamp_dist\" 1 1 Default \"invert\" 1 1 Default \"diagnosticMode\" 1 1 Default \"mmScaleFactor\" 1 1 Default \"daniele_n\" 1 1 Default \"daniele_n_r\" 1 1 Default \"daniele_g\" 1 1 Default \"daniele_c\" 1 1 Default \"daniele_c_d\" 1 1 Default \"daniele_w_g\" 1 1 Default \"daniele_t_1\" 1 1 Default \"daniele_r_hit_min\" 1 1 Default \"daniele_r_hit_max\" 1 1 Default \"catDataSelection\" 1 1 Default \"rxy\" 2 1 Default \"gxy\" 2 1 Default \"bxy\" 2 1 Default \"wxy\" 2 1 Default \"ra\" 1 1 Default \"ba\" 1 1 Default \"XYZ_w\" 3 1 Default \"XYZ_w_scaler\" 1 1 Default \"L_A\" 1 1 Default \"Y_b\" 1 1 Default \"L_B\" 3 1 Default \"userSurround\" 3 1 Default \"discount_illuminant\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default 52 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"compr\" Float 1 1 AAAAAA== \"sat\" Float 1 1 AAAAAA== \"sat_thr\" Float 1 1 AAAAAA== \"focusDist\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"model_gamma\" Float 1 1 AAAAAA== \"gamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutCuspTableReach\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutReachTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"LocusLimitMTable\" Float 1 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingIn;\n\n  // AP1 clamp\n  bool AP1Clamp;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesIn;\n\n  // Tonescale mode\n  // 0: Linear\n  // 1: Daniele Evo Curve\n  int toneScaleMode;\n\n  // Disable Degree of Adaptation\n  // This is only effective if the limit primaries have a non-D65 white point\n  // since the input conversion is assumed to be fully adapted\n  // and the output conversion does not apply a CAT\n  bool discountIlluminant_in;\n  bool discountIlluminant_mid;\n  bool discountIlluminant_out;\n\n  // Toggles for Hellwig 2022 specific params\n  bool HK_mode_in;\n  bool HK_mode_mid;\n  bool HK_mode_out;\n  int  compressMode;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int viewingConditions;\n  int outputViewingConditions;\n\n  // Toggle Tone Mapping\n  bool applyTonecurve;\n\n  // Target Peak Luminance\n  float peakLuminance;\n\n  // Toggle chroma compression\n  bool applyChromaCompression;\n  bool applyInGamutExpansion;\n  bool applyInGamutCompression;\n  bool applyReachClamp;\n  bool monochrome;\n\n  // Chroma compression params\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n  int   cc_et;\n  int   ccReach;\n  // xy coordinates for chroma compression gamut\n  float2 crxy;\n  float2 cgxy;\n  float2 cbxy;\n  float2 cwxy;\n\n  //\n  // Gamut Mapping Parameters\n  //\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Primaries of the Gamut reached by the gamut compressor\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: Spectral Locus\n  // 7: Chroma Compression Space\n  int primariesReach;\n\n  // Toggle Gamut Compression\n  bool applyGamutCompression;\n\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n  #define gamutCuspTableSize 360*1\n\n  // Blend Between Compressing towards\n  // Target Gamut Cusp Luminance (0.0)\n  // and Mid Luminance (1.0)\n  float cuspMidBlend;\n\n  // Focus distance of the compression focal point from the achromatic axis\n  float focusDistance;\n  float focusAdjustGain;\n  float focusGainBlend;\n  bool  disableFocusGain;\n  bool  disableFocusDistScaling;\n  float focusDistScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 compressionFuncParams;\n  bool   sixAxisCompressionMode;\n  float4 compressionFuncParamsR;\n  float4 compressionFuncParamsY;\n  float4 compressionFuncParamsG;\n  float4 compressionFuncParamsC;\n  float4 compressionFuncParamsB;\n  float4 compressionFuncParamsM;\n  bool   Reachcompressmode;\n  bool   reachNick;\n  bool   Locuscompressmode;\n\n  int   boundryIntersectionMethod;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n  float lowerHullGamma;\n  float upperHullGamma;\n\n  // How much the edges of the target RGB cube are smoothed when finding the gamut boundary\n  // in order to reduce visible contours at the gamut cusps\n  float smoothCusps;\n  float smoothJ; // Scaling factor for cusp J\n  float smoothM; // Scaling factor for cusp M\n\n  //\n  // Output Parameters\n  //\n\n  // Encoding of the Output Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingOut;\n\n  // Primaries of the Output Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesOut;\n\n  // Clamp output values to 0.0 - 1.0\n  bool  fitWhite;\n  bool  clampOutput;\n  bool  softclampOutput;\n  float clamp_thr;\n  float clamp_dist;\n\n  //\n  // Extra Parameters\n  //\n\n  // Toggle Inverse Transform\n  bool invert;\n  // Diagnostic path modes\n  int diagnosticMode;\n\n  // DanieleEvoCurve (ACES2 candidate) parameters\n  float mmScaleFactor;\n  float daniele_n;         // peak white\n  float daniele_n_r;       // Normalized white in nits (what 1.0 should be)\n  float daniele_g;         // surround / contrast\n  float daniele_c;         // scene-referred grey\n  float daniele_c_d;       // display-referred grey (in nits)\n  float daniele_w_g;       // grey change between different peak luminance\n  float daniele_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float daniele_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float daniele_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n  // Hellwig 2022 CAM params\n  // the kernel parameters\n\n  // 0 = Stock CAT16\n  // 1 = Thomas's custom primaries\n  // 2 = live from params below\n  int catDataSelection; // original vs modified CAT16 matrix\n  // xy coordinates for custom CAT matrix\n  float2 rxy;\n  float2 gxy;\n  float2 bxy;\n  float2 wxy;\n  float  ra;\n  float  ba;\n\n  // Input vars\n  float3 XYZ_w;\n  float  XYZ_w_scaler;\n  float  L_A;\n  float  Y_b;\n  float3 L_B;\n  float3 userSurround;\n  bool   discount_illuminant;\n  // Output vars\n  float L_A_out;\n  float Y_b_out;\n\nlocal:\n  // Hellwig 2022 constants\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n  float3x3 panlrcm;\n\n  float daniele_r_hit;\n  float daniele_m_0;\n  float daniele_m_1;\n  float daniele_u;\n  float daniele_m;\n  float daniele_w_i;\n  float daniele_c_t;\n  float daniele_g_ip;\n  float daniele_g_ipp2;\n  float daniele_w_2;\n  float daniele_s_2;\n  float daniele_u_2;\n  float daniele_m_2;\n\n  // Chroma compression pre-calculated constants\n  float compr;   // Compression\n  float sat;     // Saturation\n  float sat_thr; // Threshold to start expanding saturation\n\n  // Gamut mapper constants\n  float focusDist; // FocusDistance for projection\n\n  // ST2084 vars\n  float st2084_m_1;\n  float st2084_m_2;\n  float st2084_c_1;\n  float st2084_c_2;\n  float st2084_c_3;\n  float st2084_m_1_d;\n  float st2084_m_2_d;\n  float st2084_L_p;\n\n  // using the float3x3 type to store the array of 6 coefficients\n  // because Blink does not support generic array assignments\n\n  // matrix vars\n  float3x3 identity_matrix;\n\n  float3x3 XYZ_to_RGB_input;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 XYZ_to_RGB_reach;\n  float3x3 XYZ_to_RGB_output;\n\n  float3x3 RGB_to_XYZ_input;\n  float3x3 RGB_to_XYZ_limit;\n  float3x3 RGB_to_XYZ_reach;\n  float3x3 RGB_to_XYZ_output;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n\n  // white points\n  float3 inWhite;\n  float3 outWhite;\n  float3 limitWhite;\n\n  // the maximum RGB value of the limiting gamut\n  float boundaryRGB;\n\n  // the maximum lightness value of the limiting gamut\n  float limitJmax;\n\n  // Middle gray J\n  float midJ;\n\n  // Hellwig model's gamma (1 / cz)\n  float model_gamma;\n\n  // the 'tempTableUnsorted' table is populated\n  // in increments of H of the limiting gamut HSV space starting at H=0.0\n  // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n  // the entries are then wrap-around shifted\n  // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n  // both tables need to be declared here since temporary array variables\n  // in the init() fuction seem to crash Nuke on some systems\n  float3 gamutCuspTable\[gamutCuspTableSize + 1];\n  float3 gamutCuspTableReach\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutReachTable\[gamutCuspTableSize + 1];\n  float2 gamutGammas\[gamutCuspTableSize + 1];\n  float  LocusLimitMTable\[gamutCuspTableSize + 1];\n\n  void define()\n  \{\n    defineParam(chroma_compress_fact, \"Chroma Compress Factor\", 5.0f);\n    defineParam(chroma_expand_fact, \"Chroma Expansion Factor\", 0.78f);\n    defineParam(smoothJ, \"Smoothing factor cusp J\", 0.055f);\n    defineParam(smoothM, \"Smoothing factor cust M\", 0.183f);\n  \}\n\n  // Functions used in ACES 2.0 candidate CAM DRT\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  inline float spow(float base, float exponent)\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ;\n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b)\n\n    // float a_p = sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else\n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if (base < 0.0f && exponent != floor(exponent))\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent);\n    \}\n  \}\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  float3 float3spow(float3 base, float exponent)\n  \{\n    return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  // \"safe\" div\n  float sdiv(float a, float b)\n  \{\n    if (b == 0.0f)\n    \{\n      return 0.0f;\n    \}\n    return a / b;\n  \}\n\n  float degree_of_adaptation(float F, float L_A)\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float  ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d   = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  // basic 3D hypotenuse function, does not deal with under/overflow\n  inline float hypot_float3(float3 xyz)\n  \{\n    return length(xyz);\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float r = R / C;\n    r       = r * r;\n    r       = sqrt(4.0f / r + 1.0f) - 1.0f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float t = 0.5f + sqrt(s * s + r * r / 4.0f);\n    t       = C / t; // t is always >= 0.5f\n\n    xyz_temp = xyz_temp * t + C;\n\n    return xyz_temp;\n  \}\n\n  float3 uncompress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float t = C / R;\n    t       = t - 0.5f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float r = 2 * sqrt(fabs(t * t - s * s)) + 1;\n    r       = sqrt(fabs(r * r - 1));\n    if (r == 0.0)\n      return xyz;\n    r = C * 2 / r;\n\n    xyz_temp = xyz_temp * r + C;\n\n    return xyz_temp;\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float hr)\n  \{\n    return -0.160 * cos(hr) + 0.132 * cos(2 * hr) - 0.405 * sin(hr) + 0.080 * sin(2 * hr) + 0.792;\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n      Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n      Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? spow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n    const float3 F_L_RGB = float3pow(F_L / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, float F_L)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV(float3 RGB)\n  \{\n    float cmax  = max(RGB.x, max(RGB.y, RGB.z));\n    float cmin  = min(RGB.x, min(RGB.y, RGB.z));\n    float delta = cmax - cmin;\n\n    float3 HSV;\n    HSV.x = delta == 0.0f ? 0.0f\n      : cmax == RGB.x     ? (fmod((RGB.y - RGB.z) / delta + 6.0f, 6.0f)) / 6.0f\n      : cmax == RGB.y     ? (((RGB.z - RGB.x) / delta + 2.0f) / 6.0f)\n                          : (((RGB.x - RGB.y) / delta + 4.0f) / 6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a          = JM.y / (focusJ * slope_gain);\n    float b          = 0.0f;\n    float c          = 0.0f;\n    float intersectJ = 0.0f;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      intersectJ = 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      intersectJ = 2.0f * c / (-b + root);\n    \}\n\n    return intersectJ;\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (viewingConditions == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (viewingConditions == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (viewingConditions == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (viewingConditions == 3)\n    \{\n      // Pull from external input\n      newSurround = userSurround;\n    \}\n    return newSurround;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear(float v)\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084(float v)\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f / 2.4f);\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f / 2.6f);\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ          = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh          = XYZ_to_JMh(XYZ, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n    // First matrix to limiting gamut for clamping\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_limit, luminanceXYZ);\n\n    if (fitWhite)\n    \{\n      // Scale to fit maximum creative white channel value\n      float3 creativeWhiteXYZ = vector_dot(RGB_to_XYZ_limit, float3(1.0f, 1.0f, 1.0f)); // TODO: these scaling parameters could be precalculated\n      float3 creativeWhiteRGB = vector_dot(XYZ_to_RGB_output, creativeWhiteXYZ);\n      luminanceRGB *= 1.0f / max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    \}\n\n    if (softclampOutput)\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    if (clampOutput)\n    \{\n      // Clamp to between zero and peak luminance\n      luminanceRGB = clamp3(luminanceRGB, 0.0f, peakLuminance);\n    \}\n\n    // Matrix to output (encoding) gamut (eventually concatenate to a single matrix)\n    luminanceRGB = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceRGB);\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3(encodingOut, luminanceRGB);\n\n    return outputRGB;\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 RGB_to_JMh(const float3 RGB, float3 refWhite, const float3x3& matrix)\n  \{\n    const float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    const float3 XYZ          = vector_dot(matrix, luminanceRGB);\n    const float3 JMh          = XYZ_to_JMh(XYZ, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the given primaries\n  float3 JMh_to_RGB(float3 JMh, float3 refWhite, const float3x3& matrix)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    float3 luminanceRGB = vector_dot(matrix, luminanceXYZ);\n    float3 RGB          = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    XYZ_w = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    if (compressMode)\n    \{\n      RGB_c = compress_bjorn(RGB_c);\n    \}\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n    if (compressMode)\n    \{\n      RGB_a = uncompress_bjorn(RGB_a);\n    \}\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    float R_a = RGB_a.x;\n    float G_a = RGB_a.y;\n    float B_a = RGB_a.z;\n    float a   = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    float b   = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    float hr = atan2(b, a);\n    float h  = wrap_to_360(degrees(hr));\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    float R_a2 = RGB_a.x;\n    float G_a2 = RGB_a.y;\n    float B_a2 = RGB_a.z;\n\n    float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w, surround.y * z);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *chroma* :math:`C`.\n    float C = 35.0f * M / A_w;\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // float s = 100.0f * sdiv(M, Q);\n  \n    if (HK_mode)\n    \{\n      // # *Helmholtz–Kohlrausch* Effect Extension.\n      J = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n      // float Q_HK = (2.0f / surround.y) * (J / 100.0f) * A_w;\n    \}\n    \n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    float J = JMh.x;\n    float M = JMh.y;\n    float h = JMh.z;\n    XYZ_w   = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n    float A_w  = ra * R_aw + G_aw + ba * B_aw;\n\n    float hr = radians(h);\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    float C = (M * 35) / A_w;\n    if (HK_mode)\n    \{\n      J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n    \}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    float P_p_1 = 43.0f * surround.z;\n    float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    float gamma = M / P_p_1;\n    float a     = gamma * cos(hr);\n    float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    if (compressMode)\n    \{\n      RGB_a = compress_bjorn(RGB_a);\n    \}\n\n    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n    if (compressMode)\n    \{\n      RGB_c = uncompress_bjorn(RGB_c);\n    \}\n\n    // # Step 6\n    float3 RGB = RGB_c / D_RGB;\n\n    // # Step 7\n    float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  int find_upper_hue_in_table(float h, float3 table\[], int table_size)\n  \{\n    int low_i  = 0;\n    int high_i = table_size - 1;\n    int i      = hue_position_in_uniform_table(h, table_size);\n\n    while (low_i + 1 < high_i)\n    \{\n      if (h > table\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float2 cuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n    if (h <= gamutCuspTable\[0].z)\n    \{\n      lo   = gamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = gamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > gamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = gamutCuspTable\[high_i - 1];\n      hi = gamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 cuspFromTableLocus(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float lo = LocusLimitMTable\[i_lo];\n    const float hi = LocusLimitMTable\[i_lo + 1];\n\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    const float cuspJ = 69;\n    const float cuspM = lerp(lo, hi, t);\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (h <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  float cReachFromTable(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = cgamutReachTable\[i_lo];\n    const float3 hi = cgamutReachTable\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y       = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float  hr     = radians(h);\n\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + hr) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float _h   = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n             + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    return JMcusp.y * e_t;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f);\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = cusp_with_eccentricity_factor(JMh.z);\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!invert)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      if (applyInGamutCompression)\n      \{\n        // Normalize M with the rendering space cusp M\n        M /= Mnorm;\n\n        // Expand the colorfulness by running the toe function in reverse.  The goal is to\n        // expand less saturated colors less and more saturated colors more.  The expansion\n        // increases saturation in the shadows and mid-tones but not in the highlights.\n        // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n        // the toe less aggressive near black to reduce the expansion of noise.\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n        // Compress the colorfulness.  The goal is to compress less saturated colors more and\n        // more saturated colors less, especially in the highlights.  This step creates the\n        // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n        // mostly affects highlights and mid-tones, and does not compress shadows.\n        M = toe(M, limit, nJ * compr, snJ, 0);\n\n        // Clamp M to the rendering space\n        if (applyReachClamp)\n          M = min(limit, M);\n\n        // Denormalize\n        M *= Mnorm;\n      \}\n    \}\n    else\n    \{\n      if (applyInGamutCompression)\n      \{\n        M /= Mnorm;\n        M = toe(M, limit, nJ * compr, snJ, 1);\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n        M *= Mnorm;\n      \}\n\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    if (AP1Clamp)\n    \{\n      luminanceRGB   = vector_dot(XYZ_to_AP1, luminanceXYZ);\n      luminanceRGB.x = max(0.0f, luminanceRGB.x);\n      luminanceRGB.y = max(0.0f, luminanceRGB.y);\n      luminanceRGB.z = max(0.0f, luminanceRGB.z);\n      luminanceXYZ   = vector_dot(AP1_to_XYZ, luminanceRGB);\n    \}\n\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n    else\n    \{\n      return JMh;\n    \}\n  \}\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB     = luminanceToEncoding3(encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\nfloat Y_to_Hellwig_J(float Y, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n    return sign(Y) * 100.0f * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, surround.y * z);\n  \}\n\n  float Hellwig_J_to_Y(float J, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float A = A_w * pow(fabs(J) / 100.0f, 1.0f / (surround.y * z));\n\n    return sign(J) * 100.0f / F_L * pow((27.13f * A) / (400.0f - A), 1.0f / 0.42f);\n  \}\n\n  float3 forwardTonescale(float3 inputJMh)\n  \{\n    float3 outputJMh;\n    float3 surround    = viewingConditionsToSurround(viewingConditions);\n    float  linear      = Hellwig_J_to_Y(inputJMh.x, surround) / referenceLuminance;\n    float  luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if (toneScaleMode == 1)\n    \{\n      luminanceTS = daniele_evo_fwd(luminanceTS) * mmScaleFactor;\n    \}\n\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, surround);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    if (applyTonecurve)\n    \{\n      outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n      outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    if (monochrome)\n    \{\n      outputJMh.y = 0.0f;\n    \}\n\n    return outputJMh;\n  \}\n\n  float3 inverseTonescale(float3 JMh)\n  \{\n    float3 tonemappedJMh = JMh;\n    float3 surround = viewingConditionsToSurround(viewingConditions);\n\n    if (!applyTonecurve && !applyChromaCompression)\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n\n    float luminance = Hellwig_J_to_Y(tonemappedJMh.x, surround);\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if (toneScaleMode == 1)\n    \{\n      linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n      linear = luminance;\n    \}\n\n    linear = linear * referenceLuminance;\n\n    if (applyTonecurve)\n    \{\n      float untonemappedJ = Y_to_Hellwig_J(linear, surround);\n      untonemappedColourJMh = float3(untonemappedJ, tonemappedJMh.y, tonemappedJMh.z);\n    \}\n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return untonemappedColourJMh;\n  \}\n\n  float2 hueDependantHullGammas(float h)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(h, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    return lerp(gamutGammas\[i_lo], gamutGammas\[i_lo + 1], t);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float gamma_top, float gamma_bottom)\n  \{\n    float2 JM_source = float2(JMh_s.x, JMh_s.y);\n\n    float slope = 0.0f;\n\n    float s = max(0.000001f, smoothness);\n    JM_cusp.x *= 1.0f + smoothJ * s; // J\n    JM_cusp.y *= 1.0f + smoothM * s; // M\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, 1 / gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp)\n      * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), 1.0f / gamma_top) / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, s);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'.\n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.05f, cusp.x / limitJmax), 0.0001f);\n    cusp.y *= 1.0f + 0.18f * s;\n    cusp.x *= 1.0f + 0.07f * s;\n\n    // Line below the cusp is curved with model_gamma\n    float toJ_gamma   = cusp.x * spow(to.x / cusp.x, model_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, model_gamma);\n    t0                = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float2 findCurveIntersection(float c, float2 cusp, float m, float h)\n  \{\n    // based on this desmos plot https://www.desmos.com/calculator/pcsovzirqa\n    float xc = cusp.y;\n    float yc = cusp.x;\n    float f  = 1.0;\n    float mf = m * f;\n    float xi = 1.0f;\n    float g1 = 1.0f / model_gamma;\n    float g2 = hueDependantHullGammas(h).y;\n\n    if (m * xc + c < yc)\n    \{\n      // below cusp\n      xi = spow((1 - mf), (g1 - 1)) * ((yc * spow((c / yc), (1.0 / g1))) / (yc / xc - m));\n    \}\n    else\n    \{\n      // above cusp\n      xi =\n        spow((1 + mf), ((g2 - 1))) * (xc * (limitJmax - yc) * spow(((limitJmax - c) / (limitJmax - yc)), (1 / g2)) / (m * xc + limitJmax - yc));\n    \}\n    float yi = (m * xi) + c;\n    if (yi > limitJmax)\n    \{\n      yi = limitJmax;\n      xi = 0.0f;\n    \}\n    return float2(yi, xi);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus     = cuspFromTableLocus(h);\n    float  cuspTarget100 = cuspLocus.y;\n    float  cuspTarget    = cuspTarget100 * pow((Jmh.x / 100.0f), model_gamma);\n    float  difference    = cuspLocus.y / cuspTarget;\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float3 getReachBoundry(float3 Jmh)\n  \{\n    const float h = Jmh.z;\n\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = gamutCuspTableReach\[i_lo];\n    const float3 hi = gamutCuspTableReach\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n\n    const float reachMaxM = lerp(lo.y, hi.y, t);\n    if (reachNick)\n    \{\n      float2 JMcusp     = cuspFromTable(Jmh.z);\n      float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain = limitJmax * focusDist * getFocusGain(Jmh.x, JMcusp.x);\n      float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n      float  slope;\n      if (intersectJ < focusJ)\n      \{\n        slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      else\n      \{\n        slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      float boundaryNick = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n      return float3(Jmh.x, boundaryNick, Jmh.z);\n    \}\n    float cuspTarget = reachMaxM * pow((Jmh.x / limitJmax), model_gamma);\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n\n    if (Reachcompressmode)\n    \{\n      if (primariesReach != 6) // All of the primary based reach values\n      \{\n        // use primary based reach\n        float locusMax   = getReachBoundry(Jmh).y;\n        float difference = max(1.0001f, locusMax / Jmh.y);\n        float threshold  = max(compressionFuncParams.x, 1.0f / difference);\n        return float4(threshold, difference, difference, compressionFuncParams.w);\n      \}\n      else\n      \{\n        // use locus based reach\n        float locusMax   = getLocusBoundry(Jmh).y;\n        float difference = locusMax / Jmh.y;\n        return float4(compressionFuncParams.x, difference, difference, compressionFuncParams.w);\n      \}\n    \}\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h >= angleR && h < angleY)\n      \{\n        lerpVal = (h - angleR) / (angleY - angleR);\n        return lerp(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h >= angleY && h < angleG)\n      \{\n        lerpVal = (h - angleY) / (angleG - angleY);\n        return lerp(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h >= angleG && h < angleC)\n      \{\n        lerpVal = (h - angleG) / (angleC - angleG);\n        return lerp(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h >= angleC && h < angleB)\n      \{\n        lerpVal = (h - angleC) / (angleB - angleC);\n        return lerp(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h >= angleB && h < angleM)\n      \{\n        lerpVal = (h - angleB) / (angleM - angleB);\n        return lerp(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h >= angleM && h < angleR + 360.0f)\n      \{\n        lerpVal = (h - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h < angleR)\n      \{\n        lerpVal = (h + 360.0f - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  float getFocusGain(float J, float cuspJ)\n  \{\n    if (disableFocusGain)\n      return 1.0f;\n\n    float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J > thr)\n    \{\n      // Approximate inverse required above threshold\n      float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n      return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n    \}\n    else\n    \{\n      // Analytic inverse possible below cusp\n      return 1.0f;\n    \}\n  \}\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    if (disableFocusGain)\n      return compressGamut2(JMh, invert, JMh.x);\n\n    if (!invert)\n    \{\n      return compressGamut2(JMh, 0, JMh.x);\n    \}\n    else\n    \{\n      float2 JMcusp = cuspFromTable(JMh.z);\n      float  Jx     = JMh.x;\n\n      // Analytic inverse below threshold\n      if (Jx <= lerp(JMcusp.x, limitJmax, focusGainBlend))\n        return compressGamut2(JMh, 1, Jx);\n\n      // Approximation above\n      Jx = compressGamut2(JMh, 1, Jx).x;\n      return compressGamut2(JMh, 1, Jx);\n    \}\n  \}\n\n  float3 compressGamut2(float3 JMh, int invert, float Jx)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp       = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDist * JMcusp.y);\n    float a      = max(0.001f, Mratio / focusJ);\n    float b0     = 1.0f - Mratio;\n    float b1     = -(1.0f + Mratio + (a * limitJmax));\n    float b      = project_from.x < focusJ ? b0 : b1;\n    float c0     = -project_from.x;\n    float c1     = project_from.x + limitJmax * Mratio;\n    float c      = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0       = sqrt(b * b - 4 * a * c);\n    float J1       = (-b - J0) / (2 * a);\n    J0             = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    float slope_gain = limitJmax * focusDist * getFocusGain(Jx, JMcusp.x);\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = float2(1.0f, 1.0f);\n    if (boundryIntersectionMethod == 0)\n    \{\n      // Original method implemented by Pekka\n      JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    \}\n    else if (boundryIntersectionMethod == 1)\n    \{\n      // Alternate method shown in Oct 19 meeting\n      float m    = (JMh.x - projectJ) / JMh.y;\n      JMboundary = findCurveIntersection(JMh.x, JMcusp, 0.0f, JMh.z);\n    \}\n    else if (boundryIntersectionMethod == 2)\n    \{\n      const float2 gammas      = hueDependantHullGammas(JMh.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      JMboundary               = float2(nickBoundryReturn.x, nickBoundryReturn.y);\n      project_to               = float2(nickBoundryReturn.z, 0.0f);\n      projectJ                 = nickBoundryReturn.z;\n    \}\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams;\n    if (reachNick)\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMboundary.x, JMboundary.y, JMh.z));\n    \}\n    else\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x, JMboundary.y, JMh.z));\n    \}\n\n    if (!Reachcompressmode)\n      interpolatedCompressionFuncParams.x =\n        1.0f / lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n\n    float lowerMlimit = 0.0001f; // Testing a small value here\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)  // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                                    lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                                    interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 20)\n    \{\n      // return focus point\n      return float3(project_to.x, project_to.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n                            ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit  = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0    = daniele_n / daniele_n_r;\n    daniele_m_1    = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u      = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m      = daniele_m_1 / daniele_u;\n    daniele_w_i    = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t    = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip   = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2    = daniele_c / daniele_g_ipp2;\n    daniele_s_2    = daniele_w_2 * daniele_m_1;\n    daniele_u_2    = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2    = daniele_m_1 / daniele_u_2;\n\n    // 1.0f / (c * z)\n    model_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n\n    // Chroma compression scaling for HDR/SDR appearance match\n    float log_peak = log10(daniele_n / daniele_n_r);\n    compr          = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    sat            = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak);\n    sat_thr        = chroma_expand_thr / daniele_n;\n\n    // Gamut mapper focus distance scaling with peak luminance for\n    // HDR/SDR appearance match.  The projection gets slightly less\n    // steep with higher peak luminance.\n    // https://www.desmos.com/calculator/bnfhjcq5vf\n    if (!disableFocusDistScaling)\n      focusDist = focusDistance + focusDistance * focusDistScaling * log_peak;\n    else\n      focusDist = focusDistance;\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    float CAT_CAT16_data\[] = \{\n      0.401288, 0.650173, -0.051461, -0.250268, 1.204414, 0.045854, -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[] = \{\n      0.656619, 0.342071, 0.00131062, -0.222571, 1.10658, 0.115987, -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[] = \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374,\n      238.0180511, 235.4039917, 233.010849,  230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215,\n      190.9799347, 184.005127,  177.7472992, 172.2332611, 166.6447754, 161.64534,   156.9872284, 152.6203003, 148.3236084, 144.2987976,\n      140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861,\n      114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853,  105.188797,  103.6860809, 102.2319641, 100.8348923, 99.51873779,\n      98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951,  92.03639984, 91.15013885, 90.27630615, 89.43255615,\n      88.63536072, 87.8986969,  87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547,\n      83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156,\n      80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702,\n      80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481,  81.901474,   82.20778656, 82.67211151,\n      83.1408844,  83.62628174, 84.0898056,  84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481,\n      88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783,  94.64561462, 95.68405914, 96.84765625,\n      97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031,\n      113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034,\n      137.8343048, 140.7224121, 143.7820892, 147.23909,   150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272,\n      171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255,\n      199.4234161, 201.3786011, 203.1474609, 205.016037,  206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686,\n      215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463,\n      213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355,\n      195.217453,  193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165,\n      174.445282,  172.4908905, 170.5744934, 168.5490723, 166.459259,  164.4333649, 162.5092621, 160.4579468, 158.491806,  156.6880035,\n      155.0045624, 153.295166,  151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602,\n      139.225174,  137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328,   128.7269897,\n      127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358,  120.9004822,\n      120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039,\n      116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118,\n      114.8510284, 114.8482819, 114.848465,  114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528,  115.7195816,\n      115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586,\n      119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077,  124.071022,  124.9082108, 125.74823,   126.6865311,\n      127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252,  130.1131287, 130.5647278,\n      130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609,  136.6136017, 137.5203552,\n      138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586,\n      150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551,\n      168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373,\n      192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452,  206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306,\n      220.6668701, 223.364151,  226.2115479, 228.9524536, 231.5583954, 234.405304,  237.0275879, 239.5091705, 242.0047455, 242.0177155,\n      244.8230133\};\n\n    // populate the input primaries matrix\n    RGB_to_XYZ_input = generate_RGB_to_XYZ_matrix(primariesIn);\n    XYZ_to_RGB_input = RGB_to_XYZ_input.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(1); // AP1 == 1\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix;\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n    if (whiteLimit == 0)\n    \{\n      limitWhiteForMatrix = float2(0.32168f, 0.33767f);\n    \}\n    else if (whiteLimit == 1)\n    \{\n      limitWhiteForMatrix = float2(0.3127f, 0.3290f);\n    \}\n    else\n    \{\n      limitWhiteForMatrix = float2(0.333333f, 0.333333f);\n    \}\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001, -0.077);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, 0);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    RGB_to_XYZ_reach = generate_RGB_to_XYZ_matrix(primariesReach);\n    XYZ_to_RGB_reach = RGB_to_XYZ_reach.invert();\n\n    RGB_to_XYZ_output = generate_RGB_to_XYZ_matrix(primariesOut);\n    XYZ_to_RGB_output = RGB_to_XYZ_output.invert();\n\n    float3 white(1.0f, 1.0f, 1.0f);\n    inWhite    = vector_dot(RGB_to_XYZ_input, white);\n    outWhite   = vector_dot(RGB_to_XYZ_output, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = peakLuminance / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n      CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n      CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n      CAT_CAT16 = RGBPrimsToXYZMatrix(rxy, gxy, bxy, wxy, 1.0f, 1);\n    \}\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    generate_panlrcm();\n\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    limitJmax = RGB_to_JMh(float3(1.0f), limitWhite, RGB_to_XYZ_limit).x;\n\n    // Cusp table for chroma compression gamut\n    float3x3 RGB_to_XYZ_cgReach;\n    if (ccReach == 0) // Chroma Compression Space (primaries defined in kernel params)\n    \{\n      RGB_to_XYZ_cgReach = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 0);\n\n    \}\n    else if (ccReach == 1)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(0);\n    \}\n    else if (ccReach == 2)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(1);\n    \}\n    else\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(3);\n    \}\n    const float3x3 XYZ_to_RGB_cgReach = RGB_to_XYZ_cgReach.invert();\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, inWhite, RGB_to_XYZ_cgReach);\n    initialise_reach_cusp_table(cgamutReachTable, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_cgReach);\n\n    // With gamut mapper reach mode 7, use the chroma compression reach space with the\n    // gamut mapper.\n    if (primariesReach == 7)\n      XYZ_to_RGB_reach = XYZ_to_RGB_cgReach;\n\n    // Cusp table for limiting gamut\n    initialise_cusp_table(gamutCuspTable, gamutCuspTableSize, limitWhite, RGB_to_XYZ_limit);\n    initialise_reach_cusp_table(gamutCuspTableReach, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_reach);\n\n    midJ = XYZ_to_JMh(inWhite * daniele_c_t * mmScaleFactor, inWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid,\n                      HK_mode_mid)\n             .x;\n\n    initialise_upper_hull_gamma();\n    initialise_lower_hull_gamma();\n  \}\n\n  void initialise_cusp_table(float3 output_table\[], const int table_size, float3 refWhite, const float3x3& matrix)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      tempTableUnsorted\[i] = RGB_to_JMh(RGB, refWhite, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 tableUnsorted\[], const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 output_table\[], const int table_size, const float limitJ, float3 refWhite, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_RGB(float3(limitJ, high, hue), refWhite, matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_RGB(float3(limitJ, sampleM, hue), refWhite, matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, min(1.0, cuspMidBlend - (JMcusp.x / limitJmax)));\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, topGamma, lowerHullGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma()\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        gamutGammas\[i].x =  upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      gamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].x = gamutGammas\[0].x;\n   \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float slope_gain = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n\n      const float3 approxLimit     = findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax,\n                                                                   slope_gain, smoothCusps, upperHullGamma, bottomGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma()\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        gamutGammas\[i].y = lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      gamutGammas\[i].y = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].y = gamutGammas\[0].y;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n    float3 diagnostic;\n\n    if (invert)\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh           = inverseTonescale(tonemappedJMh);\n      diagnostic    = JMh_to_input_RGB(JMh);\n    \}\n    else\n    \{\n      JMh           = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n      diagnostic    = JMh_to_output_RGB(compressedJMh);\n    \}\n\n    if (diagnosticMode == 1 || diagnosticMode == 6)\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if (invert)\n      \{\n        diagnostic = JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic = JMh;\n      \}\n    \}\n    else if (diagnosticMode == 2 || diagnosticMode == 99)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if (diagnosticMode == 3 || diagnosticMode == 5)\n    \{\n      diagnostic = compressedJMh;\n    \}\n    else if (diagnosticMode == 4 || diagnosticMode == 7)\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB     = JMh_to_output_RGB(srcRGB);\n      diagnostic = dstRGB;\n    \}\n    else if (diagnosticMode == 8)\n    \{\n      diagnostic = inWhite;\n    \}\n    else if (diagnosticMode == 9)\n    \{\n      diagnostic = outWhite;\n    \}\n    else if (diagnosticMode == 10)\n    \{\n      diagnostic = limitWhite;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      const float2 JMcusp = cuspFromTable(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      const float2 JMcusp = cuspFromTableLocus(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundary\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundary\n      diagnostic = getReachBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 20)\n    \{\n      // output JMFocus\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 21)\n    \{\n      // output JMFocus\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).y, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 22)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float slope_gain = limitJmax * focusDist;\n      diagnostic       = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 23)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic         = float3(approxLimit.x, approxLimit.y, srcRGB.z);\n    \}\n\n    else if (diagnosticMode == 24)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      float3 newLimitRGB = JMh_to_RGB(float3(approxLimit.x, approxLimit.y, srcRGB.z), limitWhite, XYZ_to_RGB_limit);\n      diagnostic         = newLimitRGB;\n    \}\n\n    else if (diagnosticMode == 25)\n    \{\n      float2 JMcusp            = cuspFromTable(srcRGB.z);\n      float  focusJ            = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain        = limitJmax * focusDist * getFocusGain(JMh.x, JMcusp.x);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(srcRGB, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic               = float3(srcRGB.x, nickBoundryReturn.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 26)\n    \{\n      // XYZ back to luminance RGB\n      float3 JMh = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n      diagnostic = vector_dot(XYZ_to_RGB_limit, JMh);\n    \}\n    else if (diagnosticMode == 27)\n    \{\n      // output\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).x, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 28)\n    \{\n      // output\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      diagnostic    = findGamutBoundaryIntersection(srcRGB, JMcusp, lerp(JMcusp.x, midJ, cuspMidBlend), limitJmax, 10000.0f, 0.0f,\n                                                    gammas.x, gammas.y);\n    \}\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    ////// FORWARD PATHWAY\n\n    else if (diagnosticMode == 100)\n    \{\n      // display encoding to display linear\n      diagnostic      = encodingToLuminance3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 101)\n    \{\n      // convert to linear XYZ luminance values\n      diagnostic = vector_dot(RGB_to_XYZ_input, srcRGB);\n    \}\n    else if (diagnosticMode == 102)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 105)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 106)\n    \{\n      // display luminance XYZ to display linear RGB\n      diagnostic = vector_dot(XYZ_to_RGB_output, srcRGB);\n    \}\n    else if (diagnosticMode == 107)\n    \{\n      // display linear RGB to display encoded RGB\n      diagnostic = luminanceToEncoding3(encodingOut, srcRGB);\n    \}\n\n    ////// INVERSE PATHWAY\n\n    else if (diagnosticMode == 200)\n    \{\n      // output display encoded RGB to display linear RGB\n      diagnostic = encodingToLuminance3(encodingOut, srcRGB);\n    \}\n    else if (diagnosticMode == 201)\n    \{\n      // output display linear RGB to output display linear XYZ\n      diagnostic = vector_dot(RGB_to_XYZ_output, srcRGB);\n    \}\n    else if (diagnosticMode == 202)\n    \{\n      // output XYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 203)\n    \{\n      // uncompress gamut\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 204)\n    \{\n      // inverse tonescale in JMh\n      diagnostic = inverseTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 205)\n    \{\n      // inverted JMh back to XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 206)\n    \{\n      // XYZ back to luminance RGB\n      diagnostic = vector_dot(XYZ_to_RGB_input, srcRGB);\n    \}\n    else if (diagnosticMode == 207)\n    \{\n      // luminance RGB to input encoding RGB\n      diagnostic = luminanceToEncoding3(encodingIn, srcRGB);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_AP1Clamp {{parent.ap1_clamp}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_peakLuminance {{parent.peak_luminance}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_applyInGamutExpansion {{parent.applyInGamutExpansion}}
  DRT_CAM_Kernel_applyInGamutCompression {{parent.applyInGamutCompression}}
  DRT_CAM_Kernel_applyReachClamp {{parent.applyReachClamp}}
  DRT_CAM_Kernel_monochrome {{parent.monochrome}}
  DRT_CAM_Kernel_chroma_compress {{parent.compress}}
  "DRT_CAM_Kernel_Chroma Compress Factor" {{parent.chroma_compress_fact}}
  DRT_CAM_Kernel_chroma_expand {{parent.chroma_expand}}
  "DRT_CAM_Kernel_Chroma Expansion Factor" {{parent.chroma_expand_fact}}
  DRT_CAM_Kernel_chroma_expand_thr {{parent.chroma_expand_thr}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_ccReach {{parent.ccReachPrimaries}}
  DRT_CAM_Kernel_crxy {0.7347 0.2653}
  DRT_CAM_Kernel_cgxy {0.12 0.88}
  DRT_CAM_Kernel_cbxy {0.08 -0.04}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_whiteLimit {{parent.white_limit}}
  DRT_CAM_Kernel_primariesReach {{parent.primaries_reach}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_focusAdjustGain {{parent.focusgain}}
  DRT_CAM_Kernel_focusGainBlend {{parent.focus_gain_blend}}
  DRT_CAM_Kernel_focusDistScaling {{parent.focusdistscaling}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r x272 -1.75} {parent.compression_params.g} {parent.compression_params.b} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR x272 0.21} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Reachcompressmode {{parent.reachCompressMode}}
  DRT_CAM_Kernel_reachNick true
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_boundryIntersectionMethod {{boundryIntersectionMethod}}
  DRT_CAM_Kernel_disableLowerHullGamma true
  DRT_CAM_Kernel_lowerHullGamma {{lowerHullGamma}}
  DRT_CAM_Kernel_upperHullGamma {{parent.upperHullGamma}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  "DRT_CAM_Kernel_Smoothing factor cusp J" {{parent.smoothJ}}
  "DRT_CAM_Kernel_Smoothing factor cust M" {{parent.smoothM}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_fitWhite {{parent.fit_white}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.peak_luminance}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.8336 0.1735}
  DRT_CAM_Kernel_gxy {2.3854 -1.4659}
  DRT_CAM_Kernel_bxy {0.087 -0.125}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Reformat {
 type scale
 scale 7
 filter impulse
 name Reformat5
 label "scale up 7x"
 xpos 458
 ypos 658
}
Dot {
 name Dot10
 xpos 492
 ypos 690
}
set Nb047fc00 [stack 0]
Expression {
 expr0 isnan(r)?0:r
 expr1 isnan(g)?0:g
 expr2 isnan(b)?0:b
 name killNan3
 xpos 504
 ypos 707
}
Clamp {
 minimum -65535
 maximum 65535
 name Clamp3
 xpos 504
 ypos 731
}
Colorspace {
 illuminant_in ACES
 primary_in ACES
 colorspace_out CIE-XYZ
 name Colorspace7
 label "XYZ to AP0"
 xpos 504
 ypos 767
 disable true
}
ColorMatrix {
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 invert true
 name ColorMatrix4
 label "APS4 to XYZ"
 xpos 504
 ypos 799
 disable true
}
Expression {
 temp_name0 cut_lin
 temp_expr0 0.0078125
 temp_name1 cut_log
 temp_expr1 0.155251141552511
 temp_name2 A
 temp_expr2 10.5402377416545
 temp_name3 B
 temp_expr3 0.0729055341958355
 expr0 r<=cut_lin?A*r+B:(log(r)/log(2)+9.72)/17.52
 expr1 g<=cut_lin?A*g+B:(log(g)/log(2)+9.72)/17.52
 expr2 b<=cut_lin?A*b+B:(log(b)/log(2)+9.72)/17.52
 channel3 none
 name lin2log3
 label ACEScct
 xpos 504
 ypos 831
}
push $Nb047fc00
Switch {
 inputs 2
 which {{master.inverseMode}}
 name Switch6
 xpos 458
 ypos 879
}
Group {
 name Write_ResolveACES_ODT_LUT9
 label "\[python nuke.thisNode().knob('cubePath').evaluate().split('/').pop(-1)]"
 xpos 458
 ypos 995
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate CAMDRT
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target P3D65
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate_\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template_AP0.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template_AP0.fltransform
 addUserKnob {1 dctlColorspaceBufferTag}
 dctlColorspaceBufferTag P3D65_48nits
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev060/ACES2 Candidate CAMDRT rev060 P3D65_inverse.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $Nb2fce800
Group {
 name DRT_CAMv3
 label "Input: \[value encoding_in]  / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value white_limit] / \[value peak_luminance]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 320
 ypos 556
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {6 ap1_clamp l "AP1 clamp" t "Clamp input chromaticities to AP1 rendering space" +STARTLINE}
 ap1_clamp true
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {7 peak_luminance l "Peak Luminance" t "Target peak luminance in cd/m^2" R 0 1000}
 peak_luminance 100
 addUserKnob {6 monochrome t "Output monochrome image" +STARTLINE}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 applyInGamutExpansion l "apply in gamut expansion" t "Expands colorfulness to increase saturation" +STARTLINE}
 applyInGamutExpansion true
 addUserKnob {6 applyInGamutCompression l "apply in gamut compression" +STARTLINE}
 applyInGamutCompression true
 addUserKnob {6 applyReachClamp l "apply reach mode clamp" t "Clamp the chroma compressed result to the rendering space" +STARTLINE}
 addUserKnob {7 compress l "chroma compression" t "Chroma compression amount" R 2 10}
 compress 2.4
 addUserKnob {7 chroma_compress_fact l HDR t "Chroma compression scaling factor for SDR/HDR appearance match.  Smaller values will compress less as peak luminance goes highger, higher values compress more.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 2 6}
 chroma_compress_fact 3.3
 addUserKnob {7 chroma_expand l "chroma expansion" t "Chroma expansion to increase saturation in shadows and mid-tones" R 1 4}
 chroma_expand 1.3
 addUserKnob {7 chroma_expand_fact l HDR t "Chroma expansion scaling factor for SDR/HDR appearance match.  Smaller values will have more saturation as peak luminance goes highger, higher values will have less saturation.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 0.5 0.9}
 chroma_expand_fact 0.69
 addUserKnob {7 chroma_expand_thr l "chroma expansion threshold" t "Threshold for starting chroma expansion, meant to avoid expanding noise floor" R 0.5 1}
 chroma_expand_thr 0.5
 addUserKnob {4 ccReachPrimaries l "reach primaries" t "Primaries that define how far chroma compression and expansion reaches." M {"Chroma Compression Space" AP0-ACES AP1-ACES Rec.2020-D65 ""}}
 ccReachPrimaries AP1-ACES
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" "" "" ""}}
 et None
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 primaries_limit sRGB/Rec.709
 addUserKnob {4 white_limit l "white point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." -STARTLINE M {"ACES White" D65 "" "" ""}}
 white_limit D65
 addUserKnob {4 primaries_reach l "reach primaries" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "Spectral Locus" "Chroma Compression Space"}}
 primaries_reach AP1-ACES
 addUserKnob {6 reachCompressMode l "Reach Compression Mode" -STARTLINE}
 reachCompressMode true
 addUserKnob {4 boundryIntersectionMethod M {"Original Pekka" "Oct 19" "New From Nick" ""}}
 boundryIntersectionMethod "New From Nick"
 addUserKnob {41 DRT_CAM_Kernel_reachNick l "Use Nick method for reach" -STARTLINE T BlinkScript1.DRT_CAM_Kernel_reachNick}
 addUserKnob {41 DRT_CAM_Kernel_disableUpperHullGamma l disableUpperHullGamma T BlinkScript1.DRT_CAM_Kernel_disableUpperHullGamma}
 addUserKnob {7 upperHullGamma -STARTLINE R 0 2}
 upperHullGamma 1
 addUserKnob {41 DRT_CAM_Kernel_disableLowerHullGamma l disableLowerHullGamma T BlinkScript1.DRT_CAM_Kernel_disableLowerHullGamma}
 addUserKnob {7 lowerHullGamma -STARTLINE R 0 2}
 lowerHullGamma 1.14
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue and mid J.  higher cusps will closer to the cusp lightness, lower cusps will be closer to midJ" R 0.6 2}
 cusp_mid_blend 1.3
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic." R 1.1 2}
 focus_distance 1.35
 addUserKnob {7 focusdistscaling l HDR t "Focus distance scaling factor as peak luminance gets higher for SDR/HDR appearance match.  The projection gets less steep with higher projection\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 1 2}
 focusdistscaling 1.75
 addUserKnob {41 DRT_CAM_Kernel_disableFocusGain l disableFocusGain T BlinkScript1.DRT_CAM_Kernel_disableFocusGain}
 addUserKnob {7 focus_gain_blend l "focus gain blend" t "Blend between cusp J and limitJmax to determine the point where the focus gain is applied.\n\n0 = cuspJ\n1 = limitJmax"}
 focus_gain_blend 0.3
 addUserKnob {7 focusgain l "focus gain" -STARTLINE}
 focusgain 0.55
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.1 1.3 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.12
 addUserKnob {7 smoothJ l "smooth J" t "Smoothing scaling factor for cusp J" R 0 0.1}
 addUserKnob {7 smoothM l "smooth M" t "Smoothing scaling factor for cusp M" -STARTLINE R 0 0.25}
 smoothM 0.27
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out "Gamma 2.6"
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 fit_white l "fit white" t "Scale the output so the maximum RGB channel for the creative white becomes 100%. Prevents clipping when the creative and encoding whites do not match." +STARTLINE}
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" -STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 invert {{master.inverseMode}}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {26 "" l " "}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v060.blink
  recompileCount 4092
  ProgramGroup 1
  KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 925e58f9470501a7d899ac9a2a52d4f33d9c5f59bd24740acef8f1ed9e380ede 2 \"src\" Read Point \"dst\" Write Point 97 \"encodingIn\" Int 1 AAAAAA== \"AP1Clamp\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"peakLuminance\" Float 1 AAAAAA== \"applyChromaCompression\" Bool 1 AA== \"applyInGamutExpansion\" Bool 1 AA== \"applyInGamutCompression\" Bool 1 AA== \"applyReachClamp\" Bool 1 AA== \"monochrome\" Bool 1 AA== \"chroma_compress\" Float 1 AAAAAA== \"Chroma Compress Factor\" Float 1 AACgQA== \"chroma_expand\" Float 1 AAAAAA== \"Chroma Expansion Factor\" Float 1 FK5HPw== \"chroma_expand_thr\" Float 1 AAAAAA== \"cc_et\" Int 1 AAAAAA== \"ccReach\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"primariesLimit\" Int 1 AAAAAA== \"whiteLimit\" Int 1 AAAAAA== \"primariesReach\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"focusAdjustGain\" Float 1 AAAAAA== \"focusGainBlend\" Float 1 AAAAAA== \"disableFocusGain\" Bool 1 AA== \"disableFocusDistScaling\" Bool 1 AA== \"focusDistScaling\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Reachcompressmode\" Bool 1 AA== \"reachNick\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"boundryIntersectionMethod\" Int 1 AAAAAA== \"disableUpperHullGamma\" Bool 1 AA== \"disableLowerHullGamma\" Bool 1 AA== \"lowerHullGamma\" Float 1 AAAAAA== \"upperHullGamma\" Float 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"Smoothing factor cusp J\" Float 1 rkdhPQ== \"Smoothing factor cust M\" Float 1 WmQ7Pg== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"fitWhite\" Bool 1 AA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 97 \"encodingIn\" 1 1 Default \"AP1Clamp\" 1 1 Default \"primariesIn\" 1 1 Default \"toneScaleMode\" 1 1 Default \"discountIlluminant_in\" 1 1 Default \"discountIlluminant_mid\" 1 1 Default \"discountIlluminant_out\" 1 1 Default \"HK_mode_in\" 1 1 Default \"HK_mode_mid\" 1 1 Default \"HK_mode_out\" 1 1 Default \"compressMode\" 1 1 Default \"referenceLuminance\" 1 1 Default \"viewingConditions\" 1 1 Default \"outputViewingConditions\" 1 1 Default \"applyTonecurve\" 1 1 Default \"peakLuminance\" 1 1 Default \"applyChromaCompression\" 1 1 Default \"applyInGamutExpansion\" 1 1 Default \"applyInGamutCompression\" 1 1 Default \"applyReachClamp\" 1 1 Default \"monochrome\" 1 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"cc_et\" 1 1 Default \"ccReach\" 1 1 Default \"crxy\" 2 1 Default \"cgxy\" 2 1 Default \"cbxy\" 2 1 Default \"cwxy\" 2 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"primariesReach\" 1 1 Default \"applyGamutCompression\" 1 1 Default \"cuspMidBlend\" 1 1 Default \"focusDistance\" 1 1 Default \"focusAdjustGain\" 1 1 Default \"focusGainBlend\" 1 1 Default \"disableFocusGain\" 1 1 Default \"disableFocusDistScaling\" 1 1 Default \"focusDistScaling\" 1 1 Default \"compressionFuncParams\" 4 1 Default \"sixAxisCompressionMode\" 1 1 Default \"compressionFuncParamsR\" 4 1 Default \"compressionFuncParamsY\" 4 1 Default \"compressionFuncParamsG\" 4 1 Default \"compressionFuncParamsC\" 4 1 Default \"compressionFuncParamsB\" 4 1 Default \"compressionFuncParamsM\" 4 1 Default \"Reachcompressmode\" 1 1 Default \"reachNick\" 1 1 Default \"Locuscompressmode\" 1 1 Default \"boundryIntersectionMethod\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"smoothCusps\" 1 1 Default \"smoothJ\" 1 1 Default \"smoothM\" 1 1 Default \"encodingOut\" 1 1 Default \"primariesOut\" 1 1 Default \"fitWhite\" 1 1 Default \"clampOutput\" 1 1 Default \"softclampOutput\" 1 1 Default \"clamp_thr\" 1 1 Default \"clamp_dist\" 1 1 Default \"invert\" 1 1 Default \"diagnosticMode\" 1 1 Default \"mmScaleFactor\" 1 1 Default \"daniele_n\" 1 1 Default \"daniele_n_r\" 1 1 Default \"daniele_g\" 1 1 Default \"daniele_c\" 1 1 Default \"daniele_c_d\" 1 1 Default \"daniele_w_g\" 1 1 Default \"daniele_t_1\" 1 1 Default \"daniele_r_hit_min\" 1 1 Default \"daniele_r_hit_max\" 1 1 Default \"catDataSelection\" 1 1 Default \"rxy\" 2 1 Default \"gxy\" 2 1 Default \"bxy\" 2 1 Default \"wxy\" 2 1 Default \"ra\" 1 1 Default \"ba\" 1 1 Default \"XYZ_w\" 3 1 Default \"XYZ_w_scaler\" 1 1 Default \"L_A\" 1 1 Default \"Y_b\" 1 1 Default \"L_B\" 3 1 Default \"userSurround\" 3 1 Default \"discount_illuminant\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default 52 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"compr\" Float 1 1 AAAAAA== \"sat\" Float 1 1 AAAAAA== \"sat_thr\" Float 1 1 AAAAAA== \"focusDist\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"model_gamma\" Float 1 1 AAAAAA== \"gamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutCuspTableReach\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutReachTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"LocusLimitMTable\" Float 1 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingIn;\n\n  // AP1 clamp\n  bool AP1Clamp;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesIn;\n\n  // Tonescale mode\n  // 0: Linear\n  // 1: Daniele Evo Curve\n  int toneScaleMode;\n\n  // Disable Degree of Adaptation\n  // This is only effective if the limit primaries have a non-D65 white point\n  // since the input conversion is assumed to be fully adapted\n  // and the output conversion does not apply a CAT\n  bool discountIlluminant_in;\n  bool discountIlluminant_mid;\n  bool discountIlluminant_out;\n\n  // Toggles for Hellwig 2022 specific params\n  bool HK_mode_in;\n  bool HK_mode_mid;\n  bool HK_mode_out;\n  int  compressMode;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int viewingConditions;\n  int outputViewingConditions;\n\n  // Toggle Tone Mapping\n  bool applyTonecurve;\n\n  // Target Peak Luminance\n  float peakLuminance;\n\n  // Toggle chroma compression\n  bool applyChromaCompression;\n  bool applyInGamutExpansion;\n  bool applyInGamutCompression;\n  bool applyReachClamp;\n  bool monochrome;\n\n  // Chroma compression params\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n  int   cc_et;\n  int   ccReach;\n  // xy coordinates for chroma compression gamut\n  float2 crxy;\n  float2 cgxy;\n  float2 cbxy;\n  float2 cwxy;\n\n  //\n  // Gamut Mapping Parameters\n  //\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Primaries of the Gamut reached by the gamut compressor\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: Spectral Locus\n  // 7: Chroma Compression Space\n  int primariesReach;\n\n  // Toggle Gamut Compression\n  bool applyGamutCompression;\n\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n  #define gamutCuspTableSize 360*1\n\n  // Blend Between Compressing towards\n  // Target Gamut Cusp Luminance (0.0)\n  // and Mid Luminance (1.0)\n  float cuspMidBlend;\n\n  // Focus distance of the compression focal point from the achromatic axis\n  float focusDistance;\n  float focusAdjustGain;\n  float focusGainBlend;\n  bool  disableFocusGain;\n  bool  disableFocusDistScaling;\n  float focusDistScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 compressionFuncParams;\n  bool   sixAxisCompressionMode;\n  float4 compressionFuncParamsR;\n  float4 compressionFuncParamsY;\n  float4 compressionFuncParamsG;\n  float4 compressionFuncParamsC;\n  float4 compressionFuncParamsB;\n  float4 compressionFuncParamsM;\n  bool   Reachcompressmode;\n  bool   reachNick;\n  bool   Locuscompressmode;\n\n  int   boundryIntersectionMethod;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n  float lowerHullGamma;\n  float upperHullGamma;\n\n  // How much the edges of the target RGB cube are smoothed when finding the gamut boundary\n  // in order to reduce visible contours at the gamut cusps\n  float smoothCusps;\n  float smoothJ; // Scaling factor for cusp J\n  float smoothM; // Scaling factor for cusp M\n\n  //\n  // Output Parameters\n  //\n\n  // Encoding of the Output Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingOut;\n\n  // Primaries of the Output Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesOut;\n\n  // Clamp output values to 0.0 - 1.0\n  bool  fitWhite;\n  bool  clampOutput;\n  bool  softclampOutput;\n  float clamp_thr;\n  float clamp_dist;\n\n  //\n  // Extra Parameters\n  //\n\n  // Toggle Inverse Transform\n  bool invert;\n  // Diagnostic path modes\n  int diagnosticMode;\n\n  // DanieleEvoCurve (ACES2 candidate) parameters\n  float mmScaleFactor;\n  float daniele_n;         // peak white\n  float daniele_n_r;       // Normalized white in nits (what 1.0 should be)\n  float daniele_g;         // surround / contrast\n  float daniele_c;         // scene-referred grey\n  float daniele_c_d;       // display-referred grey (in nits)\n  float daniele_w_g;       // grey change between different peak luminance\n  float daniele_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float daniele_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float daniele_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n  // Hellwig 2022 CAM params\n  // the kernel parameters\n\n  // 0 = Stock CAT16\n  // 1 = Thomas's custom primaries\n  // 2 = live from params below\n  int catDataSelection; // original vs modified CAT16 matrix\n  // xy coordinates for custom CAT matrix\n  float2 rxy;\n  float2 gxy;\n  float2 bxy;\n  float2 wxy;\n  float  ra;\n  float  ba;\n\n  // Input vars\n  float3 XYZ_w;\n  float  XYZ_w_scaler;\n  float  L_A;\n  float  Y_b;\n  float3 L_B;\n  float3 userSurround;\n  bool   discount_illuminant;\n  // Output vars\n  float L_A_out;\n  float Y_b_out;\n\nlocal:\n  // Hellwig 2022 constants\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n  float3x3 panlrcm;\n\n  float daniele_r_hit;\n  float daniele_m_0;\n  float daniele_m_1;\n  float daniele_u;\n  float daniele_m;\n  float daniele_w_i;\n  float daniele_c_t;\n  float daniele_g_ip;\n  float daniele_g_ipp2;\n  float daniele_w_2;\n  float daniele_s_2;\n  float daniele_u_2;\n  float daniele_m_2;\n\n  // Chroma compression pre-calculated constants\n  float compr;   // Compression\n  float sat;     // Saturation\n  float sat_thr; // Threshold to start expanding saturation\n\n  // Gamut mapper constants\n  float focusDist; // FocusDistance for projection\n\n  // ST2084 vars\n  float st2084_m_1;\n  float st2084_m_2;\n  float st2084_c_1;\n  float st2084_c_2;\n  float st2084_c_3;\n  float st2084_m_1_d;\n  float st2084_m_2_d;\n  float st2084_L_p;\n\n  // using the float3x3 type to store the array of 6 coefficients\n  // because Blink does not support generic array assignments\n\n  // matrix vars\n  float3x3 identity_matrix;\n\n  float3x3 XYZ_to_RGB_input;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 XYZ_to_RGB_reach;\n  float3x3 XYZ_to_RGB_output;\n\n  float3x3 RGB_to_XYZ_input;\n  float3x3 RGB_to_XYZ_limit;\n  float3x3 RGB_to_XYZ_reach;\n  float3x3 RGB_to_XYZ_output;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n\n  // white points\n  float3 inWhite;\n  float3 outWhite;\n  float3 limitWhite;\n\n  // the maximum RGB value of the limiting gamut\n  float boundaryRGB;\n\n  // the maximum lightness value of the limiting gamut\n  float limitJmax;\n\n  // Middle gray J\n  float midJ;\n\n  // Hellwig model's gamma (1 / cz)\n  float model_gamma;\n\n  // the 'tempTableUnsorted' table is populated\n  // in increments of H of the limiting gamut HSV space starting at H=0.0\n  // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n  // the entries are then wrap-around shifted\n  // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n  // both tables need to be declared here since temporary array variables\n  // in the init() fuction seem to crash Nuke on some systems\n  float3 gamutCuspTable\[gamutCuspTableSize + 1];\n  float3 gamutCuspTableReach\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutReachTable\[gamutCuspTableSize + 1];\n  float2 gamutGammas\[gamutCuspTableSize + 1];\n  float  LocusLimitMTable\[gamutCuspTableSize + 1];\n\n  void define()\n  \{\n    defineParam(chroma_compress_fact, \"Chroma Compress Factor\", 5.0f);\n    defineParam(chroma_expand_fact, \"Chroma Expansion Factor\", 0.78f);\n    defineParam(smoothJ, \"Smoothing factor cusp J\", 0.055f);\n    defineParam(smoothM, \"Smoothing factor cust M\", 0.183f);\n  \}\n\n  // Functions used in ACES 2.0 candidate CAM DRT\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  inline float spow(float base, float exponent)\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ;\n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b)\n\n    // float a_p = sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else\n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if (base < 0.0f && exponent != floor(exponent))\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent);\n    \}\n  \}\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  float3 float3spow(float3 base, float exponent)\n  \{\n    return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  // \"safe\" div\n  float sdiv(float a, float b)\n  \{\n    if (b == 0.0f)\n    \{\n      return 0.0f;\n    \}\n    return a / b;\n  \}\n\n  float degree_of_adaptation(float F, float L_A)\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float  ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d   = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  // basic 3D hypotenuse function, does not deal with under/overflow\n  inline float hypot_float3(float3 xyz)\n  \{\n    return length(xyz);\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float r = R / C;\n    r       = r * r;\n    r       = sqrt(4.0f / r + 1.0f) - 1.0f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float t = 0.5f + sqrt(s * s + r * r / 4.0f);\n    t       = C / t; // t is always >= 0.5f\n\n    xyz_temp = xyz_temp * t + C;\n\n    return xyz_temp;\n  \}\n\n  float3 uncompress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float t = C / R;\n    t       = t - 0.5f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float r = 2 * sqrt(fabs(t * t - s * s)) + 1;\n    r       = sqrt(fabs(r * r - 1));\n    if (r == 0.0)\n      return xyz;\n    r = C * 2 / r;\n\n    xyz_temp = xyz_temp * r + C;\n\n    return xyz_temp;\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float hr)\n  \{\n    return -0.160 * cos(hr) + 0.132 * cos(2 * hr) - 0.405 * sin(hr) + 0.080 * sin(2 * hr) + 0.792;\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n      Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n      Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? spow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n    const float3 F_L_RGB = float3pow(F_L / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, float F_L)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV(float3 RGB)\n  \{\n    float cmax  = max(RGB.x, max(RGB.y, RGB.z));\n    float cmin  = min(RGB.x, min(RGB.y, RGB.z));\n    float delta = cmax - cmin;\n\n    float3 HSV;\n    HSV.x = delta == 0.0f ? 0.0f\n      : cmax == RGB.x     ? (fmod((RGB.y - RGB.z) / delta + 6.0f, 6.0f)) / 6.0f\n      : cmax == RGB.y     ? (((RGB.z - RGB.x) / delta + 2.0f) / 6.0f)\n                          : (((RGB.x - RGB.y) / delta + 4.0f) / 6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a          = JM.y / (focusJ * slope_gain);\n    float b          = 0.0f;\n    float c          = 0.0f;\n    float intersectJ = 0.0f;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      intersectJ = 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      intersectJ = 2.0f * c / (-b + root);\n    \}\n\n    return intersectJ;\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (viewingConditions == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (viewingConditions == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (viewingConditions == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (viewingConditions == 3)\n    \{\n      // Pull from external input\n      newSurround = userSurround;\n    \}\n    return newSurround;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear(float v)\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084(float v)\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f / 2.4f);\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f / 2.6f);\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ          = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh          = XYZ_to_JMh(XYZ, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n    // First matrix to limiting gamut for clamping\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_limit, luminanceXYZ);\n\n    if (fitWhite)\n    \{\n      // Scale to fit maximum creative white channel value\n      float3 creativeWhiteXYZ = vector_dot(RGB_to_XYZ_limit, float3(1.0f, 1.0f, 1.0f)); // TODO: these scaling parameters could be precalculated\n      float3 creativeWhiteRGB = vector_dot(XYZ_to_RGB_output, creativeWhiteXYZ);\n      luminanceRGB *= 1.0f / max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    \}\n\n    if (softclampOutput)\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    if (clampOutput)\n    \{\n      // Clamp to between zero and peak luminance\n      luminanceRGB = clamp3(luminanceRGB, 0.0f, peakLuminance);\n    \}\n\n    // Matrix to output (encoding) gamut (eventually concatenate to a single matrix)\n    luminanceRGB = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceRGB);\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3(encodingOut, luminanceRGB);\n\n    return outputRGB;\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 RGB_to_JMh(const float3 RGB, float3 refWhite, const float3x3& matrix)\n  \{\n    const float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    const float3 XYZ          = vector_dot(matrix, luminanceRGB);\n    const float3 JMh          = XYZ_to_JMh(XYZ, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the given primaries\n  float3 JMh_to_RGB(float3 JMh, float3 refWhite, const float3x3& matrix)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    float3 luminanceRGB = vector_dot(matrix, luminanceXYZ);\n    float3 RGB          = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    XYZ_w = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    if (compressMode)\n    \{\n      RGB_c = compress_bjorn(RGB_c);\n    \}\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n    if (compressMode)\n    \{\n      RGB_a = uncompress_bjorn(RGB_a);\n    \}\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    float R_a = RGB_a.x;\n    float G_a = RGB_a.y;\n    float B_a = RGB_a.z;\n    float a   = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    float b   = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    float hr = atan2(b, a);\n    float h  = wrap_to_360(degrees(hr));\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    float R_a2 = RGB_a.x;\n    float G_a2 = RGB_a.y;\n    float B_a2 = RGB_a.z;\n\n    float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w, surround.y * z);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *chroma* :math:`C`.\n    float C = 35.0f * M / A_w;\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // float s = 100.0f * sdiv(M, Q);\n  \n    if (HK_mode)\n    \{\n      // # *Helmholtz–Kohlrausch* Effect Extension.\n      J = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n      // float Q_HK = (2.0f / surround.y) * (J / 100.0f) * A_w;\n    \}\n    \n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    float J = JMh.x;\n    float M = JMh.y;\n    float h = JMh.z;\n    XYZ_w   = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n    float A_w  = ra * R_aw + G_aw + ba * B_aw;\n\n    float hr = radians(h);\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    float C = (M * 35) / A_w;\n    if (HK_mode)\n    \{\n      J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n    \}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    float P_p_1 = 43.0f * surround.z;\n    float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    float gamma = M / P_p_1;\n    float a     = gamma * cos(hr);\n    float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    if (compressMode)\n    \{\n      RGB_a = compress_bjorn(RGB_a);\n    \}\n\n    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n    if (compressMode)\n    \{\n      RGB_c = uncompress_bjorn(RGB_c);\n    \}\n\n    // # Step 6\n    float3 RGB = RGB_c / D_RGB;\n\n    // # Step 7\n    float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  int find_upper_hue_in_table(float h, float3 table\[], int table_size)\n  \{\n    int low_i  = 0;\n    int high_i = table_size - 1;\n    int i      = hue_position_in_uniform_table(h, table_size);\n\n    while (low_i + 1 < high_i)\n    \{\n      if (h > table\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float2 cuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n    if (h <= gamutCuspTable\[0].z)\n    \{\n      lo   = gamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = gamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > gamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = gamutCuspTable\[high_i - 1];\n      hi = gamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 cuspFromTableLocus(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float lo = LocusLimitMTable\[i_lo];\n    const float hi = LocusLimitMTable\[i_lo + 1];\n\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    const float cuspJ = 69;\n    const float cuspM = lerp(lo, hi, t);\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (h <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  float cReachFromTable(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = cgamutReachTable\[i_lo];\n    const float3 hi = cgamutReachTable\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y       = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float  hr     = radians(h);\n\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + hr) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float _h   = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n             + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    return JMcusp.y * e_t;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f);\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = cusp_with_eccentricity_factor(JMh.z);\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!invert)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      if (applyInGamutCompression)\n      \{\n        // Normalize M with the rendering space cusp M\n        M /= Mnorm;\n\n        // Expand the colorfulness by running the toe function in reverse.  The goal is to\n        // expand less saturated colors less and more saturated colors more.  The expansion\n        // increases saturation in the shadows and mid-tones but not in the highlights.\n        // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n        // the toe less aggressive near black to reduce the expansion of noise.\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n        // Compress the colorfulness.  The goal is to compress less saturated colors more and\n        // more saturated colors less, especially in the highlights.  This step creates the\n        // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n        // mostly affects highlights and mid-tones, and does not compress shadows.\n        M = toe(M, limit, nJ * compr, snJ, 0);\n\n        // Clamp M to the rendering space\n        if (applyReachClamp)\n          M = min(limit, M);\n\n        // Denormalize\n        M *= Mnorm;\n      \}\n    \}\n    else\n    \{\n      if (applyInGamutCompression)\n      \{\n        M /= Mnorm;\n        M = toe(M, limit, nJ * compr, snJ, 1);\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n        M *= Mnorm;\n      \}\n\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    if (AP1Clamp)\n    \{\n      luminanceRGB   = vector_dot(XYZ_to_AP1, luminanceXYZ);\n      luminanceRGB.x = max(0.0f, luminanceRGB.x);\n      luminanceRGB.y = max(0.0f, luminanceRGB.y);\n      luminanceRGB.z = max(0.0f, luminanceRGB.z);\n      luminanceXYZ   = vector_dot(AP1_to_XYZ, luminanceRGB);\n    \}\n\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n    else\n    \{\n      return JMh;\n    \}\n  \}\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB     = luminanceToEncoding3(encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\nfloat Y_to_Hellwig_J(float Y, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n    return sign(Y) * 100.0f * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, surround.y * z);\n  \}\n\n  float Hellwig_J_to_Y(float J, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float A = A_w * pow(fabs(J) / 100.0f, 1.0f / (surround.y * z));\n\n    return sign(J) * 100.0f / F_L * pow((27.13f * A) / (400.0f - A), 1.0f / 0.42f);\n  \}\n\n  float3 forwardTonescale(float3 inputJMh)\n  \{\n    float3 outputJMh;\n    float3 surround    = viewingConditionsToSurround(viewingConditions);\n    float  linear      = Hellwig_J_to_Y(inputJMh.x, surround) / referenceLuminance;\n    float  luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if (toneScaleMode == 1)\n    \{\n      luminanceTS = daniele_evo_fwd(luminanceTS) * mmScaleFactor;\n    \}\n\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, surround);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    if (applyTonecurve)\n    \{\n      outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n      outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    if (monochrome)\n    \{\n      outputJMh.y = 0.0f;\n    \}\n\n    return outputJMh;\n  \}\n\n  float3 inverseTonescale(float3 JMh)\n  \{\n    float3 tonemappedJMh = JMh;\n    float3 surround = viewingConditionsToSurround(viewingConditions);\n\n    if (!applyTonecurve && !applyChromaCompression)\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n\n    float luminance = Hellwig_J_to_Y(tonemappedJMh.x, surround);\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if (toneScaleMode == 1)\n    \{\n      linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n      linear = luminance;\n    \}\n\n    linear = linear * referenceLuminance;\n\n    if (applyTonecurve)\n    \{\n      float untonemappedJ = Y_to_Hellwig_J(linear, surround);\n      untonemappedColourJMh = float3(untonemappedJ, tonemappedJMh.y, tonemappedJMh.z);\n    \}\n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return untonemappedColourJMh;\n  \}\n\n  float2 hueDependantHullGammas(float h)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(h, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    return lerp(gamutGammas\[i_lo], gamutGammas\[i_lo + 1], t);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float gamma_top, float gamma_bottom)\n  \{\n    float2 JM_source = float2(JMh_s.x, JMh_s.y);\n\n    float slope = 0.0f;\n\n    float s = max(0.000001f, smoothness);\n    JM_cusp.x *= 1.0f + smoothJ * s; // J\n    JM_cusp.y *= 1.0f + smoothM * s; // M\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, 1 / gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp)\n      * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), 1.0f / gamma_top) / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, s);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'.\n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.05f, cusp.x / limitJmax), 0.0001f);\n    cusp.y *= 1.0f + 0.18f * s;\n    cusp.x *= 1.0f + 0.07f * s;\n\n    // Line below the cusp is curved with model_gamma\n    float toJ_gamma   = cusp.x * spow(to.x / cusp.x, model_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, model_gamma);\n    t0                = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float2 findCurveIntersection(float c, float2 cusp, float m, float h)\n  \{\n    // based on this desmos plot https://www.desmos.com/calculator/pcsovzirqa\n    float xc = cusp.y;\n    float yc = cusp.x;\n    float f  = 1.0;\n    float mf = m * f;\n    float xi = 1.0f;\n    float g1 = 1.0f / model_gamma;\n    float g2 = hueDependantHullGammas(h).y;\n\n    if (m * xc + c < yc)\n    \{\n      // below cusp\n      xi = spow((1 - mf), (g1 - 1)) * ((yc * spow((c / yc), (1.0 / g1))) / (yc / xc - m));\n    \}\n    else\n    \{\n      // above cusp\n      xi =\n        spow((1 + mf), ((g2 - 1))) * (xc * (limitJmax - yc) * spow(((limitJmax - c) / (limitJmax - yc)), (1 / g2)) / (m * xc + limitJmax - yc));\n    \}\n    float yi = (m * xi) + c;\n    if (yi > limitJmax)\n    \{\n      yi = limitJmax;\n      xi = 0.0f;\n    \}\n    return float2(yi, xi);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus     = cuspFromTableLocus(h);\n    float  cuspTarget100 = cuspLocus.y;\n    float  cuspTarget    = cuspTarget100 * pow((Jmh.x / 100.0f), model_gamma);\n    float  difference    = cuspLocus.y / cuspTarget;\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float3 getReachBoundry(float3 Jmh)\n  \{\n    const float h = Jmh.z;\n\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = gamutCuspTableReach\[i_lo];\n    const float3 hi = gamutCuspTableReach\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n\n    const float reachMaxM = lerp(lo.y, hi.y, t);\n    if (reachNick)\n    \{\n      float2 JMcusp     = cuspFromTable(Jmh.z);\n      float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain = limitJmax * focusDist * getFocusGain(Jmh.x, JMcusp.x);\n      float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n      float  slope;\n      if (intersectJ < focusJ)\n      \{\n        slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      else\n      \{\n        slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      float boundaryNick = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n      return float3(Jmh.x, boundaryNick, Jmh.z);\n    \}\n    float cuspTarget = reachMaxM * pow((Jmh.x / limitJmax), model_gamma);\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n\n    if (Reachcompressmode)\n    \{\n      if (primariesReach != 6) // All of the primary based reach values\n      \{\n        // use primary based reach\n        float locusMax   = getReachBoundry(Jmh).y;\n        float difference = max(1.0001f, locusMax / Jmh.y);\n        float threshold  = max(compressionFuncParams.x, 1.0f / difference);\n        return float4(threshold, difference, difference, compressionFuncParams.w);\n      \}\n      else\n      \{\n        // use locus based reach\n        float locusMax   = getLocusBoundry(Jmh).y;\n        float difference = locusMax / Jmh.y;\n        return float4(compressionFuncParams.x, difference, difference, compressionFuncParams.w);\n      \}\n    \}\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h >= angleR && h < angleY)\n      \{\n        lerpVal = (h - angleR) / (angleY - angleR);\n        return lerp(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h >= angleY && h < angleG)\n      \{\n        lerpVal = (h - angleY) / (angleG - angleY);\n        return lerp(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h >= angleG && h < angleC)\n      \{\n        lerpVal = (h - angleG) / (angleC - angleG);\n        return lerp(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h >= angleC && h < angleB)\n      \{\n        lerpVal = (h - angleC) / (angleB - angleC);\n        return lerp(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h >= angleB && h < angleM)\n      \{\n        lerpVal = (h - angleB) / (angleM - angleB);\n        return lerp(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h >= angleM && h < angleR + 360.0f)\n      \{\n        lerpVal = (h - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h < angleR)\n      \{\n        lerpVal = (h + 360.0f - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  float getFocusGain(float J, float cuspJ)\n  \{\n    if (disableFocusGain)\n      return 1.0f;\n\n    float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J > thr)\n    \{\n      // Approximate inverse required above threshold\n      float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n      return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n    \}\n    else\n    \{\n      // Analytic inverse possible below cusp\n      return 1.0f;\n    \}\n  \}\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    if (disableFocusGain)\n      return compressGamut2(JMh, invert, JMh.x);\n\n    if (!invert)\n    \{\n      return compressGamut2(JMh, 0, JMh.x);\n    \}\n    else\n    \{\n      float2 JMcusp = cuspFromTable(JMh.z);\n      float  Jx     = JMh.x;\n\n      // Analytic inverse below threshold\n      if (Jx <= lerp(JMcusp.x, limitJmax, focusGainBlend))\n        return compressGamut2(JMh, 1, Jx);\n\n      // Approximation above\n      Jx = compressGamut2(JMh, 1, Jx).x;\n      return compressGamut2(JMh, 1, Jx);\n    \}\n  \}\n\n  float3 compressGamut2(float3 JMh, int invert, float Jx)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp       = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDist * JMcusp.y);\n    float a      = max(0.001f, Mratio / focusJ);\n    float b0     = 1.0f - Mratio;\n    float b1     = -(1.0f + Mratio + (a * limitJmax));\n    float b      = project_from.x < focusJ ? b0 : b1;\n    float c0     = -project_from.x;\n    float c1     = project_from.x + limitJmax * Mratio;\n    float c      = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0       = sqrt(b * b - 4 * a * c);\n    float J1       = (-b - J0) / (2 * a);\n    J0             = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    float slope_gain = limitJmax * focusDist * getFocusGain(Jx, JMcusp.x);\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = float2(1.0f, 1.0f);\n    if (boundryIntersectionMethod == 0)\n    \{\n      // Original method implemented by Pekka\n      JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    \}\n    else if (boundryIntersectionMethod == 1)\n    \{\n      // Alternate method shown in Oct 19 meeting\n      float m    = (JMh.x - projectJ) / JMh.y;\n      JMboundary = findCurveIntersection(JMh.x, JMcusp, 0.0f, JMh.z);\n    \}\n    else if (boundryIntersectionMethod == 2)\n    \{\n      const float2 gammas      = hueDependantHullGammas(JMh.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      JMboundary               = float2(nickBoundryReturn.x, nickBoundryReturn.y);\n      project_to               = float2(nickBoundryReturn.z, 0.0f);\n      projectJ                 = nickBoundryReturn.z;\n    \}\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams;\n    if (reachNick)\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMboundary.x, JMboundary.y, JMh.z));\n    \}\n    else\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x, JMboundary.y, JMh.z));\n    \}\n\n    if (!Reachcompressmode)\n      interpolatedCompressionFuncParams.x =\n        1.0f / lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n\n    float lowerMlimit = 0.0001f; // Testing a small value here\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)  // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                                    lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                                    interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 20)\n    \{\n      // return focus point\n      return float3(project_to.x, project_to.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n                            ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit  = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0    = daniele_n / daniele_n_r;\n    daniele_m_1    = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u      = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m      = daniele_m_1 / daniele_u;\n    daniele_w_i    = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t    = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip   = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2    = daniele_c / daniele_g_ipp2;\n    daniele_s_2    = daniele_w_2 * daniele_m_1;\n    daniele_u_2    = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2    = daniele_m_1 / daniele_u_2;\n\n    // 1.0f / (c * z)\n    model_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n\n    // Chroma compression scaling for HDR/SDR appearance match\n    float log_peak = log10(daniele_n / daniele_n_r);\n    compr          = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    sat            = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak);\n    sat_thr        = chroma_expand_thr / daniele_n;\n\n    // Gamut mapper focus distance scaling with peak luminance for\n    // HDR/SDR appearance match.  The projection gets slightly less\n    // steep with higher peak luminance.\n    // https://www.desmos.com/calculator/bnfhjcq5vf\n    if (!disableFocusDistScaling)\n      focusDist = focusDistance + focusDistance * focusDistScaling * log_peak;\n    else\n      focusDist = focusDistance;\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    float CAT_CAT16_data\[] = \{\n      0.401288, 0.650173, -0.051461, -0.250268, 1.204414, 0.045854, -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[] = \{\n      0.656619, 0.342071, 0.00131062, -0.222571, 1.10658, 0.115987, -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[] = \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374,\n      238.0180511, 235.4039917, 233.010849,  230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215,\n      190.9799347, 184.005127,  177.7472992, 172.2332611, 166.6447754, 161.64534,   156.9872284, 152.6203003, 148.3236084, 144.2987976,\n      140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861,\n      114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853,  105.188797,  103.6860809, 102.2319641, 100.8348923, 99.51873779,\n      98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951,  92.03639984, 91.15013885, 90.27630615, 89.43255615,\n      88.63536072, 87.8986969,  87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547,\n      83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156,\n      80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702,\n      80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481,  81.901474,   82.20778656, 82.67211151,\n      83.1408844,  83.62628174, 84.0898056,  84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481,\n      88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783,  94.64561462, 95.68405914, 96.84765625,\n      97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031,\n      113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034,\n      137.8343048, 140.7224121, 143.7820892, 147.23909,   150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272,\n      171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255,\n      199.4234161, 201.3786011, 203.1474609, 205.016037,  206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686,\n      215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463,\n      213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355,\n      195.217453,  193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165,\n      174.445282,  172.4908905, 170.5744934, 168.5490723, 166.459259,  164.4333649, 162.5092621, 160.4579468, 158.491806,  156.6880035,\n      155.0045624, 153.295166,  151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602,\n      139.225174,  137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328,   128.7269897,\n      127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358,  120.9004822,\n      120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039,\n      116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118,\n      114.8510284, 114.8482819, 114.848465,  114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528,  115.7195816,\n      115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586,\n      119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077,  124.071022,  124.9082108, 125.74823,   126.6865311,\n      127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252,  130.1131287, 130.5647278,\n      130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609,  136.6136017, 137.5203552,\n      138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586,\n      150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551,\n      168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373,\n      192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452,  206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306,\n      220.6668701, 223.364151,  226.2115479, 228.9524536, 231.5583954, 234.405304,  237.0275879, 239.5091705, 242.0047455, 242.0177155,\n      244.8230133\};\n\n    // populate the input primaries matrix\n    RGB_to_XYZ_input = generate_RGB_to_XYZ_matrix(primariesIn);\n    XYZ_to_RGB_input = RGB_to_XYZ_input.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(1); // AP1 == 1\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix;\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n    if (whiteLimit == 0)\n    \{\n      limitWhiteForMatrix = float2(0.32168f, 0.33767f);\n    \}\n    else if (whiteLimit == 1)\n    \{\n      limitWhiteForMatrix = float2(0.3127f, 0.3290f);\n    \}\n    else\n    \{\n      limitWhiteForMatrix = float2(0.333333f, 0.333333f);\n    \}\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001, -0.077);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, 0);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    RGB_to_XYZ_reach = generate_RGB_to_XYZ_matrix(primariesReach);\n    XYZ_to_RGB_reach = RGB_to_XYZ_reach.invert();\n\n    RGB_to_XYZ_output = generate_RGB_to_XYZ_matrix(primariesOut);\n    XYZ_to_RGB_output = RGB_to_XYZ_output.invert();\n\n    float3 white(1.0f, 1.0f, 1.0f);\n    inWhite    = vector_dot(RGB_to_XYZ_input, white);\n    outWhite   = vector_dot(RGB_to_XYZ_output, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = peakLuminance / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n      CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n      CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n      CAT_CAT16 = RGBPrimsToXYZMatrix(rxy, gxy, bxy, wxy, 1.0f, 1);\n    \}\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    generate_panlrcm();\n\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    limitJmax = RGB_to_JMh(float3(1.0f), limitWhite, RGB_to_XYZ_limit).x;\n\n    // Cusp table for chroma compression gamut\n    float3x3 RGB_to_XYZ_cgReach;\n    if (ccReach == 0) // Chroma Compression Space (primaries defined in kernel params)\n    \{\n      RGB_to_XYZ_cgReach = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 0);\n\n    \}\n    else if (ccReach == 1)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(0);\n    \}\n    else if (ccReach == 2)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(1);\n    \}\n    else\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(3);\n    \}\n    const float3x3 XYZ_to_RGB_cgReach = RGB_to_XYZ_cgReach.invert();\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, inWhite, RGB_to_XYZ_cgReach);\n    initialise_reach_cusp_table(cgamutReachTable, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_cgReach);\n\n    // With gamut mapper reach mode 7, use the chroma compression reach space with the\n    // gamut mapper.\n    if (primariesReach == 7)\n      XYZ_to_RGB_reach = XYZ_to_RGB_cgReach;\n\n    // Cusp table for limiting gamut\n    initialise_cusp_table(gamutCuspTable, gamutCuspTableSize, limitWhite, RGB_to_XYZ_limit);\n    initialise_reach_cusp_table(gamutCuspTableReach, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_reach);\n\n    midJ = XYZ_to_JMh(inWhite * daniele_c_t * mmScaleFactor, inWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid,\n                      HK_mode_mid)\n             .x;\n\n    initialise_upper_hull_gamma();\n    initialise_lower_hull_gamma();\n  \}\n\n  void initialise_cusp_table(float3 output_table\[], const int table_size, float3 refWhite, const float3x3& matrix)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      tempTableUnsorted\[i] = RGB_to_JMh(RGB, refWhite, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 tableUnsorted\[], const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 output_table\[], const int table_size, const float limitJ, float3 refWhite, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_RGB(float3(limitJ, high, hue), refWhite, matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_RGB(float3(limitJ, sampleM, hue), refWhite, matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, min(1.0, cuspMidBlend - (JMcusp.x / limitJmax)));\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, topGamma, lowerHullGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma()\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        gamutGammas\[i].x =  upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      gamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].x = gamutGammas\[0].x;\n   \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float slope_gain = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n\n      const float3 approxLimit     = findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax,\n                                                                   slope_gain, smoothCusps, upperHullGamma, bottomGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma()\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        gamutGammas\[i].y = lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      gamutGammas\[i].y = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].y = gamutGammas\[0].y;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n    float3 diagnostic;\n\n    if (invert)\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh           = inverseTonescale(tonemappedJMh);\n      diagnostic    = JMh_to_input_RGB(JMh);\n    \}\n    else\n    \{\n      JMh           = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n      diagnostic    = JMh_to_output_RGB(compressedJMh);\n    \}\n\n    if (diagnosticMode == 1 || diagnosticMode == 6)\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if (invert)\n      \{\n        diagnostic = JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic = JMh;\n      \}\n    \}\n    else if (diagnosticMode == 2 || diagnosticMode == 99)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if (diagnosticMode == 3 || diagnosticMode == 5)\n    \{\n      diagnostic = compressedJMh;\n    \}\n    else if (diagnosticMode == 4 || diagnosticMode == 7)\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB     = JMh_to_output_RGB(srcRGB);\n      diagnostic = dstRGB;\n    \}\n    else if (diagnosticMode == 8)\n    \{\n      diagnostic = inWhite;\n    \}\n    else if (diagnosticMode == 9)\n    \{\n      diagnostic = outWhite;\n    \}\n    else if (diagnosticMode == 10)\n    \{\n      diagnostic = limitWhite;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      const float2 JMcusp = cuspFromTable(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      const float2 JMcusp = cuspFromTableLocus(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundary\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundary\n      diagnostic = getReachBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 20)\n    \{\n      // output JMFocus\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 21)\n    \{\n      // output JMFocus\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).y, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 22)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float slope_gain = limitJmax * focusDist;\n      diagnostic       = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 23)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic         = float3(approxLimit.x, approxLimit.y, srcRGB.z);\n    \}\n\n    else if (diagnosticMode == 24)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      float3 newLimitRGB = JMh_to_RGB(float3(approxLimit.x, approxLimit.y, srcRGB.z), limitWhite, XYZ_to_RGB_limit);\n      diagnostic         = newLimitRGB;\n    \}\n\n    else if (diagnosticMode == 25)\n    \{\n      float2 JMcusp            = cuspFromTable(srcRGB.z);\n      float  focusJ            = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain        = limitJmax * focusDist * getFocusGain(JMh.x, JMcusp.x);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(srcRGB, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic               = float3(srcRGB.x, nickBoundryReturn.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 26)\n    \{\n      // XYZ back to luminance RGB\n      float3 JMh = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n      diagnostic = vector_dot(XYZ_to_RGB_limit, JMh);\n    \}\n    else if (diagnosticMode == 27)\n    \{\n      // output\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).x, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 28)\n    \{\n      // output\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      diagnostic    = findGamutBoundaryIntersection(srcRGB, JMcusp, lerp(JMcusp.x, midJ, cuspMidBlend), limitJmax, 10000.0f, 0.0f,\n                                                    gammas.x, gammas.y);\n    \}\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    ////// FORWARD PATHWAY\n\n    else if (diagnosticMode == 100)\n    \{\n      // display encoding to display linear\n      diagnostic      = encodingToLuminance3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 101)\n    \{\n      // convert to linear XYZ luminance values\n      diagnostic = vector_dot(RGB_to_XYZ_input, srcRGB);\n    \}\n    else if (diagnosticMode == 102)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 105)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 106)\n    \{\n      // display luminance XYZ to display linear RGB\n      diagnostic = vector_dot(XYZ_to_RGB_output, srcRGB);\n    \}\n    else if (diagnosticMode == 107)\n    \{\n      // display linear RGB to display encoded RGB\n      diagnostic = luminanceToEncoding3(encodingOut, srcRGB);\n    \}\n\n    ////// INVERSE PATHWAY\n\n    else if (diagnosticMode == 200)\n    \{\n      // output display encoded RGB to display linear RGB\n      diagnostic = encodingToLuminance3(encodingOut, srcRGB);\n    \}\n    else if (diagnosticMode == 201)\n    \{\n      // output display linear RGB to output display linear XYZ\n      diagnostic = vector_dot(RGB_to_XYZ_output, srcRGB);\n    \}\n    else if (diagnosticMode == 202)\n    \{\n      // output XYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 203)\n    \{\n      // uncompress gamut\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 204)\n    \{\n      // inverse tonescale in JMh\n      diagnostic = inverseTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 205)\n    \{\n      // inverted JMh back to XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 206)\n    \{\n      // XYZ back to luminance RGB\n      diagnostic = vector_dot(XYZ_to_RGB_input, srcRGB);\n    \}\n    else if (diagnosticMode == 207)\n    \{\n      // luminance RGB to input encoding RGB\n      diagnostic = luminanceToEncoding3(encodingIn, srcRGB);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_AP1Clamp {{parent.ap1_clamp}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_peakLuminance {{parent.peak_luminance}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_applyInGamutExpansion {{parent.applyInGamutExpansion}}
  DRT_CAM_Kernel_applyInGamutCompression {{parent.applyInGamutCompression}}
  DRT_CAM_Kernel_applyReachClamp {{parent.applyReachClamp}}
  DRT_CAM_Kernel_monochrome {{parent.monochrome}}
  DRT_CAM_Kernel_chroma_compress {{parent.compress}}
  "DRT_CAM_Kernel_Chroma Compress Factor" {{parent.chroma_compress_fact}}
  DRT_CAM_Kernel_chroma_expand {{parent.chroma_expand}}
  "DRT_CAM_Kernel_Chroma Expansion Factor" {{parent.chroma_expand_fact}}
  DRT_CAM_Kernel_chroma_expand_thr {{parent.chroma_expand_thr}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_ccReach {{parent.ccReachPrimaries}}
  DRT_CAM_Kernel_crxy {0.7347 0.2653}
  DRT_CAM_Kernel_cgxy {0.12 0.88}
  DRT_CAM_Kernel_cbxy {0.08 -0.04}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_whiteLimit {{parent.white_limit}}
  DRT_CAM_Kernel_primariesReach {{parent.primaries_reach}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_focusAdjustGain {{parent.focusgain}}
  DRT_CAM_Kernel_focusGainBlend {{parent.focus_gain_blend}}
  DRT_CAM_Kernel_focusDistScaling {{parent.focusdistscaling}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r x272 -1.75} {parent.compression_params.g} {parent.compression_params.b} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR x272 0.21} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Reachcompressmode {{parent.reachCompressMode}}
  DRT_CAM_Kernel_reachNick true
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_boundryIntersectionMethod {{boundryIntersectionMethod}}
  DRT_CAM_Kernel_disableLowerHullGamma true
  DRT_CAM_Kernel_lowerHullGamma {{lowerHullGamma}}
  DRT_CAM_Kernel_upperHullGamma {{parent.upperHullGamma}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  "DRT_CAM_Kernel_Smoothing factor cusp J" {{parent.smoothJ}}
  "DRT_CAM_Kernel_Smoothing factor cust M" {{parent.smoothM}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_fitWhite {{parent.fit_white}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.peak_luminance}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.8336 0.1735}
  DRT_CAM_Kernel_gxy {2.3854 -1.4659}
  DRT_CAM_Kernel_bxy {0.087 -0.125}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Reformat {
 type scale
 scale 7
 filter impulse
 name Reformat4
 label "scale up 7x"
 xpos 320
 ypos 660
}
Dot {
 name Dot9
 xpos 354
 ypos 692
}
set Nb131aa00 [stack 0]
Expression {
 expr0 isnan(r)?0:r
 expr1 isnan(g)?0:g
 expr2 isnan(b)?0:b
 name killNan2
 xpos 366
 ypos 709
}
Clamp {
 minimum -65535
 maximum 65535
 name Clamp4
 xpos 366
 ypos 733
}
Colorspace {
 illuminant_in ACES
 primary_in ACES
 colorspace_out CIE-XYZ
 name Colorspace6
 label "XYZ to AP0"
 xpos 366
 ypos 769
 disable true
}
ColorMatrix {
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 invert true
 name ColorMatrix3
 label "APS4 to XYZ"
 xpos 366
 ypos 801
 disable true
}
Expression {
 temp_name0 cut_lin
 temp_expr0 0.0078125
 temp_name1 cut_log
 temp_expr1 0.155251141552511
 temp_name2 A
 temp_expr2 10.5402377416545
 temp_name3 B
 temp_expr3 0.0729055341958355
 expr0 r<=cut_lin?A*r+B:(log(r)/log(2)+9.72)/17.52
 expr1 g<=cut_lin?A*g+B:(log(g)/log(2)+9.72)/17.52
 expr2 b<=cut_lin?A*b+B:(log(b)/log(2)+9.72)/17.52
 channel3 none
 name lin2log2
 label ACEScct
 xpos 366
 ypos 833
}
push $Nb131aa00
Switch {
 inputs 2
 which {{master.inverseMode}}
 name Switch5
 xpos 320
 ypos 884
}
Group {
 name Write_ResolveACES_ODT_LUT7
 label "\[python nuke.thisNode().knob('cubePath').evaluate().split('/').pop(-1)]"
 xpos 320
 ypos 998
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate CAMDRT
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target "P3D65 (Rec709 sim)"
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate_\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template_AP0.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template_AP0.fltransform
 addUserKnob {1 dctlColorspaceBufferTag}
 dctlColorspaceBufferTag P3D65_48nits
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev060/ACES2 Candidate CAMDRT rev060 P3D65 (Rec709 sim)_inverse.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $Nb2fce800
Group {
 name DRT_CAMv7
 label "Input: \[value encoding_in]  / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value white_limit] / \[value peak_luminance]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 935
 ypos 550
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {6 ap1_clamp l "AP1 clamp" t "Clamp input chromaticities to AP1 rendering space" +STARTLINE}
 ap1_clamp true
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {7 peak_luminance l "Peak Luminance" t "Target peak luminance in cd/m^2" R 0 1000}
 peak_luminance 4000
 addUserKnob {6 monochrome t "Output monochrome image" +STARTLINE}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 applyInGamutExpansion l "apply in gamut expansion" t "Expands colorfulness to increase saturation" +STARTLINE}
 applyInGamutExpansion true
 addUserKnob {6 applyInGamutCompression l "apply in gamut compression" +STARTLINE}
 applyInGamutCompression true
 addUserKnob {6 applyReachClamp l "apply reach mode clamp" t "Clamp the chroma compressed result to the rendering space" +STARTLINE}
 addUserKnob {7 compress l "chroma compression" t "Chroma compression amount" R 2 10}
 compress 2.4
 addUserKnob {7 chroma_compress_fact l HDR t "Chroma compression scaling factor for SDR/HDR appearance match.  Smaller values will compress less as peak luminance goes highger, higher values compress more.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 2 6}
 chroma_compress_fact 3.3
 addUserKnob {7 chroma_expand l "chroma expansion" t "Chroma expansion to increase saturation in shadows and mid-tones" R 1 4}
 chroma_expand 1.3
 addUserKnob {7 chroma_expand_fact l HDR t "Chroma expansion scaling factor for SDR/HDR appearance match.  Smaller values will have more saturation as peak luminance goes highger, higher values will have less saturation.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 0.5 0.9}
 chroma_expand_fact 0.69
 addUserKnob {7 chroma_expand_thr l "chroma expansion threshold" t "Threshold for starting chroma expansion, meant to avoid expanding noise floor" R 0.5 1}
 chroma_expand_thr 0.5
 addUserKnob {4 ccReachPrimaries l "reach primaries" t "Primaries that define how far chroma compression and expansion reaches." M {"Chroma Compression Space" AP0-ACES AP1-ACES Rec.2020-D65 ""}}
 ccReachPrimaries AP1-ACES
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" "" "" ""}}
 et None
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 primaries_limit P3
 addUserKnob {4 white_limit l "white point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." -STARTLINE M {"ACES White" D65 "" "" ""}}
 white_limit D65
 addUserKnob {4 primaries_reach l "reach primaries" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "Spectral Locus" "Chroma Compression Space"}}
 primaries_reach AP1-ACES
 addUserKnob {6 reachCompressMode l "Reach Compression Mode" -STARTLINE}
 reachCompressMode true
 addUserKnob {4 boundryIntersectionMethod M {"Original Pekka" "Oct 19" "New From Nick" ""}}
 boundryIntersectionMethod "New From Nick"
 addUserKnob {41 DRT_CAM_Kernel_reachNick l "Use Nick method for reach" -STARTLINE T BlinkScript1.DRT_CAM_Kernel_reachNick}
 addUserKnob {41 DRT_CAM_Kernel_disableUpperHullGamma l disableUpperHullGamma T BlinkScript1.DRT_CAM_Kernel_disableUpperHullGamma}
 addUserKnob {7 upperHullGamma -STARTLINE R 0 2}
 upperHullGamma 1
 addUserKnob {41 DRT_CAM_Kernel_disableLowerHullGamma l disableLowerHullGamma T BlinkScript1.DRT_CAM_Kernel_disableLowerHullGamma}
 addUserKnob {7 lowerHullGamma -STARTLINE R 0 2}
 lowerHullGamma 1.14
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue and mid J.  higher cusps will closer to the cusp lightness, lower cusps will be closer to midJ" R 0.6 2}
 cusp_mid_blend 1.3
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic." R 1.1 2}
 focus_distance 1.35
 addUserKnob {7 focusdistscaling l HDR t "Focus distance scaling factor as peak luminance gets higher for SDR/HDR appearance match.  The projection gets less steep with higher projection\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 1 2}
 focusdistscaling 1.75
 addUserKnob {41 DRT_CAM_Kernel_disableFocusGain l disableFocusGain T BlinkScript1.DRT_CAM_Kernel_disableFocusGain}
 addUserKnob {7 focus_gain_blend l "focus gain blend" t "Blend between cusp J and limitJmax to determine the point where the focus gain is applied.\n\n0 = cuspJ\n1 = limitJmax"}
 focus_gain_blend 0.3
 addUserKnob {7 focusgain l "focus gain" -STARTLINE}
 focusgain 0.55
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.1 1.3 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.12
 addUserKnob {7 smoothJ l "smooth J" t "Smoothing scaling factor for cusp J" R 0 0.1}
 addUserKnob {7 smoothM l "smooth M" t "Smoothing scaling factor for cusp M" -STARTLINE R 0 0.25}
 smoothM 0.27
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out ST2084
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out Rec.2020-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 fit_white l "fit white" t "Scale the output so the maximum RGB channel for the creative white becomes 100%. Prevents clipping when the creative and encoding whites do not match." +STARTLINE}
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" -STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 invert {{master.inverseMode}}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {26 "" l " "}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v060.blink
  recompileCount 4092
  ProgramGroup 1
  KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 925e58f9470501a7d899ac9a2a52d4f33d9c5f59bd24740acef8f1ed9e380ede 2 \"src\" Read Point \"dst\" Write Point 97 \"encodingIn\" Int 1 AAAAAA== \"AP1Clamp\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"peakLuminance\" Float 1 AAAAAA== \"applyChromaCompression\" Bool 1 AA== \"applyInGamutExpansion\" Bool 1 AA== \"applyInGamutCompression\" Bool 1 AA== \"applyReachClamp\" Bool 1 AA== \"monochrome\" Bool 1 AA== \"chroma_compress\" Float 1 AAAAAA== \"Chroma Compress Factor\" Float 1 AACgQA== \"chroma_expand\" Float 1 AAAAAA== \"Chroma Expansion Factor\" Float 1 FK5HPw== \"chroma_expand_thr\" Float 1 AAAAAA== \"cc_et\" Int 1 AAAAAA== \"ccReach\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"primariesLimit\" Int 1 AAAAAA== \"whiteLimit\" Int 1 AAAAAA== \"primariesReach\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"focusAdjustGain\" Float 1 AAAAAA== \"focusGainBlend\" Float 1 AAAAAA== \"disableFocusGain\" Bool 1 AA== \"disableFocusDistScaling\" Bool 1 AA== \"focusDistScaling\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Reachcompressmode\" Bool 1 AA== \"reachNick\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"boundryIntersectionMethod\" Int 1 AAAAAA== \"disableUpperHullGamma\" Bool 1 AA== \"disableLowerHullGamma\" Bool 1 AA== \"lowerHullGamma\" Float 1 AAAAAA== \"upperHullGamma\" Float 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"Smoothing factor cusp J\" Float 1 rkdhPQ== \"Smoothing factor cust M\" Float 1 WmQ7Pg== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"fitWhite\" Bool 1 AA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 97 \"encodingIn\" 1 1 Default \"AP1Clamp\" 1 1 Default \"primariesIn\" 1 1 Default \"toneScaleMode\" 1 1 Default \"discountIlluminant_in\" 1 1 Default \"discountIlluminant_mid\" 1 1 Default \"discountIlluminant_out\" 1 1 Default \"HK_mode_in\" 1 1 Default \"HK_mode_mid\" 1 1 Default \"HK_mode_out\" 1 1 Default \"compressMode\" 1 1 Default \"referenceLuminance\" 1 1 Default \"viewingConditions\" 1 1 Default \"outputViewingConditions\" 1 1 Default \"applyTonecurve\" 1 1 Default \"peakLuminance\" 1 1 Default \"applyChromaCompression\" 1 1 Default \"applyInGamutExpansion\" 1 1 Default \"applyInGamutCompression\" 1 1 Default \"applyReachClamp\" 1 1 Default \"monochrome\" 1 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"cc_et\" 1 1 Default \"ccReach\" 1 1 Default \"crxy\" 2 1 Default \"cgxy\" 2 1 Default \"cbxy\" 2 1 Default \"cwxy\" 2 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"primariesReach\" 1 1 Default \"applyGamutCompression\" 1 1 Default \"cuspMidBlend\" 1 1 Default \"focusDistance\" 1 1 Default \"focusAdjustGain\" 1 1 Default \"focusGainBlend\" 1 1 Default \"disableFocusGain\" 1 1 Default \"disableFocusDistScaling\" 1 1 Default \"focusDistScaling\" 1 1 Default \"compressionFuncParams\" 4 1 Default \"sixAxisCompressionMode\" 1 1 Default \"compressionFuncParamsR\" 4 1 Default \"compressionFuncParamsY\" 4 1 Default \"compressionFuncParamsG\" 4 1 Default \"compressionFuncParamsC\" 4 1 Default \"compressionFuncParamsB\" 4 1 Default \"compressionFuncParamsM\" 4 1 Default \"Reachcompressmode\" 1 1 Default \"reachNick\" 1 1 Default \"Locuscompressmode\" 1 1 Default \"boundryIntersectionMethod\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"smoothCusps\" 1 1 Default \"smoothJ\" 1 1 Default \"smoothM\" 1 1 Default \"encodingOut\" 1 1 Default \"primariesOut\" 1 1 Default \"fitWhite\" 1 1 Default \"clampOutput\" 1 1 Default \"softclampOutput\" 1 1 Default \"clamp_thr\" 1 1 Default \"clamp_dist\" 1 1 Default \"invert\" 1 1 Default \"diagnosticMode\" 1 1 Default \"mmScaleFactor\" 1 1 Default \"daniele_n\" 1 1 Default \"daniele_n_r\" 1 1 Default \"daniele_g\" 1 1 Default \"daniele_c\" 1 1 Default \"daniele_c_d\" 1 1 Default \"daniele_w_g\" 1 1 Default \"daniele_t_1\" 1 1 Default \"daniele_r_hit_min\" 1 1 Default \"daniele_r_hit_max\" 1 1 Default \"catDataSelection\" 1 1 Default \"rxy\" 2 1 Default \"gxy\" 2 1 Default \"bxy\" 2 1 Default \"wxy\" 2 1 Default \"ra\" 1 1 Default \"ba\" 1 1 Default \"XYZ_w\" 3 1 Default \"XYZ_w_scaler\" 1 1 Default \"L_A\" 1 1 Default \"Y_b\" 1 1 Default \"L_B\" 3 1 Default \"userSurround\" 3 1 Default \"discount_illuminant\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default 52 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"compr\" Float 1 1 AAAAAA== \"sat\" Float 1 1 AAAAAA== \"sat_thr\" Float 1 1 AAAAAA== \"focusDist\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"model_gamma\" Float 1 1 AAAAAA== \"gamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutCuspTableReach\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutReachTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"LocusLimitMTable\" Float 1 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingIn;\n\n  // AP1 clamp\n  bool AP1Clamp;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesIn;\n\n  // Tonescale mode\n  // 0: Linear\n  // 1: Daniele Evo Curve\n  int toneScaleMode;\n\n  // Disable Degree of Adaptation\n  // This is only effective if the limit primaries have a non-D65 white point\n  // since the input conversion is assumed to be fully adapted\n  // and the output conversion does not apply a CAT\n  bool discountIlluminant_in;\n  bool discountIlluminant_mid;\n  bool discountIlluminant_out;\n\n  // Toggles for Hellwig 2022 specific params\n  bool HK_mode_in;\n  bool HK_mode_mid;\n  bool HK_mode_out;\n  int  compressMode;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int viewingConditions;\n  int outputViewingConditions;\n\n  // Toggle Tone Mapping\n  bool applyTonecurve;\n\n  // Target Peak Luminance\n  float peakLuminance;\n\n  // Toggle chroma compression\n  bool applyChromaCompression;\n  bool applyInGamutExpansion;\n  bool applyInGamutCompression;\n  bool applyReachClamp;\n  bool monochrome;\n\n  // Chroma compression params\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n  int   cc_et;\n  int   ccReach;\n  // xy coordinates for chroma compression gamut\n  float2 crxy;\n  float2 cgxy;\n  float2 cbxy;\n  float2 cwxy;\n\n  //\n  // Gamut Mapping Parameters\n  //\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Primaries of the Gamut reached by the gamut compressor\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: Spectral Locus\n  // 7: Chroma Compression Space\n  int primariesReach;\n\n  // Toggle Gamut Compression\n  bool applyGamutCompression;\n\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n  #define gamutCuspTableSize 360*1\n\n  // Blend Between Compressing towards\n  // Target Gamut Cusp Luminance (0.0)\n  // and Mid Luminance (1.0)\n  float cuspMidBlend;\n\n  // Focus distance of the compression focal point from the achromatic axis\n  float focusDistance;\n  float focusAdjustGain;\n  float focusGainBlend;\n  bool  disableFocusGain;\n  bool  disableFocusDistScaling;\n  float focusDistScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 compressionFuncParams;\n  bool   sixAxisCompressionMode;\n  float4 compressionFuncParamsR;\n  float4 compressionFuncParamsY;\n  float4 compressionFuncParamsG;\n  float4 compressionFuncParamsC;\n  float4 compressionFuncParamsB;\n  float4 compressionFuncParamsM;\n  bool   Reachcompressmode;\n  bool   reachNick;\n  bool   Locuscompressmode;\n\n  int   boundryIntersectionMethod;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n  float lowerHullGamma;\n  float upperHullGamma;\n\n  // How much the edges of the target RGB cube are smoothed when finding the gamut boundary\n  // in order to reduce visible contours at the gamut cusps\n  float smoothCusps;\n  float smoothJ; // Scaling factor for cusp J\n  float smoothM; // Scaling factor for cusp M\n\n  //\n  // Output Parameters\n  //\n\n  // Encoding of the Output Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingOut;\n\n  // Primaries of the Output Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesOut;\n\n  // Clamp output values to 0.0 - 1.0\n  bool  fitWhite;\n  bool  clampOutput;\n  bool  softclampOutput;\n  float clamp_thr;\n  float clamp_dist;\n\n  //\n  // Extra Parameters\n  //\n\n  // Toggle Inverse Transform\n  bool invert;\n  // Diagnostic path modes\n  int diagnosticMode;\n\n  // DanieleEvoCurve (ACES2 candidate) parameters\n  float mmScaleFactor;\n  float daniele_n;         // peak white\n  float daniele_n_r;       // Normalized white in nits (what 1.0 should be)\n  float daniele_g;         // surround / contrast\n  float daniele_c;         // scene-referred grey\n  float daniele_c_d;       // display-referred grey (in nits)\n  float daniele_w_g;       // grey change between different peak luminance\n  float daniele_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float daniele_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float daniele_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n  // Hellwig 2022 CAM params\n  // the kernel parameters\n\n  // 0 = Stock CAT16\n  // 1 = Thomas's custom primaries\n  // 2 = live from params below\n  int catDataSelection; // original vs modified CAT16 matrix\n  // xy coordinates for custom CAT matrix\n  float2 rxy;\n  float2 gxy;\n  float2 bxy;\n  float2 wxy;\n  float  ra;\n  float  ba;\n\n  // Input vars\n  float3 XYZ_w;\n  float  XYZ_w_scaler;\n  float  L_A;\n  float  Y_b;\n  float3 L_B;\n  float3 userSurround;\n  bool   discount_illuminant;\n  // Output vars\n  float L_A_out;\n  float Y_b_out;\n\nlocal:\n  // Hellwig 2022 constants\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n  float3x3 panlrcm;\n\n  float daniele_r_hit;\n  float daniele_m_0;\n  float daniele_m_1;\n  float daniele_u;\n  float daniele_m;\n  float daniele_w_i;\n  float daniele_c_t;\n  float daniele_g_ip;\n  float daniele_g_ipp2;\n  float daniele_w_2;\n  float daniele_s_2;\n  float daniele_u_2;\n  float daniele_m_2;\n\n  // Chroma compression pre-calculated constants\n  float compr;   // Compression\n  float sat;     // Saturation\n  float sat_thr; // Threshold to start expanding saturation\n\n  // Gamut mapper constants\n  float focusDist; // FocusDistance for projection\n\n  // ST2084 vars\n  float st2084_m_1;\n  float st2084_m_2;\n  float st2084_c_1;\n  float st2084_c_2;\n  float st2084_c_3;\n  float st2084_m_1_d;\n  float st2084_m_2_d;\n  float st2084_L_p;\n\n  // using the float3x3 type to store the array of 6 coefficients\n  // because Blink does not support generic array assignments\n\n  // matrix vars\n  float3x3 identity_matrix;\n\n  float3x3 XYZ_to_RGB_input;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 XYZ_to_RGB_reach;\n  float3x3 XYZ_to_RGB_output;\n\n  float3x3 RGB_to_XYZ_input;\n  float3x3 RGB_to_XYZ_limit;\n  float3x3 RGB_to_XYZ_reach;\n  float3x3 RGB_to_XYZ_output;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n\n  // white points\n  float3 inWhite;\n  float3 outWhite;\n  float3 limitWhite;\n\n  // the maximum RGB value of the limiting gamut\n  float boundaryRGB;\n\n  // the maximum lightness value of the limiting gamut\n  float limitJmax;\n\n  // Middle gray J\n  float midJ;\n\n  // Hellwig model's gamma (1 / cz)\n  float model_gamma;\n\n  // the 'tempTableUnsorted' table is populated\n  // in increments of H of the limiting gamut HSV space starting at H=0.0\n  // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n  // the entries are then wrap-around shifted\n  // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n  // both tables need to be declared here since temporary array variables\n  // in the init() fuction seem to crash Nuke on some systems\n  float3 gamutCuspTable\[gamutCuspTableSize + 1];\n  float3 gamutCuspTableReach\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutReachTable\[gamutCuspTableSize + 1];\n  float2 gamutGammas\[gamutCuspTableSize + 1];\n  float  LocusLimitMTable\[gamutCuspTableSize + 1];\n\n  void define()\n  \{\n    defineParam(chroma_compress_fact, \"Chroma Compress Factor\", 5.0f);\n    defineParam(chroma_expand_fact, \"Chroma Expansion Factor\", 0.78f);\n    defineParam(smoothJ, \"Smoothing factor cusp J\", 0.055f);\n    defineParam(smoothM, \"Smoothing factor cust M\", 0.183f);\n  \}\n\n  // Functions used in ACES 2.0 candidate CAM DRT\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  inline float spow(float base, float exponent)\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ;\n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b)\n\n    // float a_p = sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else\n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if (base < 0.0f && exponent != floor(exponent))\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent);\n    \}\n  \}\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  float3 float3spow(float3 base, float exponent)\n  \{\n    return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  // \"safe\" div\n  float sdiv(float a, float b)\n  \{\n    if (b == 0.0f)\n    \{\n      return 0.0f;\n    \}\n    return a / b;\n  \}\n\n  float degree_of_adaptation(float F, float L_A)\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float  ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d   = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  // basic 3D hypotenuse function, does not deal with under/overflow\n  inline float hypot_float3(float3 xyz)\n  \{\n    return length(xyz);\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float r = R / C;\n    r       = r * r;\n    r       = sqrt(4.0f / r + 1.0f) - 1.0f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float t = 0.5f + sqrt(s * s + r * r / 4.0f);\n    t       = C / t; // t is always >= 0.5f\n\n    xyz_temp = xyz_temp * t + C;\n\n    return xyz_temp;\n  \}\n\n  float3 uncompress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float t = C / R;\n    t       = t - 0.5f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float r = 2 * sqrt(fabs(t * t - s * s)) + 1;\n    r       = sqrt(fabs(r * r - 1));\n    if (r == 0.0)\n      return xyz;\n    r = C * 2 / r;\n\n    xyz_temp = xyz_temp * r + C;\n\n    return xyz_temp;\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float hr)\n  \{\n    return -0.160 * cos(hr) + 0.132 * cos(2 * hr) - 0.405 * sin(hr) + 0.080 * sin(2 * hr) + 0.792;\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n      Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n      Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? spow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n    const float3 F_L_RGB = float3pow(F_L / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, float F_L)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV(float3 RGB)\n  \{\n    float cmax  = max(RGB.x, max(RGB.y, RGB.z));\n    float cmin  = min(RGB.x, min(RGB.y, RGB.z));\n    float delta = cmax - cmin;\n\n    float3 HSV;\n    HSV.x = delta == 0.0f ? 0.0f\n      : cmax == RGB.x     ? (fmod((RGB.y - RGB.z) / delta + 6.0f, 6.0f)) / 6.0f\n      : cmax == RGB.y     ? (((RGB.z - RGB.x) / delta + 2.0f) / 6.0f)\n                          : (((RGB.x - RGB.y) / delta + 4.0f) / 6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a          = JM.y / (focusJ * slope_gain);\n    float b          = 0.0f;\n    float c          = 0.0f;\n    float intersectJ = 0.0f;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      intersectJ = 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      intersectJ = 2.0f * c / (-b + root);\n    \}\n\n    return intersectJ;\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (viewingConditions == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (viewingConditions == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (viewingConditions == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (viewingConditions == 3)\n    \{\n      // Pull from external input\n      newSurround = userSurround;\n    \}\n    return newSurround;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear(float v)\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084(float v)\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f / 2.4f);\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f / 2.6f);\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ          = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh          = XYZ_to_JMh(XYZ, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n    // First matrix to limiting gamut for clamping\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_limit, luminanceXYZ);\n\n    if (fitWhite)\n    \{\n      // Scale to fit maximum creative white channel value\n      float3 creativeWhiteXYZ = vector_dot(RGB_to_XYZ_limit, float3(1.0f, 1.0f, 1.0f)); // TODO: these scaling parameters could be precalculated\n      float3 creativeWhiteRGB = vector_dot(XYZ_to_RGB_output, creativeWhiteXYZ);\n      luminanceRGB *= 1.0f / max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    \}\n\n    if (softclampOutput)\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    if (clampOutput)\n    \{\n      // Clamp to between zero and peak luminance\n      luminanceRGB = clamp3(luminanceRGB, 0.0f, peakLuminance);\n    \}\n\n    // Matrix to output (encoding) gamut (eventually concatenate to a single matrix)\n    luminanceRGB = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceRGB);\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3(encodingOut, luminanceRGB);\n\n    return outputRGB;\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 RGB_to_JMh(const float3 RGB, float3 refWhite, const float3x3& matrix)\n  \{\n    const float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    const float3 XYZ          = vector_dot(matrix, luminanceRGB);\n    const float3 JMh          = XYZ_to_JMh(XYZ, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the given primaries\n  float3 JMh_to_RGB(float3 JMh, float3 refWhite, const float3x3& matrix)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    float3 luminanceRGB = vector_dot(matrix, luminanceXYZ);\n    float3 RGB          = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    XYZ_w = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    if (compressMode)\n    \{\n      RGB_c = compress_bjorn(RGB_c);\n    \}\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n    if (compressMode)\n    \{\n      RGB_a = uncompress_bjorn(RGB_a);\n    \}\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    float R_a = RGB_a.x;\n    float G_a = RGB_a.y;\n    float B_a = RGB_a.z;\n    float a   = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    float b   = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    float hr = atan2(b, a);\n    float h  = wrap_to_360(degrees(hr));\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    float R_a2 = RGB_a.x;\n    float G_a2 = RGB_a.y;\n    float B_a2 = RGB_a.z;\n\n    float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w, surround.y * z);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *chroma* :math:`C`.\n    float C = 35.0f * M / A_w;\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // float s = 100.0f * sdiv(M, Q);\n  \n    if (HK_mode)\n    \{\n      // # *Helmholtz–Kohlrausch* Effect Extension.\n      J = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n      // float Q_HK = (2.0f / surround.y) * (J / 100.0f) * A_w;\n    \}\n    \n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    float J = JMh.x;\n    float M = JMh.y;\n    float h = JMh.z;\n    XYZ_w   = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n    float A_w  = ra * R_aw + G_aw + ba * B_aw;\n\n    float hr = radians(h);\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    float C = (M * 35) / A_w;\n    if (HK_mode)\n    \{\n      J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n    \}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    float P_p_1 = 43.0f * surround.z;\n    float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    float gamma = M / P_p_1;\n    float a     = gamma * cos(hr);\n    float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    if (compressMode)\n    \{\n      RGB_a = compress_bjorn(RGB_a);\n    \}\n\n    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n    if (compressMode)\n    \{\n      RGB_c = uncompress_bjorn(RGB_c);\n    \}\n\n    // # Step 6\n    float3 RGB = RGB_c / D_RGB;\n\n    // # Step 7\n    float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  int find_upper_hue_in_table(float h, float3 table\[], int table_size)\n  \{\n    int low_i  = 0;\n    int high_i = table_size - 1;\n    int i      = hue_position_in_uniform_table(h, table_size);\n\n    while (low_i + 1 < high_i)\n    \{\n      if (h > table\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float2 cuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n    if (h <= gamutCuspTable\[0].z)\n    \{\n      lo   = gamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = gamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > gamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = gamutCuspTable\[high_i - 1];\n      hi = gamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 cuspFromTableLocus(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float lo = LocusLimitMTable\[i_lo];\n    const float hi = LocusLimitMTable\[i_lo + 1];\n\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    const float cuspJ = 69;\n    const float cuspM = lerp(lo, hi, t);\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (h <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  float cReachFromTable(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = cgamutReachTable\[i_lo];\n    const float3 hi = cgamutReachTable\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y       = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float  hr     = radians(h);\n\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + hr) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float _h   = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n             + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    return JMcusp.y * e_t;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f);\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = cusp_with_eccentricity_factor(JMh.z);\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!invert)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      if (applyInGamutCompression)\n      \{\n        // Normalize M with the rendering space cusp M\n        M /= Mnorm;\n\n        // Expand the colorfulness by running the toe function in reverse.  The goal is to\n        // expand less saturated colors less and more saturated colors more.  The expansion\n        // increases saturation in the shadows and mid-tones but not in the highlights.\n        // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n        // the toe less aggressive near black to reduce the expansion of noise.\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n        // Compress the colorfulness.  The goal is to compress less saturated colors more and\n        // more saturated colors less, especially in the highlights.  This step creates the\n        // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n        // mostly affects highlights and mid-tones, and does not compress shadows.\n        M = toe(M, limit, nJ * compr, snJ, 0);\n\n        // Clamp M to the rendering space\n        if (applyReachClamp)\n          M = min(limit, M);\n\n        // Denormalize\n        M *= Mnorm;\n      \}\n    \}\n    else\n    \{\n      if (applyInGamutCompression)\n      \{\n        M /= Mnorm;\n        M = toe(M, limit, nJ * compr, snJ, 1);\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n        M *= Mnorm;\n      \}\n\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    if (AP1Clamp)\n    \{\n      luminanceRGB   = vector_dot(XYZ_to_AP1, luminanceXYZ);\n      luminanceRGB.x = max(0.0f, luminanceRGB.x);\n      luminanceRGB.y = max(0.0f, luminanceRGB.y);\n      luminanceRGB.z = max(0.0f, luminanceRGB.z);\n      luminanceXYZ   = vector_dot(AP1_to_XYZ, luminanceRGB);\n    \}\n\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n    else\n    \{\n      return JMh;\n    \}\n  \}\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB     = luminanceToEncoding3(encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\nfloat Y_to_Hellwig_J(float Y, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n    return sign(Y) * 100.0f * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, surround.y * z);\n  \}\n\n  float Hellwig_J_to_Y(float J, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float A = A_w * pow(fabs(J) / 100.0f, 1.0f / (surround.y * z));\n\n    return sign(J) * 100.0f / F_L * pow((27.13f * A) / (400.0f - A), 1.0f / 0.42f);\n  \}\n\n  float3 forwardTonescale(float3 inputJMh)\n  \{\n    float3 outputJMh;\n    float3 surround    = viewingConditionsToSurround(viewingConditions);\n    float  linear      = Hellwig_J_to_Y(inputJMh.x, surround) / referenceLuminance;\n    float  luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if (toneScaleMode == 1)\n    \{\n      luminanceTS = daniele_evo_fwd(luminanceTS) * mmScaleFactor;\n    \}\n\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, surround);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    if (applyTonecurve)\n    \{\n      outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n      outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    if (monochrome)\n    \{\n      outputJMh.y = 0.0f;\n    \}\n\n    return outputJMh;\n  \}\n\n  float3 inverseTonescale(float3 JMh)\n  \{\n    float3 tonemappedJMh = JMh;\n    float3 surround = viewingConditionsToSurround(viewingConditions);\n\n    if (!applyTonecurve && !applyChromaCompression)\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n\n    float luminance = Hellwig_J_to_Y(tonemappedJMh.x, surround);\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if (toneScaleMode == 1)\n    \{\n      linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n      linear = luminance;\n    \}\n\n    linear = linear * referenceLuminance;\n\n    if (applyTonecurve)\n    \{\n      float untonemappedJ = Y_to_Hellwig_J(linear, surround);\n      untonemappedColourJMh = float3(untonemappedJ, tonemappedJMh.y, tonemappedJMh.z);\n    \}\n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return untonemappedColourJMh;\n  \}\n\n  float2 hueDependantHullGammas(float h)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(h, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    return lerp(gamutGammas\[i_lo], gamutGammas\[i_lo + 1], t);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float gamma_top, float gamma_bottom)\n  \{\n    float2 JM_source = float2(JMh_s.x, JMh_s.y);\n\n    float slope = 0.0f;\n\n    float s = max(0.000001f, smoothness);\n    JM_cusp.x *= 1.0f + smoothJ * s; // J\n    JM_cusp.y *= 1.0f + smoothM * s; // M\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, 1 / gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp)\n      * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), 1.0f / gamma_top) / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, s);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'.\n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.05f, cusp.x / limitJmax), 0.0001f);\n    cusp.y *= 1.0f + 0.18f * s;\n    cusp.x *= 1.0f + 0.07f * s;\n\n    // Line below the cusp is curved with model_gamma\n    float toJ_gamma   = cusp.x * spow(to.x / cusp.x, model_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, model_gamma);\n    t0                = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float2 findCurveIntersection(float c, float2 cusp, float m, float h)\n  \{\n    // based on this desmos plot https://www.desmos.com/calculator/pcsovzirqa\n    float xc = cusp.y;\n    float yc = cusp.x;\n    float f  = 1.0;\n    float mf = m * f;\n    float xi = 1.0f;\n    float g1 = 1.0f / model_gamma;\n    float g2 = hueDependantHullGammas(h).y;\n\n    if (m * xc + c < yc)\n    \{\n      // below cusp\n      xi = spow((1 - mf), (g1 - 1)) * ((yc * spow((c / yc), (1.0 / g1))) / (yc / xc - m));\n    \}\n    else\n    \{\n      // above cusp\n      xi =\n        spow((1 + mf), ((g2 - 1))) * (xc * (limitJmax - yc) * spow(((limitJmax - c) / (limitJmax - yc)), (1 / g2)) / (m * xc + limitJmax - yc));\n    \}\n    float yi = (m * xi) + c;\n    if (yi > limitJmax)\n    \{\n      yi = limitJmax;\n      xi = 0.0f;\n    \}\n    return float2(yi, xi);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus     = cuspFromTableLocus(h);\n    float  cuspTarget100 = cuspLocus.y;\n    float  cuspTarget    = cuspTarget100 * pow((Jmh.x / 100.0f), model_gamma);\n    float  difference    = cuspLocus.y / cuspTarget;\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float3 getReachBoundry(float3 Jmh)\n  \{\n    const float h = Jmh.z;\n\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = gamutCuspTableReach\[i_lo];\n    const float3 hi = gamutCuspTableReach\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n\n    const float reachMaxM = lerp(lo.y, hi.y, t);\n    if (reachNick)\n    \{\n      float2 JMcusp     = cuspFromTable(Jmh.z);\n      float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain = limitJmax * focusDist * getFocusGain(Jmh.x, JMcusp.x);\n      float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n      float  slope;\n      if (intersectJ < focusJ)\n      \{\n        slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      else\n      \{\n        slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      float boundaryNick = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n      return float3(Jmh.x, boundaryNick, Jmh.z);\n    \}\n    float cuspTarget = reachMaxM * pow((Jmh.x / limitJmax), model_gamma);\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n\n    if (Reachcompressmode)\n    \{\n      if (primariesReach != 6) // All of the primary based reach values\n      \{\n        // use primary based reach\n        float locusMax   = getReachBoundry(Jmh).y;\n        float difference = max(1.0001f, locusMax / Jmh.y);\n        float threshold  = max(compressionFuncParams.x, 1.0f / difference);\n        return float4(threshold, difference, difference, compressionFuncParams.w);\n      \}\n      else\n      \{\n        // use locus based reach\n        float locusMax   = getLocusBoundry(Jmh).y;\n        float difference = locusMax / Jmh.y;\n        return float4(compressionFuncParams.x, difference, difference, compressionFuncParams.w);\n      \}\n    \}\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h >= angleR && h < angleY)\n      \{\n        lerpVal = (h - angleR) / (angleY - angleR);\n        return lerp(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h >= angleY && h < angleG)\n      \{\n        lerpVal = (h - angleY) / (angleG - angleY);\n        return lerp(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h >= angleG && h < angleC)\n      \{\n        lerpVal = (h - angleG) / (angleC - angleG);\n        return lerp(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h >= angleC && h < angleB)\n      \{\n        lerpVal = (h - angleC) / (angleB - angleC);\n        return lerp(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h >= angleB && h < angleM)\n      \{\n        lerpVal = (h - angleB) / (angleM - angleB);\n        return lerp(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h >= angleM && h < angleR + 360.0f)\n      \{\n        lerpVal = (h - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h < angleR)\n      \{\n        lerpVal = (h + 360.0f - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  float getFocusGain(float J, float cuspJ)\n  \{\n    if (disableFocusGain)\n      return 1.0f;\n\n    float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J > thr)\n    \{\n      // Approximate inverse required above threshold\n      float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n      return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n    \}\n    else\n    \{\n      // Analytic inverse possible below cusp\n      return 1.0f;\n    \}\n  \}\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    if (disableFocusGain)\n      return compressGamut2(JMh, invert, JMh.x);\n\n    if (!invert)\n    \{\n      return compressGamut2(JMh, 0, JMh.x);\n    \}\n    else\n    \{\n      float2 JMcusp = cuspFromTable(JMh.z);\n      float  Jx     = JMh.x;\n\n      // Analytic inverse below threshold\n      if (Jx <= lerp(JMcusp.x, limitJmax, focusGainBlend))\n        return compressGamut2(JMh, 1, Jx);\n\n      // Approximation above\n      Jx = compressGamut2(JMh, 1, Jx).x;\n      return compressGamut2(JMh, 1, Jx);\n    \}\n  \}\n\n  float3 compressGamut2(float3 JMh, int invert, float Jx)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp       = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDist * JMcusp.y);\n    float a      = max(0.001f, Mratio / focusJ);\n    float b0     = 1.0f - Mratio;\n    float b1     = -(1.0f + Mratio + (a * limitJmax));\n    float b      = project_from.x < focusJ ? b0 : b1;\n    float c0     = -project_from.x;\n    float c1     = project_from.x + limitJmax * Mratio;\n    float c      = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0       = sqrt(b * b - 4 * a * c);\n    float J1       = (-b - J0) / (2 * a);\n    J0             = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    float slope_gain = limitJmax * focusDist * getFocusGain(Jx, JMcusp.x);\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = float2(1.0f, 1.0f);\n    if (boundryIntersectionMethod == 0)\n    \{\n      // Original method implemented by Pekka\n      JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    \}\n    else if (boundryIntersectionMethod == 1)\n    \{\n      // Alternate method shown in Oct 19 meeting\n      float m    = (JMh.x - projectJ) / JMh.y;\n      JMboundary = findCurveIntersection(JMh.x, JMcusp, 0.0f, JMh.z);\n    \}\n    else if (boundryIntersectionMethod == 2)\n    \{\n      const float2 gammas      = hueDependantHullGammas(JMh.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      JMboundary               = float2(nickBoundryReturn.x, nickBoundryReturn.y);\n      project_to               = float2(nickBoundryReturn.z, 0.0f);\n      projectJ                 = nickBoundryReturn.z;\n    \}\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams;\n    if (reachNick)\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMboundary.x, JMboundary.y, JMh.z));\n    \}\n    else\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x, JMboundary.y, JMh.z));\n    \}\n\n    if (!Reachcompressmode)\n      interpolatedCompressionFuncParams.x =\n        1.0f / lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n\n    float lowerMlimit = 0.0001f; // Testing a small value here\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)  // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                                    lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                                    interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 20)\n    \{\n      // return focus point\n      return float3(project_to.x, project_to.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n                            ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit  = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0    = daniele_n / daniele_n_r;\n    daniele_m_1    = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u      = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m      = daniele_m_1 / daniele_u;\n    daniele_w_i    = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t    = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip   = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2    = daniele_c / daniele_g_ipp2;\n    daniele_s_2    = daniele_w_2 * daniele_m_1;\n    daniele_u_2    = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2    = daniele_m_1 / daniele_u_2;\n\n    // 1.0f / (c * z)\n    model_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n\n    // Chroma compression scaling for HDR/SDR appearance match\n    float log_peak = log10(daniele_n / daniele_n_r);\n    compr          = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    sat            = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak);\n    sat_thr        = chroma_expand_thr / daniele_n;\n\n    // Gamut mapper focus distance scaling with peak luminance for\n    // HDR/SDR appearance match.  The projection gets slightly less\n    // steep with higher peak luminance.\n    // https://www.desmos.com/calculator/bnfhjcq5vf\n    if (!disableFocusDistScaling)\n      focusDist = focusDistance + focusDistance * focusDistScaling * log_peak;\n    else\n      focusDist = focusDistance;\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    float CAT_CAT16_data\[] = \{\n      0.401288, 0.650173, -0.051461, -0.250268, 1.204414, 0.045854, -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[] = \{\n      0.656619, 0.342071, 0.00131062, -0.222571, 1.10658, 0.115987, -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[] = \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374,\n      238.0180511, 235.4039917, 233.010849,  230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215,\n      190.9799347, 184.005127,  177.7472992, 172.2332611, 166.6447754, 161.64534,   156.9872284, 152.6203003, 148.3236084, 144.2987976,\n      140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861,\n      114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853,  105.188797,  103.6860809, 102.2319641, 100.8348923, 99.51873779,\n      98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951,  92.03639984, 91.15013885, 90.27630615, 89.43255615,\n      88.63536072, 87.8986969,  87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547,\n      83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156,\n      80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702,\n      80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481,  81.901474,   82.20778656, 82.67211151,\n      83.1408844,  83.62628174, 84.0898056,  84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481,\n      88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783,  94.64561462, 95.68405914, 96.84765625,\n      97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031,\n      113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034,\n      137.8343048, 140.7224121, 143.7820892, 147.23909,   150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272,\n      171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255,\n      199.4234161, 201.3786011, 203.1474609, 205.016037,  206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686,\n      215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463,\n      213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355,\n      195.217453,  193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165,\n      174.445282,  172.4908905, 170.5744934, 168.5490723, 166.459259,  164.4333649, 162.5092621, 160.4579468, 158.491806,  156.6880035,\n      155.0045624, 153.295166,  151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602,\n      139.225174,  137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328,   128.7269897,\n      127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358,  120.9004822,\n      120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039,\n      116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118,\n      114.8510284, 114.8482819, 114.848465,  114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528,  115.7195816,\n      115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586,\n      119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077,  124.071022,  124.9082108, 125.74823,   126.6865311,\n      127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252,  130.1131287, 130.5647278,\n      130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609,  136.6136017, 137.5203552,\n      138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586,\n      150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551,\n      168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373,\n      192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452,  206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306,\n      220.6668701, 223.364151,  226.2115479, 228.9524536, 231.5583954, 234.405304,  237.0275879, 239.5091705, 242.0047455, 242.0177155,\n      244.8230133\};\n\n    // populate the input primaries matrix\n    RGB_to_XYZ_input = generate_RGB_to_XYZ_matrix(primariesIn);\n    XYZ_to_RGB_input = RGB_to_XYZ_input.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(1); // AP1 == 1\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix;\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n    if (whiteLimit == 0)\n    \{\n      limitWhiteForMatrix = float2(0.32168f, 0.33767f);\n    \}\n    else if (whiteLimit == 1)\n    \{\n      limitWhiteForMatrix = float2(0.3127f, 0.3290f);\n    \}\n    else\n    \{\n      limitWhiteForMatrix = float2(0.333333f, 0.333333f);\n    \}\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001, -0.077);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, 0);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    RGB_to_XYZ_reach = generate_RGB_to_XYZ_matrix(primariesReach);\n    XYZ_to_RGB_reach = RGB_to_XYZ_reach.invert();\n\n    RGB_to_XYZ_output = generate_RGB_to_XYZ_matrix(primariesOut);\n    XYZ_to_RGB_output = RGB_to_XYZ_output.invert();\n\n    float3 white(1.0f, 1.0f, 1.0f);\n    inWhite    = vector_dot(RGB_to_XYZ_input, white);\n    outWhite   = vector_dot(RGB_to_XYZ_output, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = peakLuminance / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n      CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n      CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n      CAT_CAT16 = RGBPrimsToXYZMatrix(rxy, gxy, bxy, wxy, 1.0f, 1);\n    \}\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    generate_panlrcm();\n\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    limitJmax = RGB_to_JMh(float3(1.0f), limitWhite, RGB_to_XYZ_limit).x;\n\n    // Cusp table for chroma compression gamut\n    float3x3 RGB_to_XYZ_cgReach;\n    if (ccReach == 0) // Chroma Compression Space (primaries defined in kernel params)\n    \{\n      RGB_to_XYZ_cgReach = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 0);\n\n    \}\n    else if (ccReach == 1)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(0);\n    \}\n    else if (ccReach == 2)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(1);\n    \}\n    else\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(3);\n    \}\n    const float3x3 XYZ_to_RGB_cgReach = RGB_to_XYZ_cgReach.invert();\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, inWhite, RGB_to_XYZ_cgReach);\n    initialise_reach_cusp_table(cgamutReachTable, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_cgReach);\n\n    // With gamut mapper reach mode 7, use the chroma compression reach space with the\n    // gamut mapper.\n    if (primariesReach == 7)\n      XYZ_to_RGB_reach = XYZ_to_RGB_cgReach;\n\n    // Cusp table for limiting gamut\n    initialise_cusp_table(gamutCuspTable, gamutCuspTableSize, limitWhite, RGB_to_XYZ_limit);\n    initialise_reach_cusp_table(gamutCuspTableReach, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_reach);\n\n    midJ = XYZ_to_JMh(inWhite * daniele_c_t * mmScaleFactor, inWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid,\n                      HK_mode_mid)\n             .x;\n\n    initialise_upper_hull_gamma();\n    initialise_lower_hull_gamma();\n  \}\n\n  void initialise_cusp_table(float3 output_table\[], const int table_size, float3 refWhite, const float3x3& matrix)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      tempTableUnsorted\[i] = RGB_to_JMh(RGB, refWhite, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 tableUnsorted\[], const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 output_table\[], const int table_size, const float limitJ, float3 refWhite, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_RGB(float3(limitJ, high, hue), refWhite, matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_RGB(float3(limitJ, sampleM, hue), refWhite, matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, min(1.0, cuspMidBlend - (JMcusp.x / limitJmax)));\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, topGamma, lowerHullGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma()\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        gamutGammas\[i].x =  upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      gamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].x = gamutGammas\[0].x;\n   \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float slope_gain = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n\n      const float3 approxLimit     = findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax,\n                                                                   slope_gain, smoothCusps, upperHullGamma, bottomGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma()\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        gamutGammas\[i].y = lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      gamutGammas\[i].y = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].y = gamutGammas\[0].y;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n    float3 diagnostic;\n\n    if (invert)\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh           = inverseTonescale(tonemappedJMh);\n      diagnostic    = JMh_to_input_RGB(JMh);\n    \}\n    else\n    \{\n      JMh           = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n      diagnostic    = JMh_to_output_RGB(compressedJMh);\n    \}\n\n    if (diagnosticMode == 1 || diagnosticMode == 6)\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if (invert)\n      \{\n        diagnostic = JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic = JMh;\n      \}\n    \}\n    else if (diagnosticMode == 2 || diagnosticMode == 99)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if (diagnosticMode == 3 || diagnosticMode == 5)\n    \{\n      diagnostic = compressedJMh;\n    \}\n    else if (diagnosticMode == 4 || diagnosticMode == 7)\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB     = JMh_to_output_RGB(srcRGB);\n      diagnostic = dstRGB;\n    \}\n    else if (diagnosticMode == 8)\n    \{\n      diagnostic = inWhite;\n    \}\n    else if (diagnosticMode == 9)\n    \{\n      diagnostic = outWhite;\n    \}\n    else if (diagnosticMode == 10)\n    \{\n      diagnostic = limitWhite;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      const float2 JMcusp = cuspFromTable(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      const float2 JMcusp = cuspFromTableLocus(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundary\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundary\n      diagnostic = getReachBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 20)\n    \{\n      // output JMFocus\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 21)\n    \{\n      // output JMFocus\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).y, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 22)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float slope_gain = limitJmax * focusDist;\n      diagnostic       = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 23)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic         = float3(approxLimit.x, approxLimit.y, srcRGB.z);\n    \}\n\n    else if (diagnosticMode == 24)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      float3 newLimitRGB = JMh_to_RGB(float3(approxLimit.x, approxLimit.y, srcRGB.z), limitWhite, XYZ_to_RGB_limit);\n      diagnostic         = newLimitRGB;\n    \}\n\n    else if (diagnosticMode == 25)\n    \{\n      float2 JMcusp            = cuspFromTable(srcRGB.z);\n      float  focusJ            = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain        = limitJmax * focusDist * getFocusGain(JMh.x, JMcusp.x);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(srcRGB, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic               = float3(srcRGB.x, nickBoundryReturn.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 26)\n    \{\n      // XYZ back to luminance RGB\n      float3 JMh = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n      diagnostic = vector_dot(XYZ_to_RGB_limit, JMh);\n    \}\n    else if (diagnosticMode == 27)\n    \{\n      // output\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).x, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 28)\n    \{\n      // output\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      diagnostic    = findGamutBoundaryIntersection(srcRGB, JMcusp, lerp(JMcusp.x, midJ, cuspMidBlend), limitJmax, 10000.0f, 0.0f,\n                                                    gammas.x, gammas.y);\n    \}\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    ////// FORWARD PATHWAY\n\n    else if (diagnosticMode == 100)\n    \{\n      // display encoding to display linear\n      diagnostic      = encodingToLuminance3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 101)\n    \{\n      // convert to linear XYZ luminance values\n      diagnostic = vector_dot(RGB_to_XYZ_input, srcRGB);\n    \}\n    else if (diagnosticMode == 102)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 105)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 106)\n    \{\n      // display luminance XYZ to display linear RGB\n      diagnostic = vector_dot(XYZ_to_RGB_output, srcRGB);\n    \}\n    else if (diagnosticMode == 107)\n    \{\n      // display linear RGB to display encoded RGB\n      diagnostic = luminanceToEncoding3(encodingOut, srcRGB);\n    \}\n\n    ////// INVERSE PATHWAY\n\n    else if (diagnosticMode == 200)\n    \{\n      // output display encoded RGB to display linear RGB\n      diagnostic = encodingToLuminance3(encodingOut, srcRGB);\n    \}\n    else if (diagnosticMode == 201)\n    \{\n      // output display linear RGB to output display linear XYZ\n      diagnostic = vector_dot(RGB_to_XYZ_output, srcRGB);\n    \}\n    else if (diagnosticMode == 202)\n    \{\n      // output XYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 203)\n    \{\n      // uncompress gamut\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 204)\n    \{\n      // inverse tonescale in JMh\n      diagnostic = inverseTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 205)\n    \{\n      // inverted JMh back to XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 206)\n    \{\n      // XYZ back to luminance RGB\n      diagnostic = vector_dot(XYZ_to_RGB_input, srcRGB);\n    \}\n    else if (diagnosticMode == 207)\n    \{\n      // luminance RGB to input encoding RGB\n      diagnostic = luminanceToEncoding3(encodingIn, srcRGB);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_AP1Clamp {{parent.ap1_clamp}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_peakLuminance {{parent.peak_luminance}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_applyInGamutExpansion {{parent.applyInGamutExpansion}}
  DRT_CAM_Kernel_applyInGamutCompression {{parent.applyInGamutCompression}}
  DRT_CAM_Kernel_applyReachClamp {{parent.applyReachClamp}}
  DRT_CAM_Kernel_monochrome {{parent.monochrome}}
  DRT_CAM_Kernel_chroma_compress {{parent.compress}}
  "DRT_CAM_Kernel_Chroma Compress Factor" {{parent.chroma_compress_fact}}
  DRT_CAM_Kernel_chroma_expand {{parent.chroma_expand}}
  "DRT_CAM_Kernel_Chroma Expansion Factor" {{parent.chroma_expand_fact}}
  DRT_CAM_Kernel_chroma_expand_thr {{parent.chroma_expand_thr}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_ccReach {{parent.ccReachPrimaries}}
  DRT_CAM_Kernel_crxy {0.7347 0.2653}
  DRT_CAM_Kernel_cgxy {0.12 0.88}
  DRT_CAM_Kernel_cbxy {0.08 -0.04}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_whiteLimit {{parent.white_limit}}
  DRT_CAM_Kernel_primariesReach {{parent.primaries_reach}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_focusAdjustGain {{parent.focusgain}}
  DRT_CAM_Kernel_focusGainBlend {{parent.focus_gain_blend}}
  DRT_CAM_Kernel_focusDistScaling {{parent.focusdistscaling}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r x272 -1.75} {parent.compression_params.g} {parent.compression_params.b} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR x272 0.21} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Reachcompressmode {{parent.reachCompressMode}}
  DRT_CAM_Kernel_reachNick true
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_boundryIntersectionMethod {{boundryIntersectionMethod}}
  DRT_CAM_Kernel_disableLowerHullGamma true
  DRT_CAM_Kernel_lowerHullGamma {{lowerHullGamma}}
  DRT_CAM_Kernel_upperHullGamma {{parent.upperHullGamma}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  "DRT_CAM_Kernel_Smoothing factor cusp J" {{parent.smoothJ}}
  "DRT_CAM_Kernel_Smoothing factor cust M" {{parent.smoothM}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_fitWhite {{parent.fit_white}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.peak_luminance}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.8336 0.1735}
  DRT_CAM_Kernel_gxy {2.3854 -1.4659}
  DRT_CAM_Kernel_bxy {0.087 -0.125}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Reformat {
 type scale
 scale 7
 filter impulse
 name Reformat8
 label "scale up 7x"
 xpos 935
 ypos 658
}
Dot {
 name Dot13
 xpos 969
 ypos 690
}
set Nb048f600 [stack 0]
Expression {
 expr0 isnan(r)?0:r
 expr1 isnan(g)?0:g
 expr2 isnan(b)?0:b
 name killNan7
 xpos 981
 ypos 707
}
Clamp {
 minimum -65535
 maximum 65535
 name Clamp7
 xpos 981
 ypos 731
}
Colorspace {
 illuminant_in ACES
 primary_in ACES
 colorspace_out CIE-XYZ
 name Colorspace11
 label "XYZ to AP0"
 xpos 981
 ypos 767
 disable true
}
ColorMatrix {
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 invert true
 name ColorMatrix11
 label "APS4 to XYZ"
 xpos 981
 ypos 799
 disable true
}
Expression {
 temp_name0 cut_lin
 temp_expr0 0.0078125
 temp_name1 cut_log
 temp_expr1 0.155251141552511
 temp_name2 A
 temp_expr2 10.5402377416545
 temp_name3 B
 temp_expr3 0.0729055341958355
 expr0 r<=cut_lin?A*r+B:(log(r)/log(2)+9.72)/17.52
 expr1 g<=cut_lin?A*g+B:(log(g)/log(2)+9.72)/17.52
 expr2 b<=cut_lin?A*b+B:(log(b)/log(2)+9.72)/17.52
 channel3 none
 name lin2log6
 label ACEScct
 xpos 981
 ypos 831
}
push $Nb048f600
Switch {
 inputs 2
 which {{master.inverseMode}}
 name Switch9
 xpos 935
 ypos 874
}
Group {
 name Write_ResolveACES_ODT_LUT1
 label "\[python nuke.thisNode().knob('cubePath').evaluate().split('/').pop(-1)]"
 xpos 935
 ypos 996
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate CAMDRT
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target "Rec2100 (P3D65 4000nit Limited)"
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate_\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template_AP0.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template_AP0.fltransform
 addUserKnob {1 dctlColorspaceBufferTag}
 dctlColorspaceBufferTag Rec2020_4000nits_15nits_ST2084
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev060/ACES2 Candidate CAMDRT rev060 Rec2100 (P3D65 4000nit Limited)_inverse.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $Nb2fce800
Group {
 name DRT_CAMv6
 label "Input: \[value encoding_in]  / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value white_limit] / \[value peak_luminance]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 774
 ypos 552
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {6 ap1_clamp l "AP1 clamp" t "Clamp input chromaticities to AP1 rendering space" +STARTLINE}
 ap1_clamp true
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {7 peak_luminance l "Peak Luminance" t "Target peak luminance in cd/m^2" R 0 1000}
 peak_luminance 500
 addUserKnob {6 monochrome t "Output monochrome image" +STARTLINE}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply chroma compression" t "Applies the chroma compression step.  If this checkbox alone is checked the applies only the scaling step of chroma compression, but not the in-gamiut compression or the saturation." +STARTLINE}
 applyChromaCompression true
 addUserKnob {6 applyInGamutExpansion l "apply in gamut expansion" t "Expands colorfulness to increase saturation" +STARTLINE}
 applyInGamutExpansion true
 addUserKnob {6 applyInGamutCompression l "apply in gamut compression" +STARTLINE}
 applyInGamutCompression true
 addUserKnob {6 applyReachClamp l "apply reach mode clamp" t "Clamp the chroma compressed result to the rendering space" +STARTLINE}
 addUserKnob {7 compress l "chroma compression" t "Chroma compression amount" R 2 10}
 compress 2.4
 addUserKnob {7 chroma_compress_fact l HDR t "Chroma compression scaling factor for SDR/HDR appearance match.  Smaller values will compress less as peak luminance goes highger, higher values compress more.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 2 6}
 chroma_compress_fact 3.3
 addUserKnob {7 chroma_expand l "chroma expansion" t "Chroma expansion to increase saturation in shadows and mid-tones" R 1 4}
 chroma_expand 1.3
 addUserKnob {7 chroma_expand_fact l HDR t "Chroma expansion scaling factor for SDR/HDR appearance match.  Smaller values will have more saturation as peak luminance goes highger, higher values will have less saturation.\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 0.5 0.9}
 chroma_expand_fact 0.69
 addUserKnob {7 chroma_expand_thr l "chroma expansion threshold" t "Threshold for starting chroma expansion, meant to avoid expanding noise floor" R 0.5 1}
 chroma_expand_thr 0.5
 addUserKnob {4 ccReachPrimaries l "reach primaries" t "Primaries that define how far chroma compression and expansion reaches." M {"Chroma Compression Space" AP0-ACES AP1-ACES Rec.2020-D65 ""}}
 ccReachPrimaries AP1-ACES
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" "" "" ""}}
 et None
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709 Rec.2020 P3 "" ""}}
 primaries_limit P3
 addUserKnob {4 white_limit l "white point" t "The white point of the limiting gamut. Also used as the reference white for the output XYZ conversion, independent of the white point of the final encoding. This makes it effectively the creative white." -STARTLINE M {"ACES White" D65 "" "" ""}}
 white_limit D65
 addUserKnob {4 primaries_reach l "reach primaries" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "Spectral Locus" "Chroma Compression Space"}}
 primaries_reach AP1-ACES
 addUserKnob {6 reachCompressMode l "Reach Compression Mode" -STARTLINE}
 reachCompressMode true
 addUserKnob {4 boundryIntersectionMethod M {"Original Pekka" "Oct 19" "New From Nick" ""}}
 boundryIntersectionMethod "New From Nick"
 addUserKnob {41 DRT_CAM_Kernel_reachNick l "Use Nick method for reach" -STARTLINE T BlinkScript1.DRT_CAM_Kernel_reachNick}
 addUserKnob {41 DRT_CAM_Kernel_disableUpperHullGamma l disableUpperHullGamma T BlinkScript1.DRT_CAM_Kernel_disableUpperHullGamma}
 addUserKnob {7 upperHullGamma -STARTLINE R 0 2}
 upperHullGamma 1
 addUserKnob {41 DRT_CAM_Kernel_disableLowerHullGamma l disableLowerHullGamma T BlinkScript1.DRT_CAM_Kernel_disableLowerHullGamma}
 addUserKnob {7 lowerHullGamma -STARTLINE R 0 2}
 lowerHullGamma 1.14
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue and mid J.  higher cusps will closer to the cusp lightness, lower cusps will be closer to midJ" R 0.6 2}
 cusp_mid_blend 1.3
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic." R 1.1 2}
 focus_distance 1.35
 addUserKnob {7 focusdistscaling l HDR t "Focus distance scaling factor as peak luminance gets higher for SDR/HDR appearance match.  The projection gets less steep with higher projection\n\nThis setting has effect only for peak luminance >100 nits." -STARTLINE R 1 2}
 focusdistscaling 1.75
 addUserKnob {41 DRT_CAM_Kernel_disableFocusGain l disableFocusGain T BlinkScript1.DRT_CAM_Kernel_disableFocusGain}
 addUserKnob {7 focus_gain_blend l "focus gain blend" t "Blend between cusp J and limitJmax to determine the point where the focus gain is applied.\n\n0 = cuspJ\n1 = limitJmax"}
 focus_gain_blend 0.3
 addUserKnob {7 focusgain l "focus gain" -STARTLINE}
 focusgain 0.55
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.75 1.1 1.3 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.12
 addUserKnob {7 smoothJ l "smooth J" t "Smoothing scaling factor for cusp J" R 0 0.1}
 addUserKnob {7 smoothM l "smooth M" t "Smoothing scaling factor for cusp M" -STARTLINE R 0 0.25}
 smoothM 0.27
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.2 1.4 {compressionFuncParamsR.g} 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {{compressionFuncParamsR.r} 1.21 {compressionFuncParamsY.g} 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {{compressionFuncParamsR.r} 1.3 {compressionFuncParamsG.g} 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {{compressionFuncParamsR.r} 1.9 {compressionFuncParamsC.g} 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {{compressionFuncParamsR.r} 1.2 {compressionFuncParamsB.g} 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {{compressionFuncParamsR.r} 1.23 {compressionFuncParamsM.g} 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out ST2084
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out Rec.2020-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 fit_white l "fit white" t "Scale the output so the maximum RGB channel for the creative white becomes 100%. Prevents clipping when the creative and encoding whites do not match." +STARTLINE}
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" -STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 invert {{master.inverseMode}}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {41 kernelSourceFile l "Kernel File" T BlinkScript1.kernelSourceFile}
 addUserKnob {26 "" l " "}
 addUserKnob {41 reloadKernelSourceFile l Load T BlinkScript1.reloadKernelSourceFile}
 addUserKnob {41 recompile l Recompile -STARTLINE T BlinkScript1.recompile}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v060.blink
  recompileCount 4092
  ProgramGroup 1
  KernelDescription "3 \"DRT_CAM_Kernel\" iterate pixelWise 925e58f9470501a7d899ac9a2a52d4f33d9c5f59bd24740acef8f1ed9e380ede 2 \"src\" Read Point \"dst\" Write Point 97 \"encodingIn\" Int 1 AAAAAA== \"AP1Clamp\" Bool 1 AA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"peakLuminance\" Float 1 AAAAAA== \"applyChromaCompression\" Bool 1 AA== \"applyInGamutExpansion\" Bool 1 AA== \"applyInGamutCompression\" Bool 1 AA== \"applyReachClamp\" Bool 1 AA== \"monochrome\" Bool 1 AA== \"chroma_compress\" Float 1 AAAAAA== \"Chroma Compress Factor\" Float 1 AACgQA== \"chroma_expand\" Float 1 AAAAAA== \"Chroma Expansion Factor\" Float 1 FK5HPw== \"chroma_expand_thr\" Float 1 AAAAAA== \"cc_et\" Int 1 AAAAAA== \"ccReach\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"primariesLimit\" Int 1 AAAAAA== \"whiteLimit\" Int 1 AAAAAA== \"primariesReach\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"focusAdjustGain\" Float 1 AAAAAA== \"focusGainBlend\" Float 1 AAAAAA== \"disableFocusGain\" Bool 1 AA== \"disableFocusDistScaling\" Bool 1 AA== \"focusDistScaling\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Reachcompressmode\" Bool 1 AA== \"reachNick\" Bool 1 AA== \"Locuscompressmode\" Bool 1 AA== \"boundryIntersectionMethod\" Int 1 AAAAAA== \"disableUpperHullGamma\" Bool 1 AA== \"disableLowerHullGamma\" Bool 1 AA== \"lowerHullGamma\" Float 1 AAAAAA== \"upperHullGamma\" Float 1 AAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"Smoothing factor cusp J\" Float 1 rkdhPQ== \"Smoothing factor cust M\" Float 1 WmQ7Pg== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"fitWhite\" Bool 1 AA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 97 \"encodingIn\" 1 1 Default \"AP1Clamp\" 1 1 Default \"primariesIn\" 1 1 Default \"toneScaleMode\" 1 1 Default \"discountIlluminant_in\" 1 1 Default \"discountIlluminant_mid\" 1 1 Default \"discountIlluminant_out\" 1 1 Default \"HK_mode_in\" 1 1 Default \"HK_mode_mid\" 1 1 Default \"HK_mode_out\" 1 1 Default \"compressMode\" 1 1 Default \"referenceLuminance\" 1 1 Default \"viewingConditions\" 1 1 Default \"outputViewingConditions\" 1 1 Default \"applyTonecurve\" 1 1 Default \"peakLuminance\" 1 1 Default \"applyChromaCompression\" 1 1 Default \"applyInGamutExpansion\" 1 1 Default \"applyInGamutCompression\" 1 1 Default \"applyReachClamp\" 1 1 Default \"monochrome\" 1 1 Default \"chroma_compress\" 1 1 Default \"chroma_compress_fact\" 1 1 Default \"chroma_expand\" 1 1 Default \"chroma_expand_fact\" 1 1 Default \"chroma_expand_thr\" 1 1 Default \"cc_et\" 1 1 Default \"ccReach\" 1 1 Default \"crxy\" 2 1 Default \"cgxy\" 2 1 Default \"cbxy\" 2 1 Default \"cwxy\" 2 1 Default \"primariesLimit\" 1 1 Default \"whiteLimit\" 1 1 Default \"primariesReach\" 1 1 Default \"applyGamutCompression\" 1 1 Default \"cuspMidBlend\" 1 1 Default \"focusDistance\" 1 1 Default \"focusAdjustGain\" 1 1 Default \"focusGainBlend\" 1 1 Default \"disableFocusGain\" 1 1 Default \"disableFocusDistScaling\" 1 1 Default \"focusDistScaling\" 1 1 Default \"compressionFuncParams\" 4 1 Default \"sixAxisCompressionMode\" 1 1 Default \"compressionFuncParamsR\" 4 1 Default \"compressionFuncParamsY\" 4 1 Default \"compressionFuncParamsG\" 4 1 Default \"compressionFuncParamsC\" 4 1 Default \"compressionFuncParamsB\" 4 1 Default \"compressionFuncParamsM\" 4 1 Default \"Reachcompressmode\" 1 1 Default \"reachNick\" 1 1 Default \"Locuscompressmode\" 1 1 Default \"boundryIntersectionMethod\" 1 1 Default \"disableUpperHullGamma\" 1 1 Default \"disableLowerHullGamma\" 1 1 Default \"lowerHullGamma\" 1 1 Default \"upperHullGamma\" 1 1 Default \"smoothCusps\" 1 1 Default \"smoothJ\" 1 1 Default \"smoothM\" 1 1 Default \"encodingOut\" 1 1 Default \"primariesOut\" 1 1 Default \"fitWhite\" 1 1 Default \"clampOutput\" 1 1 Default \"softclampOutput\" 1 1 Default \"clamp_thr\" 1 1 Default \"clamp_dist\" 1 1 Default \"invert\" 1 1 Default \"diagnosticMode\" 1 1 Default \"mmScaleFactor\" 1 1 Default \"daniele_n\" 1 1 Default \"daniele_n_r\" 1 1 Default \"daniele_g\" 1 1 Default \"daniele_c\" 1 1 Default \"daniele_c_d\" 1 1 Default \"daniele_w_g\" 1 1 Default \"daniele_t_1\" 1 1 Default \"daniele_r_hit_min\" 1 1 Default \"daniele_r_hit_max\" 1 1 Default \"catDataSelection\" 1 1 Default \"rxy\" 2 1 Default \"gxy\" 2 1 Default \"bxy\" 2 1 Default \"wxy\" 2 1 Default \"ra\" 1 1 Default \"ba\" 1 1 Default \"XYZ_w\" 3 1 Default \"XYZ_w_scaler\" 1 1 Default \"L_A\" 1 1 Default \"Y_b\" 1 1 Default \"L_B\" 3 1 Default \"userSurround\" 3 1 Default \"discount_illuminant\" 1 1 Default \"L_A_out\" 1 1 Default \"Y_b_out\" 1 1 Default 52 \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"CAT_CAT16_INVERSE\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"compr\" Float 1 1 AAAAAA== \"sat\" Float 1 1 AAAAAA== \"sat_thr\" Float 1 1 AAAAAA== \"focusDist\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_reach\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"AP1_to_XYZ\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_AP1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"model_gamma\" Float 1 1 AAAAAA== \"gamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutCuspTableReach\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutCuspTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cgamutReachTable\" Float 3 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"gamutGammas\" Float 2 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"LocusLimitMTable\" Float 1 361 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite>                            dst; // the output image\n\nparam:\n  //\n  // Input Parameters\n  //\n\n  // Encoding of the Input Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingIn;\n\n  // AP1 clamp\n  bool AP1Clamp;\n\n  // Primaries of the Input Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesIn;\n\n  // Tonescale mode\n  // 0: Linear\n  // 1: Daniele Evo Curve\n  int toneScaleMode;\n\n  // Disable Degree of Adaptation\n  // This is only effective if the limit primaries have a non-D65 white point\n  // since the input conversion is assumed to be fully adapted\n  // and the output conversion does not apply a CAT\n  bool discountIlluminant_in;\n  bool discountIlluminant_mid;\n  bool discountIlluminant_out;\n\n  // Toggles for Hellwig 2022 specific params\n  bool HK_mode_in;\n  bool HK_mode_mid;\n  bool HK_mode_out;\n  int  compressMode;\n\n  // Reference Luminance in Cd/sqm\n  float referenceLuminance;\n\n  // Viewing Conditions (for output)\n  // 0: Dark\n  // 1: Dim\n  // 2: Average\n  int viewingConditions;\n  int outputViewingConditions;\n\n  // Toggle Tone Mapping\n  bool applyTonecurve;\n\n  // Target Peak Luminance\n  float peakLuminance;\n\n  // Toggle chroma compression\n  bool applyChromaCompression;\n  bool applyInGamutExpansion;\n  bool applyInGamutCompression;\n  bool applyReachClamp;\n  bool monochrome;\n\n  // Chroma compression params\n  float chroma_compress;\n  float chroma_compress_fact;\n  float chroma_expand;\n  float chroma_expand_fact;\n  float chroma_expand_thr;\n  int   cc_et;\n  int   ccReach;\n  // xy coordinates for chroma compression gamut\n  float2 crxy;\n  float2 cgxy;\n  float2 cbxy;\n  float2 cwxy;\n\n  //\n  // Gamut Mapping Parameters\n  //\n\n  // Primaries of the Target Gamut\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65 # now just Rec.709\n  // 3: Rec.2020-D65 # now just Rec.2020\n  // 4: P3-D65 # now just P3\n  // 5: P3-DCI # no longer included\n  int primariesLimit;\n\n  // White point of the limiting gamut\n  // effectively the \"creative white\"\n  // 0: ACES white\n  // 1: D65\n  // Could add others, or user white point\n  int whiteLimit;\n\n  // Primaries of the Gamut reached by the gamut compressor\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  // 6: Spectral Locus\n  // 7: Chroma Compression Space\n  int primariesReach;\n\n  // Toggle Gamut Compression\n  bool applyGamutCompression;\n\n  // the 1D LUT used for quickly finding the approximate limiting gamut cusp JMh coordinates\n  // the samples are spaced by HSV hue increments of the limiting RGB gamut\n  // so to find the correct entry for a given CAM hue (h) value\n  // one must search the table entries for the matching entry.z component\n  #define gamutCuspTableSize 360*1\n\n  // Blend Between Compressing towards\n  // Target Gamut Cusp Luminance (0.0)\n  // and Mid Luminance (1.0)\n  float cuspMidBlend;\n\n  // Focus distance of the compression focal point from the achromatic axis\n  float focusDistance;\n  float focusAdjustGain;\n  float focusGainBlend;\n  bool  disableFocusGain;\n  bool  disableFocusDistScaling;\n  float focusDistScaling;\n\n  // Gamut Compression Fuction Parameters\n  // Threshold / min Limit / max Limit / Power\n  float4 compressionFuncParams;\n  bool   sixAxisCompressionMode;\n  float4 compressionFuncParamsR;\n  float4 compressionFuncParamsY;\n  float4 compressionFuncParamsG;\n  float4 compressionFuncParamsC;\n  float4 compressionFuncParamsB;\n  float4 compressionFuncParamsM;\n  bool   Reachcompressmode;\n  bool   reachNick;\n  bool   Locuscompressmode;\n\n  int   boundryIntersectionMethod;\n  bool  disableUpperHullGamma;\n  bool  disableLowerHullGamma;\n  float lowerHullGamma;\n  float upperHullGamma;\n\n  // How much the edges of the target RGB cube are smoothed when finding the gamut boundary\n  // in order to reduce visible contours at the gamut cusps\n  float smoothCusps;\n  float smoothJ; // Scaling factor for cusp J\n  float smoothM; // Scaling factor for cusp M\n\n  //\n  // Output Parameters\n  //\n\n  // Encoding of the Output Image\n  // 0: Linear\n  // 1: ACEScct\n  // 2: sRGB\n  // 3: BT.1886 (Gamma 2.4)\n  // 4: Gamma 2.6\n  // 5: ST2084\n  int encodingOut;\n\n  // Primaries of the Output Image\n  // 0: AP0-ACES\n  // 1: AP1-ACES\n  // 2: sRGB/Rec.709-D65\n  // 3: Rec.2020-D65\n  // 4: P3-D65\n  // 5: P3-DCI\n  int primariesOut;\n\n  // Clamp output values to 0.0 - 1.0\n  bool  fitWhite;\n  bool  clampOutput;\n  bool  softclampOutput;\n  float clamp_thr;\n  float clamp_dist;\n\n  //\n  // Extra Parameters\n  //\n\n  // Toggle Inverse Transform\n  bool invert;\n  // Diagnostic path modes\n  int diagnosticMode;\n\n  // DanieleEvoCurve (ACES2 candidate) parameters\n  float mmScaleFactor;\n  float daniele_n;         // peak white\n  float daniele_n_r;       // Normalized white in nits (what 1.0 should be)\n  float daniele_g;         // surround / contrast\n  float daniele_c;         // scene-referred grey\n  float daniele_c_d;       // display-referred grey (in nits)\n  float daniele_w_g;       // grey change between different peak luminance\n  float daniele_t_1;       // shadow toe, flare/glare compensation - how ever you want to call it\n  float daniele_r_hit_min; // Scene-referred value \"hitting the roof\" at 100 nits\n  float daniele_r_hit_max; // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n  // Hellwig 2022 CAM params\n  // the kernel parameters\n\n  // 0 = Stock CAT16\n  // 1 = Thomas's custom primaries\n  // 2 = live from params below\n  int catDataSelection; // original vs modified CAT16 matrix\n  // xy coordinates for custom CAT matrix\n  float2 rxy;\n  float2 gxy;\n  float2 bxy;\n  float2 wxy;\n  float  ra;\n  float  ba;\n\n  // Input vars\n  float3 XYZ_w;\n  float  XYZ_w_scaler;\n  float  L_A;\n  float  Y_b;\n  float3 L_B;\n  float3 userSurround;\n  bool   discount_illuminant;\n  // Output vars\n  float L_A_out;\n  float Y_b_out;\n\nlocal:\n  // Hellwig 2022 constants\n  float3x3 CAT_CAT16;\n  float3x3 CAT_CAT16_INVERSE;\n  float3x3 panlrcm;\n\n  float daniele_r_hit;\n  float daniele_m_0;\n  float daniele_m_1;\n  float daniele_u;\n  float daniele_m;\n  float daniele_w_i;\n  float daniele_c_t;\n  float daniele_g_ip;\n  float daniele_g_ipp2;\n  float daniele_w_2;\n  float daniele_s_2;\n  float daniele_u_2;\n  float daniele_m_2;\n\n  // Chroma compression pre-calculated constants\n  float compr;   // Compression\n  float sat;     // Saturation\n  float sat_thr; // Threshold to start expanding saturation\n\n  // Gamut mapper constants\n  float focusDist; // FocusDistance for projection\n\n  // ST2084 vars\n  float st2084_m_1;\n  float st2084_m_2;\n  float st2084_c_1;\n  float st2084_c_2;\n  float st2084_c_3;\n  float st2084_m_1_d;\n  float st2084_m_2_d;\n  float st2084_L_p;\n\n  // using the float3x3 type to store the array of 6 coefficients\n  // because Blink does not support generic array assignments\n\n  // matrix vars\n  float3x3 identity_matrix;\n\n  float3x3 XYZ_to_RGB_input;\n  float3x3 XYZ_to_RGB_limit;\n  float3x3 XYZ_to_RGB_reach;\n  float3x3 XYZ_to_RGB_output;\n\n  float3x3 RGB_to_XYZ_input;\n  float3x3 RGB_to_XYZ_limit;\n  float3x3 RGB_to_XYZ_reach;\n  float3x3 RGB_to_XYZ_output;\n\n  float3x3 AP1_to_XYZ;\n  float3x3 XYZ_to_AP1;\n\n  // white points\n  float3 inWhite;\n  float3 outWhite;\n  float3 limitWhite;\n\n  // the maximum RGB value of the limiting gamut\n  float boundaryRGB;\n\n  // the maximum lightness value of the limiting gamut\n  float limitJmax;\n\n  // Middle gray J\n  float midJ;\n\n  // Hellwig model's gamma (1 / cz)\n  float model_gamma;\n\n  // the 'tempTableUnsorted' table is populated\n  // in increments of H of the limiting gamut HSV space starting at H=0.0\n  // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n  // the entries are then wrap-around shifted\n  // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n  // both tables need to be declared here since temporary array variables\n  // in the init() fuction seem to crash Nuke on some systems\n  float3 gamutCuspTable\[gamutCuspTableSize + 1];\n  float3 gamutCuspTableReach\[gamutCuspTableSize + 1];\n  float3 cgamutCuspTable\[gamutCuspTableSize + 1];\n  float3 cgamutReachTable\[gamutCuspTableSize + 1];\n  float2 gamutGammas\[gamutCuspTableSize + 1];\n  float  LocusLimitMTable\[gamutCuspTableSize + 1];\n\n  void define()\n  \{\n    defineParam(chroma_compress_fact, \"Chroma Compress Factor\", 5.0f);\n    defineParam(chroma_expand_fact, \"Chroma Expansion Factor\", 0.78f);\n    defineParam(smoothJ, \"Smoothing factor cusp J\", 0.055f);\n    defineParam(smoothM, \"Smoothing factor cust M\", 0.183f);\n  \}\n\n  // Functions used in ACES 2.0 candidate CAM DRT\n\n  // multiplies a 3D vector with a 3x3 matrix\n  inline float3 vector_dot(const float3x3& m, const float3 v)\n  \{\n    float3 r;\n    for (int c = 0; c < 3; c++)\n    \{\n      r\[c] = m\[c]\[0] * v.x + m\[c]\[1] * v.y + m\[c]\[2] * v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  inline float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float2 lerp(float2 a, float2 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float3 lerp(float3 a, float3 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n  inline float4 lerp(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  inline float spow(float base, float exponent)\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ;\n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b)\n\n    // float a_p = sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else\n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if (base < 0.0f && exponent != floor(exponent))\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n      return pow(base, exponent);\n    \}\n  \}\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n  float3 float3spow(float3 base, float exponent)\n  \{\n    return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  inline float3 float3pow(float3 base, float exponent)\n  \{\n    return float3(pow(base.x, exponent), pow(base.y, exponent), pow(base.z, exponent));\n  \}\n\n  // \"safe\" div\n  float sdiv(float a, float b)\n  \{\n    if (b == 0.0f)\n    \{\n      return 0.0f;\n    \}\n    return a / b;\n  \}\n\n  float degree_of_adaptation(float F, float L_A)\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  inline float degrees(float radians)\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n  // convert degrees to radians\n  inline float radians(float degrees)\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'threshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP(float v, float threshold, float limit, float power, int inverse)\n  \{\n    float s = (limit - threshold) / pow(pow((1.0f - threshold) / (limit - threshold), -power) - 1.0f, 1.0f / power);\n\n    float vCompressed;\n\n    if (inverse)\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f || v > threshold + s)\n        ? v\n        : threshold + s * pow(-(pow((v - threshold) / s, power) / (pow((v - threshold) / s, power) - 1.0f)), 1.0f / power);\n    \}\n    else\n    \{\n      vCompressed = (v < threshold || limit < 1.0001f)\n        ? v\n        : threshold + s * ((v - threshold) / s) / (pow(1.0f + pow((v - threshold) / s, power), 1.0f / power));\n    \}\n\n    return vCompressed;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float  ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d   = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  // basic 3D hypotenuse function, does not deal with under/overflow\n  inline float hypot_float3(float3 xyz)\n  \{\n    return length(xyz);\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float r = R / C;\n    r       = r * r;\n    r       = sqrt(4.0f / r + 1.0f) - 1.0f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float t = 0.5f + sqrt(s * s + r * r / 4.0f);\n    t       = C / t; // t is always >= 0.5f\n\n    xyz_temp = xyz_temp * t + C;\n\n    return xyz_temp;\n  \}\n\n  float3 uncompress_bjorn(float3 xyz)\n  \{\n    float C = (xyz.x + xyz.y + xyz.z) / 3;\n\n    float3 xyz_temp = xyz - C;\n    float  R        = hypot_float3(xyz_temp);\n\n    if (R == 0.0f || C == 0.0f)\n      return xyz;\n\n    R = R * 0.816496580927726; // sqrt(2/3)\n\n    xyz_temp = xyz_temp / R;\n\n    float t = C / R;\n    t       = t - 0.5f;\n\n    float s = -min(xyz_temp.x, min(xyz_temp.y, xyz_temp.z));\n    s       = s - 0.5f;\n\n    float r = 2 * sqrt(fabs(t * t - s * s)) + 1;\n    r       = sqrt(fabs(r * r - 1));\n    if (r == 0.0)\n      return xyz;\n    r = C * 2 / r;\n\n    xyz_temp = xyz_temp * r + C;\n\n    return xyz_temp;\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float hr)\n  \{\n    return -0.160 * cos(hr) + 0.132 * cos(2 * hr) - 0.405 * sin(hr) + 0.080 * sin(2 * hr) + 0.792;\n  \}\n\n  float3x3 RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy, float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) +       \\\n            b.x * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n\n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n      Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n      Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n      Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear(float v)\n  \{\n    return v > 0.155251141552511f ? spow(2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct(float v)\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear(float v)\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB(float v)\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n    const float3 F_L_RGB = float3pow(F_L / 100.0f * fabs(RGB), 0.42f);\n    const float3 RGB_c   = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n    return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB, float F_L)\n  \{\n    const float3 absRGB = fabs(RGB);\n    const float3 RGB_p  = sign(RGB) * 100.0f / F_L * float3pow((27.13f * absRGB) / (400.0f - absRGB), 1.0f / 0.42f);\n    return RGB_p;\n  \}\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB(float3 HSV)\n  \{\n    float C = HSV.z * HSV.y;\n    float X = C * (1.0f - fabs(fmod(HSV.x * 6.0f, 2.0f) - 1.0f));\n    float m = HSV.z - C;\n\n    float3 RGB;\n    RGB.x = (HSV.x < 1.0f / 6.0f     ? C\n               : HSV.x < 2.0f / 6.0f ? X\n               : HSV.x < 3.0f / 6.0f ? 0.0f\n               : HSV.x < 4.0f / 6.0f ? 0.0f\n               : HSV.x < 5.0f / 6.0f ? X\n                                     : C)\n      + m;\n    RGB.y = (HSV.x < 1.0f / 6.0f     ? X\n               : HSV.x < 2.0f / 6.0f ? C\n               : HSV.x < 3.0f / 6.0f ? C\n               : HSV.x < 4.0f / 6.0f ? X\n               : HSV.x < 5.0f / 6.0f ? 0.0f\n                                     : 0.0f)\n      + m;\n    RGB.z = (HSV.x < 1.0f / 6.0f     ? 0.0f\n               : HSV.x < 2.0f / 6.0f ? 0.0f\n               : HSV.x < 3.0f / 6.0f ? X\n               : HSV.x < 4.0f / 6.0f ? C\n               : HSV.x < 5.0f / 6.0f ? C\n                                     : X)\n      + m;\n    return RGB;\n  \}\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV(float3 RGB)\n  \{\n    float cmax  = max(RGB.x, max(RGB.y, RGB.z));\n    float cmin  = min(RGB.x, min(RGB.y, RGB.z));\n    float delta = cmax - cmin;\n\n    float3 HSV;\n    HSV.x = delta == 0.0f ? 0.0f\n      : cmax == RGB.x     ? (fmod((RGB.y - RGB.z) / delta + 6.0f, 6.0f)) / 6.0f\n      : cmax == RGB.y     ? (((RGB.z - RGB.x) / delta + 2.0f) / 6.0f)\n                          : (((RGB.x - RGB.y) / delta + 4.0f) / 6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float solve_J_intersect(float2 JM, float focusJ, float maxJ, float slope_gain)\n  \{\n    float a          = JM.y / (focusJ * slope_gain);\n    float b          = 0.0f;\n    float c          = 0.0f;\n    float intersectJ = 0.0f;\n\n    if (JM.x < focusJ)\n    \{\n      b = 1.0f - JM.y / slope_gain;\n      c = -JM.x;\n    \}\n    else\n    \{\n      b = -(1.0f + JM.y / slope_gain + maxJ * JM.y / (focusJ * slope_gain));\n      c = maxJ * JM.y / slope_gain + JM.x;\n    \}\n\n    float root = sqrt(b * b - 4.0f * a * c);\n\n    if (JM.x < focusJ)\n    \{\n      intersectJ = 2.0f * c / (-b - root);\n    \}\n    else\n    \{\n      intersectJ = 2.0f * c / (-b + root);\n    \}\n\n    return intersectJ;\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n    float3 newSurround;\n    // hack to turn incoming int value into surround coeffs\n    if (viewingConditions == 0)\n    \{\n      // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n      newSurround = float3(0.8, 0.525, 0.8);\n    \}\n    else if (viewingConditions == 1)\n    \{\n      // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n      newSurround = float3(0.9, 0.59, 0.9);\n    \}\n    else if (viewingConditions == 2)\n    \{\n      // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n      newSurround = float3(1.0, 0.69, 1.0);\n    \}\n    else if (viewingConditions == 3)\n    \{\n      // Pull from external input\n      newSurround = userSurround;\n    \}\n    return newSurround;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 XYZ_to_JMh(float3 XYZ, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and the viewing conditions as parameters\n  inline float3 JMh_to_XYZ(float3 JMh, float3 referenceWhite, int viewingConditions, float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant, HK_mode);\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear(float v)\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d) * st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084(float v)\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if (encoding == 1)\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if (encoding == 2)\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if (encoding == 3)\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f / 2.4f);\n    \}\n    else if (encoding == 4)\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f / 2.6f);\n    \}\n    else if (encoding == 5)\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ          = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh          = XYZ_to_JMh(XYZ, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n\n    // switch to treat incoming data as luminanceXYZ when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      luminanceXYZ = JMh;\n    \}\n\n    // First matrix to limiting gamut for clamping\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_limit, luminanceXYZ);\n\n    if (fitWhite)\n    \{\n      // Scale to fit maximum creative white channel value\n      float3 creativeWhiteXYZ = vector_dot(RGB_to_XYZ_limit, float3(1.0f, 1.0f, 1.0f)); // TODO: these scaling parameters could be precalculated\n      float3 creativeWhiteRGB = vector_dot(XYZ_to_RGB_output, creativeWhiteXYZ);\n      luminanceRGB *= 1.0f / max(creativeWhiteRGB.x, max(creativeWhiteRGB.y, creativeWhiteRGB.z));\n    \}\n\n    if (softclampOutput)\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    if (clampOutput)\n    \{\n      // Clamp to between zero and peak luminance\n      luminanceRGB = clamp3(luminanceRGB, 0.0f, peakLuminance);\n    \}\n\n    // Matrix to output (encoding) gamut (eventually concatenate to a single matrix)\n    luminanceRGB = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceRGB);\n\n    // return luminanceRGB when in breakout mode\n    if (diagnosticMode == 105)\n    \{\n      return luminanceRGB;\n    \}\n\n    float3 outputRGB = luminanceToEncoding3(encodingOut, luminanceRGB);\n\n    return outputRGB;\n  \}\n\n  // convert linear RGB values with the given primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 RGB_to_JMh(const float3 RGB, float3 refWhite, const float3x3& matrix)\n  \{\n    const float3 luminanceRGB = RGB * boundaryRGB * referenceLuminance;\n    const float3 XYZ          = vector_dot(matrix, luminanceRGB);\n    const float3 JMh          = XYZ_to_JMh(XYZ, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the given primaries\n  float3 JMh_to_RGB(float3 JMh, float3 refWhite, const float3x3& matrix)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, refWhite, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    float3 luminanceRGB = vector_dot(matrix, luminanceXYZ);\n    float3 RGB          = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh(float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    XYZ_w = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n\n    float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n    // # Step 1\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB = vector_dot(CAT_CAT16, XYZ);\n\n    // # Step 2\n    float3 RGB_c = D_RGB * RGB;\n\n    // # Step 3\n    // # Applying forward post-adaptation non-linear response compression.\n\n    if (compressMode)\n    \{\n      RGB_c = compress_bjorn(RGB_c);\n    \}\n\n    float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n    if (compressMode)\n    \{\n      RGB_a = uncompress_bjorn(RGB_a);\n    \}\n\n    // # Step 4\n    // # Converting to preliminary cartesian coordinates.\n    float R_a = RGB_a.x;\n    float G_a = RGB_a.y;\n    float B_a = RGB_a.z;\n    float a   = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n    float b   = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n    // # Computing the *hue* angle :math:`h`.\n    float hr = atan2(b, a);\n    float h  = wrap_to_360(degrees(hr));\n\n    // # Step 6\n    // # Computing achromatic responses for the stimulus.\n    float R_a2 = RGB_a.x;\n    float G_a2 = RGB_a.y;\n    float B_a2 = RGB_a.z;\n\n    float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n    // # Step 7\n    // # Computing the correlate of *Lightness* :math:`J`.\n    float J = 100.0f * pow(A / A_w, surround.y * z);\n\n    // # Step 8\n    // # Computing the correlate of *brightness* :math:`Q`.\n    // float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n    // # Step 9\n    // # Computing the correlate of *colourfulness* :math:`M`.\n    float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n    // # Computing the correlate of *chroma* :math:`C`.\n    float C = 35.0f * M / A_w;\n\n    // # Computing the correlate of *saturation* :math:`s`.\n    // float s = 100.0f * sdiv(M, Q);\n  \n    if (HK_mode)\n    \{\n      // # *Helmholtz–Kohlrausch* Effect Extension.\n      J = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n      // float Q_HK = (2.0f / surround.y) * (J / 100.0f) * A_w;\n    \}\n    \n    if (J == 0.0f)\n      M = 0.0f;\n    return \{J, M, h\};\n  \}\n\n  float3 Hellwig2022_JMh_to_XYZ(float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n  \{\n    float J = JMh.x;\n    float M = JMh.y;\n    float h = JMh.z;\n    XYZ_w   = XYZ_w * XYZ_w_scaler;\n\n    // # Step 0\n    // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n    float3 RGB_w = vector_dot(CAT_CAT16, XYZ_w);\n\n    // # Computing degree of adaptation :math:`D`.\n    float D = 1.0f;\n    if (!discountIlluminant)\n    \{\n      D = clamp(degree_of_adaptation(surround.x, L_A), 0, 1);\n    \}\n\n    // # Viewing conditions dependent parameters\n    float k   = 1 / (5 * L_A + 1);\n    float k4  = pow(k, 4);\n    float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f);\n    float n   = Y_b / XYZ_w.y;\n    float z   = 1.48 + sqrt(n);\n\n    float3 D_RGB  = D * XYZ_w.y / RGB_w + 1 - D;\n    float3 RGB_wc = D_RGB * RGB_w;\n    float3 RGB_aw = post_adaptation_non_linear_response_compression_forward(RGB_wc, F_L);\n\n    // # Computing achromatic responses for the whitepoint.\n    float R_aw = RGB_aw.x;\n    float G_aw = RGB_aw.y;\n    float B_aw = RGB_aw.z;\n    float A_w  = ra * R_aw + G_aw + ba * B_aw;\n\n    float hr = radians(h);\n\n    // # *Helmholtz–Kohlrausch* Effect Extension.\n    float C = (M * 35) / A_w;\n    if (HK_mode)\n    \{\n      J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n    \}\n\n    // # Computing achromatic response :math:`A` for the stimulus.\n    float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n    // # Computing *P_p_1* to *P_p_2*.\n    float P_p_1 = 43.0f * surround.z;\n    float P_p_2 = A;\n\n    // # Step 3\n    // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n    float gamma = M / P_p_1;\n    float a     = gamma * cos(hr);\n    float b     = gamma * sin(hr);\n\n    // # Step 4\n    // # Applying post-adaptation non-linear response compression matrix.\n    float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n    // # Step 5\n    // # Applying inverse post-adaptation non-linear response compression.\n    if (compressMode)\n    \{\n      RGB_a = compress_bjorn(RGB_a);\n    \}\n\n    float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n    if (compressMode)\n    \{\n      RGB_c = uncompress_bjorn(RGB_c);\n    \}\n\n    // # Step 6\n    float3 RGB = RGB_c / D_RGB;\n\n    // # Step 7\n    float3 XYZ = vector_dot(CAT_CAT16_INVERSE, RGB);\n\n    return XYZ;\n  \}\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n\n  inline int midpoint(int low, int high)\n  \{\n    return int((high + low) / 2); // Integer division\n  \}\n\n  int find_upper_hue_in_table(float h, float3 table\[], int table_size)\n  \{\n    int low_i  = 0;\n    int high_i = table_size - 1;\n    int i      = hue_position_in_uniform_table(h, table_size);\n\n    while (low_i + 1 < high_i)\n    \{\n      if (h > table\[i].z)\n      \{\n        low_i = i;\n      \}\n      else\n      \{\n        high_i = i;\n      \}\n      i = midpoint(low_i, high_i);\n    \}\n    return high_i;\n  \}\n\n  float2 cuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n    if (h <= gamutCuspTable\[0].z)\n    \{\n      lo   = gamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = gamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > gamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = gamutCuspTable\[high_i - 1];\n      hi = gamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 cuspFromTableLocus(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float lo = LocusLimitMTable\[i_lo];\n    const float hi = LocusLimitMTable\[i_lo + 1];\n\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    const float cuspJ = 69;\n    const float cuspM = lerp(lo, hi, t);\n    return float2(cuspJ, cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n    float3 lo;\n    float3 hi;\n\n    if (h <= cgamutCuspTable\[0].z)\n    \{\n      lo   = cgamutCuspTable\[gamutCuspTableSize - 1];\n      lo.z = lo.z - 360.0f;\n      hi   = cgamutCuspTable\[0];\n    \}\n    else\n    \{\n      int low_i  = 0;\n      int high_i = gamutCuspTableSize;\n      int i      = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n      while (low_i + 1 < high_i)\n      \{\n        if (h > cgamutCuspTable\[i].z)\n        \{\n          low_i = i;\n        \}\n        else\n        \{\n          high_i = i;\n        \}\n        i = midpoint(low_i, high_i);\n      \}\n      lo = cgamutCuspTable\[high_i - 1];\n      hi = cgamutCuspTable\[high_i];\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ, cuspM);\n  \}\n\n  inline float wrap_to_360(float hue)\n  \{\n    float y = fmod(hue, 360.0f);\n    if (y < 0.0)\n    \{\n      y = y + 360.0f;\n    \}\n    return y;\n  \}\n\n  inline int hue_position_in_uniform_table(float wrapped_hue, int table_size)\n  \{\n    return int(wrapped_hue / 360.0f * table_size);\n  \}\n\n  inline float base_hue_for_position(int i_lo, int table_size)\n  \{\n    return float(i_lo) * 360.0f / float(table_size);\n  \}\n\n  float cReachFromTable(float h)\n  \{\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = cgamutReachTable\[i_lo];\n    const float3 hi = cgamutReachTable\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n    return lerp(lo.y, hi.y, t);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y       = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n    return f;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float  hr     = radians(h);\n\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + hr) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float _h   = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n             + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n    return JMcusp.y * e_t;\n  \}\n\n  // A \"toe\" function that remaps the given value x between 0 and limit.\n  // The k1 and k2 parameters change the size and shape of the toe.\n  // https://www.desmos.com/calculator/6vplvw14ti\n  float toe(float x, float limit, float k1, float k2, int inverse)\n  \{\n    if (x > limit)\n      return x;\n\n    k2       = max(k2, 0.001f);\n    k1       = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!inverse)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // Chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white, and from\n  // achromatic outward to purer colors.\n  //\n  float chromaCompression(float3 JMh, float origJ, float linear, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ    = JMh.x / limitJmax;\n    float snJ   = max(0.0f, 1.0f - nJ);\n    float Mnorm = cusp_with_eccentricity_factor(JMh.z);\n    float limit = pow(nJ, model_gamma) * cReachFromTable(JMh.z) / Mnorm;\n\n    if (!invert)\n    \{\n      // Rescaling of M with the tonescaled J to get the M to the same range as\n      // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to\n      // keep the M/J ratio correct (keeping the chromaticities constant).\n      M *= pow(JMh.x / origJ, model_gamma);\n\n      if (applyInGamutCompression)\n      \{\n        // Normalize M with the rendering space cusp M\n        M /= Mnorm;\n\n        // Expand the colorfulness by running the toe function in reverse.  The goal is to\n        // expand less saturated colors less and more saturated colors more.  The expansion\n        // increases saturation in the shadows and mid-tones but not in the highlights.\n        // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes\n        // the toe less aggressive near black to reduce the expansion of noise.\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 0);\n\n        // Compress the colorfulness.  The goal is to compress less saturated colors more and\n        // more saturated colors less, especially in the highlights.  This step creates the\n        // saturation roll-off in the highlights, but attemps to preserve pure colors.  This\n        // mostly affects highlights and mid-tones, and does not compress shadows.\n        M = toe(M, limit, nJ * compr, snJ, 0);\n\n        // Clamp M to the rendering space\n        if (applyReachClamp)\n          M = min(limit, M);\n\n        // Denormalize\n        M *= Mnorm;\n      \}\n    \}\n    else\n    \{\n      if (applyInGamutCompression)\n      \{\n        M /= Mnorm;\n        M = toe(M, limit, nJ * compr, snJ, 1);\n        if (applyInGamutExpansion)\n          M = limit - toe(limit - M, limit - 0.001f, snJ * sat, sqrt(nJ * nJ + sat_thr), 1);\n        M *= Mnorm;\n      \}\n\n      M *= pow(JMh.x / origJ, -model_gamma);\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3(encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n\n    if (AP1Clamp)\n    \{\n      luminanceRGB   = vector_dot(XYZ_to_AP1, luminanceXYZ);\n      luminanceRGB.x = max(0.0f, luminanceRGB.x);\n      luminanceRGB.y = max(0.0f, luminanceRGB.y);\n      luminanceRGB.z = max(0.0f, luminanceRGB.z);\n      luminanceXYZ   = vector_dot(AP1_to_XYZ, luminanceRGB);\n    \}\n\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6 || diagnosticMode == 100)\n    \{\n      return luminanceXYZ;\n    \}\n    else\n    \{\n      return JMh;\n    \}\n  \}\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ(JMh, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB     = luminanceToEncoding3(encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\nfloat Y_to_Hellwig_J(float Y, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float F_L_Y = pow(F_L * fabs(Y) / 100.0f, 0.42f);\n\n    return sign(Y) * 100.0f * pow(((400.0f * F_L_Y) / (27.13f + F_L_Y)) / A_w, surround.y * z);\n  \}\n\n  float Hellwig_J_to_Y(float J, float3 surround)\n  \{\n    // Viewing conditions dependent parameters (could be pre-calculated)\n    float k     = 1.0f / (5.0f * L_A + 1.0f);\n    float k4    = k*k*k*k;\n    float F_L   = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * pow(5.0f * L_A, 1.0f / 3.0f) ;\n    float n     = Y_b / XYZ_w_scaler;\n    float z     = 1.48f + sqrt(n);\n    float F_L_W = pow(F_L, 0.42f);\n    float A_w   = (400.0f * F_L_W) / (27.13f + F_L_W);\n\n    float A = A_w * pow(fabs(J) / 100.0f, 1.0f / (surround.y * z));\n\n    return sign(J) * 100.0f / F_L * pow((27.13f * A) / (400.0f - A), 1.0f / 0.42f);\n  \}\n\n  float3 forwardTonescale(float3 inputJMh)\n  \{\n    float3 outputJMh;\n    float3 surround    = viewingConditionsToSurround(viewingConditions);\n    float  linear      = Hellwig_J_to_Y(inputJMh.x, surround) / referenceLuminance;\n    float  luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if (toneScaleMode == 1)\n    \{\n      luminanceTS = daniele_evo_fwd(luminanceTS) * mmScaleFactor;\n    \}\n\n    float  tonemappedJ   = Y_to_Hellwig_J(luminanceTS, surround);\n    float3 tonemappedJMh = float3(tonemappedJ, inputJMh.y, inputJMh.z);\n\n    if (applyTonecurve)\n    \{\n      outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n      outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(tonemappedJMh, inputJMh.x, linear, 0);\n    \}\n\n    if (monochrome)\n    \{\n      outputJMh.y = 0.0f;\n    \}\n\n    return outputJMh;\n  \}\n\n  float3 inverseTonescale(float3 JMh)\n  \{\n    float3 tonemappedJMh = JMh;\n    float3 surround = viewingConditionsToSurround(viewingConditions);\n\n    if (!applyTonecurve && !applyChromaCompression)\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n\n    float luminance = Hellwig_J_to_Y(tonemappedJMh.x, surround);\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if (toneScaleMode == 1)\n    \{\n      linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n      linear = luminance;\n    \}\n\n    linear = linear * referenceLuminance;\n\n    if (applyTonecurve)\n    \{\n      float untonemappedJ = Y_to_Hellwig_J(linear, surround);\n      untonemappedColourJMh = float3(untonemappedJ, tonemappedJMh.y, tonemappedJMh.z);\n    \}\n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, linear, 1);\n    \}\n\n    return untonemappedColourJMh;\n  \}\n\n  float2 hueDependantHullGammas(float h)\n  \{\n    const int   i_lo     = hue_position_in_uniform_table(h, gamutCuspTableSize);\n    const float base_hue = base_hue_for_position(i_lo, gamutCuspTableSize);\n    const float t        = h - base_hue;\n\n    return lerp(gamutGammas\[i_lo], gamutGammas\[i_lo + 1], t);\n  \}\n\n  // reimplemented from https://github.com/nick-shaw/aces-ot-vwg-experiments/blob/master/python/intersection_approx.py\n  float3 findGamutBoundaryIntersection(float3 JMh_s, float2 JM_cusp, float J_focus, float J_max, float slope_gain, float smoothness,\n                                       float gamma_top, float gamma_bottom)\n  \{\n    float2 JM_source = float2(JMh_s.x, JMh_s.y);\n\n    float slope = 0.0f;\n\n    float s = max(0.000001f, smoothness);\n    JM_cusp.x *= 1.0f + smoothJ * s; // J\n    JM_cusp.y *= 1.0f + smoothM * s; // M\n\n    float J_intersect_source = solve_J_intersect(JM_source, J_focus, J_max, slope_gain);\n    float J_intersect_cusp   = solve_J_intersect(JM_cusp, J_focus, J_max, slope_gain);\n\n    if (J_intersect_source < J_focus)\n    \{\n      slope = J_intersect_source * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n    else\n    \{\n      slope = (J_max - J_intersect_source) * (J_intersect_source - J_focus) / (J_focus * slope_gain);\n    \}\n\n    float M_boundary_lower = J_intersect_cusp * pow(J_intersect_source / J_intersect_cusp, 1 / gamma_bottom) / (JM_cusp.x / JM_cusp.y - slope);\n\n    float M_boundary_upper = JM_cusp.y * (J_max - J_intersect_cusp)\n      * pow((J_max - J_intersect_source) / (J_max - J_intersect_cusp), 1.0f / gamma_top) / (slope * JM_cusp.y + J_max - JM_cusp.x);\n\n    float M_boundary = JM_cusp.y * smin(M_boundary_lower / JM_cusp.y, M_boundary_upper / JM_cusp.y, s);\n\n    float J_boundary = J_intersect_source + slope * M_boundary;\n\n    return float3(J_boundary, M_boundary, J_intersect_source);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'.\n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.05f, cusp.x / limitJmax), 0.0001f);\n    cusp.y *= 1.0f + 0.18f * s;\n    cusp.x *= 1.0f + 0.07f * s;\n\n    // Line below the cusp is curved with model_gamma\n    float toJ_gamma   = cusp.x * spow(to.x / cusp.x, model_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, model_gamma);\n    t0                = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n  float2 findCurveIntersection(float c, float2 cusp, float m, float h)\n  \{\n    // based on this desmos plot https://www.desmos.com/calculator/pcsovzirqa\n    float xc = cusp.y;\n    float yc = cusp.x;\n    float f  = 1.0;\n    float mf = m * f;\n    float xi = 1.0f;\n    float g1 = 1.0f / model_gamma;\n    float g2 = hueDependantHullGammas(h).y;\n\n    if (m * xc + c < yc)\n    \{\n      // below cusp\n      xi = spow((1 - mf), (g1 - 1)) * ((yc * spow((c / yc), (1.0 / g1))) / (yc / xc - m));\n    \}\n    else\n    \{\n      // above cusp\n      xi =\n        spow((1 + mf), ((g2 - 1))) * (xc * (limitJmax - yc) * spow(((limitJmax - c) / (limitJmax - yc)), (1 / g2)) / (m * xc + limitJmax - yc));\n    \}\n    float yi = (m * xi) + c;\n    if (yi > limitJmax)\n    \{\n      yi = limitJmax;\n      xi = 0.0f;\n    \}\n    return float2(yi, xi);\n  \}\n\n  float3 getLocusBoundry(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float2 cuspLocus     = cuspFromTableLocus(h);\n    float  cuspTarget100 = cuspLocus.y;\n    float  cuspTarget    = cuspTarget100 * pow((Jmh.x / 100.0f), model_gamma);\n    float  difference    = cuspLocus.y / cuspTarget;\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float3 getReachBoundry(float3 Jmh)\n  \{\n    const float h = Jmh.z;\n\n    const int i_lo = hue_position_in_uniform_table(h, gamutCuspTableSize);\n\n    const float3 lo = gamutCuspTableReach\[i_lo];\n    const float3 hi = gamutCuspTableReach\[i_lo + 1];\n\n    const float t = (h - lo.z) / (hi.z - lo.z);\n\n    const float reachMaxM = lerp(lo.y, hi.y, t);\n    if (reachNick)\n    \{\n      float2 JMcusp     = cuspFromTable(Jmh.z);\n      float  focusJ     = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain = limitJmax * focusDist * getFocusGain(Jmh.x, JMcusp.x);\n      float  intersectJ = solve_J_intersect(float2(Jmh.x, Jmh.y), focusJ, limitJmax, slope_gain);\n      float  slope;\n      if (intersectJ < focusJ)\n      \{\n        slope = intersectJ * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      else\n      \{\n        slope = (limitJmax - intersectJ) * (intersectJ - focusJ) / (focusJ * slope_gain);\n      \}\n      float boundaryNick = limitJmax * pow(intersectJ / limitJmax, model_gamma) * reachMaxM / (limitJmax - slope * reachMaxM);\n      return float3(Jmh.x, boundaryNick, Jmh.z);\n    \}\n    float cuspTarget = reachMaxM * pow((Jmh.x / limitJmax), model_gamma);\n    return float3(Jmh.x, cuspTarget, Jmh.z);\n  \}\n\n  float4 getCompressionFuncParams(float3 Jmh)\n  \{\n    float h = Jmh.z;\n\n    float angleR = 20.0f;\n    float angleY = 102.0f;\n    float angleG = 146.0f;\n    float angleC = 193.0f;\n    float angleB = 259.0f;\n    float angleM = 342.0f;\n\n    float lerpVal = 0.0f;\n\n    if (Reachcompressmode)\n    \{\n      if (primariesReach != 6) // All of the primary based reach values\n      \{\n        // use primary based reach\n        float locusMax   = getReachBoundry(Jmh).y;\n        float difference = max(1.0001f, locusMax / Jmh.y);\n        float threshold  = max(compressionFuncParams.x, 1.0f / difference);\n        return float4(threshold, difference, difference, compressionFuncParams.w);\n      \}\n      else\n      \{\n        // use locus based reach\n        float locusMax   = getLocusBoundry(Jmh).y;\n        float difference = locusMax / Jmh.y;\n        return float4(compressionFuncParams.x, difference, difference, compressionFuncParams.w);\n      \}\n    \}\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h >= angleR && h < angleY)\n      \{\n        lerpVal = (h - angleR) / (angleY - angleR);\n        return lerp(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h >= angleY && h < angleG)\n      \{\n        lerpVal = (h - angleY) / (angleG - angleY);\n        return lerp(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h >= angleG && h < angleC)\n      \{\n        lerpVal = (h - angleG) / (angleC - angleG);\n        return lerp(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h >= angleC && h < angleB)\n      \{\n        lerpVal = (h - angleC) / (angleB - angleC);\n        return lerp(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h >= angleB && h < angleM)\n      \{\n        lerpVal = (h - angleB) / (angleM - angleB);\n        return lerp(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h >= angleM && h < angleR + 360.0f)\n      \{\n        lerpVal = (h - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h < angleR)\n      \{\n        lerpVal = (h + 360.0f - angleM) / (angleR + 360.0f - angleM);\n        return lerp(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n  \}\n\n  // https://www.desmos.com/calculator/oe2fscya80\n  float getFocusGain(float J, float cuspJ)\n  \{\n    if (disableFocusGain)\n      return 1.0f;\n\n    float thr = lerp(cuspJ, limitJmax, focusGainBlend);\n    if (J > thr)\n    \{\n      // Approximate inverse required above threshold\n      float gain = (limitJmax - thr) / max(0.0001f, (limitJmax - min(limitJmax, J)));\n      return pow(log10(gain), 1.0f / focusAdjustGain) + 1.0f;\n    \}\n    else\n    \{\n      // Analytic inverse possible below cusp\n      return 1.0f;\n    \}\n  \}\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    if (disableFocusGain)\n      return compressGamut2(JMh, invert, JMh.x);\n\n    if (!invert)\n    \{\n      return compressGamut2(JMh, 0, JMh.x);\n    \}\n    else\n    \{\n      float2 JMcusp = cuspFromTable(JMh.z);\n      float  Jx     = JMh.x;\n\n      // Analytic inverse below threshold\n      if (Jx <= lerp(JMcusp.x, limitJmax, focusGainBlend))\n        return compressGamut2(JMh, 1, Jx);\n\n      // Approximation above\n      Jx = compressGamut2(JMh, 1, Jx).x;\n      return compressGamut2(JMh, 1, Jx);\n    \}\n  \}\n\n  float3 compressGamut2(float3 JMh, int invert, float Jx)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp       = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDist * JMcusp.y);\n    float a      = max(0.001f, Mratio / focusJ);\n    float b0     = 1.0f - Mratio;\n    float b1     = -(1.0f + Mratio + (a * limitJmax));\n    float b      = project_from.x < focusJ ? b0 : b1;\n    float c0     = -project_from.x;\n    float c1     = project_from.x + limitJmax * Mratio;\n    float c      = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0       = sqrt(b * b - 4 * a * c);\n    float J1       = (-b - J0) / (2 * a);\n    J0             = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    float slope_gain = limitJmax * focusDist * getFocusGain(Jx, JMcusp.x);\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = float2(1.0f, 1.0f);\n    if (boundryIntersectionMethod == 0)\n    \{\n      // Original method implemented by Pekka\n      JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n    \}\n    else if (boundryIntersectionMethod == 1)\n    \{\n      // Alternate method shown in Oct 19 meeting\n      float m    = (JMh.x - projectJ) / JMh.y;\n      JMboundary = findCurveIntersection(JMh.x, JMcusp, 0.0f, JMh.z);\n    \}\n    else if (boundryIntersectionMethod == 2)\n    \{\n      const float2 gammas      = hueDependantHullGammas(JMh.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(JMh, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      JMboundary               = float2(nickBoundryReturn.x, nickBoundryReturn.y);\n      project_to               = float2(nickBoundryReturn.z, 0.0f);\n      projectJ                 = nickBoundryReturn.z;\n    \}\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams;\n    if (reachNick)\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMboundary.x, JMboundary.y, JMh.z));\n    \}\n    else\n    \{\n      interpolatedCompressionFuncParams = getCompressionFuncParams(float3(JMh.x, JMboundary.y, JMh.z));\n    \}\n\n    if (!Reachcompressmode)\n      interpolatedCompressionFuncParams.x =\n        1.0f / lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n\n    float lowerMlimit = 0.0001f; // Testing a small value here\n    if (JMh.x < limitJmax\n        && JMh.y > lowerMlimit)  // using a small value to test against here rather than 0.0, and I was getting Nans on inversion.\n    \{\n      float v      = project_from.y / JMboundary.y;\n      v            = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                                    lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                                    interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n    else\n    \{\n      JMcompressed = float2(JMh.x, 0.0f);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 18)\n    \{\n      return float3(JMh.x, JMboundary.y, JMh.z);\n    \}\n    if (diagnosticMode == 20)\n    \{\n      // return focus point\n      return float3(project_to.x, project_to.y, JMh.z);\n    \}\n    // actual output\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n                            ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  float3x3 generate_RGB_to_XYZ_matrix(const int which)\n  \{\n    if (which == 0)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.7347f, 0.2653), float2(0.0f, 1.0f), float2(0.0001, -0.077), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 1)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.713f, 0.293f), float2(0.165f, 0.830f), float2(0.128f, 0.044f), float2(0.32168f, 0.33767f), 1.0f, 0);\n    \}\n    else if (which == 2)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.64f, 0.33f), float2(0.3f, 0.6f), float2(0.15f, 0.06f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 3)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.708f, 0.292f), float2(0.170f, 0.797f), float2(0.131f, 0.046f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 4)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.3127f, 0.3290f), 1.0f, 0);\n    \}\n    else if (which == 5)\n    \{\n      return RGBPrimsToXYZMatrix(float2(0.680f, 0.320f), float2(0.265f, 0.690f), float2(0.150f, 0.060f), float2(0.314f, 0.351f), 1.0f, 0);\n    \}\n    else\n    \{\n      return identity_matrix;\n    \}\n  \}\n\n  void init()\n  \{\n    st2084_m_1   = 2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2   = 2523.0f / 4096.0f * 128.0f;\n    st2084_c_1   = 3424.0f / 4096.0f;\n    st2084_c_2   = 2413.0f / 4096.0f * 32.0f;\n    st2084_c_3   = 2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p   = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit  = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0    = daniele_n / daniele_n_r;\n    daniele_m_1    = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u      = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m      = daniele_m_1 / daniele_u;\n    daniele_w_i    = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t    = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip   = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2    = daniele_c / daniele_g_ipp2;\n    daniele_s_2    = daniele_w_2 * daniele_m_1;\n    daniele_u_2    = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2    = daniele_m_1 / daniele_u_2;\n\n    // 1.0f / (c * z)\n    model_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n\n    // Chroma compression scaling for HDR/SDR appearance match\n    float log_peak = log10(daniele_n / daniele_n_r);\n    compr          = chroma_compress + (chroma_compress * chroma_compress_fact) * log_peak;\n    sat            = max(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * log_peak);\n    sat_thr        = chroma_expand_thr / daniele_n;\n\n    // Gamut mapper focus distance scaling with peak luminance for\n    // HDR/SDR appearance match.  The projection gets slightly less\n    // steep with higher peak luminance.\n    // https://www.desmos.com/calculator/bnfhjcq5vf\n    if (!disableFocusDistScaling)\n      focusDist = focusDistance + focusDistance * focusDistScaling * log_peak;\n    else\n      focusDist = focusDistance;\n\n    float identity_matrix_data\[] = \{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\};\n    identity_matrix.setArray(identity_matrix_data);\n\n    float CAT_CAT16_data\[] = \{\n      0.401288, 0.650173, -0.051461, -0.250268, 1.204414, 0.045854, -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[] = \{\n      0.656619, 0.342071, 0.00131062, -0.222571, 1.10658, 0.115987, -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // M Max data generated via an external Nukescript at a J value of 100\n    float LocusLimitMTable_data\[] = \{\n      244.8230133, 245.4952393, 246.4431458, 247.1381531, 247.2368927, 246.8459778, 245.7083588, 244.2591095, 242.5463409, 240.4208374,\n      238.0180511, 235.4039917, 233.010849,  230.4004669, 227.8723602, 225.2279968, 222.7197876, 214.8562622, 206.1778564, 198.0664215,\n      190.9799347, 184.005127,  177.7472992, 172.2332611, 166.6447754, 161.64534,   156.9872284, 152.6203003, 148.3236084, 144.2987976,\n      140.8540192, 137.4315033, 134.3281555, 131.2306366, 128.3477631, 125.8098145, 123.1305542, 120.5120163, 118.3302231, 116.127861,\n      114.0526428, 112.1633072, 110.2943344, 108.4250336, 106.711853,  105.188797,  103.6860809, 102.2319641, 100.8348923, 99.51873779,\n      98.26163483, 97.04810333, 95.90451813, 94.84623718, 93.86389923, 92.9352951,  92.03639984, 91.15013885, 90.27630615, 89.43255615,\n      88.63536072, 87.8986969,  87.23329163, 86.63896942, 86.09989166, 85.60071564, 85.12715912, 84.66781616, 84.21458435, 83.76491547,\n      83.30849457, 82.86478424, 82.46378326, 82.11483002, 81.82078552, 81.58016968, 81.37005615, 81.18525696, 81.01979065, 80.86772156,\n      80.72546387, 80.59381104, 80.48122406, 80.40287018, 80.33755493, 80.30010986, 80.28891754, 80.28807831, 80.33933258, 80.44513702,\n      80.57379913, 80.71469879, 80.86810303, 81.03874207, 81.23072052, 81.44044495, 81.6555481,  81.901474,   82.20778656, 82.67211151,\n      83.1408844,  83.62628174, 84.0898056,  84.53721619, 84.99518585, 85.49137878, 86.03423309, 86.58794403, 87.16802979, 87.72124481,\n      88.51965332, 89.35781097, 90.16739655, 90.94639587, 91.75927734, 92.65882111, 93.6033783,  94.64561462, 95.68405914, 96.84765625,\n      97.98625183, 99.09587097, 100.2806396, 101.5832748, 103.0694122, 104.6378632, 106.2420197, 107.8503952, 109.5214844, 111.3000031,\n      113.1901169, 115.1414337, 117.1432114, 119.3193054, 121.7141724, 124.2319031, 126.4584961, 128.9876556, 131.6906891, 134.7160034,\n      137.8343048, 140.7224121, 143.7820892, 147.23909,   150.6812439, 154.0381317, 157.1765747, 160.5133972, 164.2957306, 168.1366272,\n      171.8247986, 175.4206543, 179.2828827, 182.0374146, 185.0783844, 188.2106171, 190.9611206, 193.3639221, 195.5132294, 197.58255,\n      199.4234161, 201.3786011, 203.1474609, 205.016037,  206.6236725, 208.1813812, 209.8205719, 211.2774353, 212.8192749, 214.4571686,\n      215.6442261, 216.4818726, 217.1617279, 217.7372131, 218.2023926, 218.4073486, 218.4278564, 217.6643677, 216.4666748, 215.1212463,\n      213.8158264, 212.5012817, 210.8331757, 208.8956146, 206.9006958, 204.9239197, 203.0310059, 201.2084045, 199.3484344, 197.3464355,\n      195.217453,  193.0449677, 190.9578705, 188.9528656, 187.0009918, 185.0068817, 182.9402924, 180.8367767, 178.7057037, 176.5325165,\n      174.445282,  172.4908905, 170.5744934, 168.5490723, 166.459259,  164.4333649, 162.5092621, 160.4579468, 158.491806,  156.6880035,\n      155.0045624, 153.295166,  151.4545441, 149.5910492, 147.7821808, 146.4078522, 144.8022614, 143.2662506, 141.8236542, 140.5029602,\n      139.225174,  137.8959045, 136.4792175, 135.0780334, 133.7389374, 132.7613525, 131.6787109, 130.6356354, 129.64328,   128.7269897,\n      127.8450623, 126.9439697, 126.0015182, 125.0760727, 124.1718826, 123.4704056, 122.8062363, 122.1408768, 121.501358,  120.9004822,\n      120.3225555, 119.7514191, 119.2011871, 118.7055511, 118.2950592, 117.9416199, 117.5793762, 117.2029953, 116.8356552, 116.4874039,\n      116.1693954, 115.9030762, 115.6935577, 115.5213852, 115.3659363, 115.2032318, 115.0445251, 114.9317932, 114.8815384, 114.8605118,\n      114.8510284, 114.8482819, 114.848465,  114.8521805, 114.8999329, 115.0081787, 115.1483612, 115.2983322, 115.511528,  115.7195816,\n      115.9448853, 116.2098999, 116.5264893, 116.8126144, 117.1579666, 117.5379944, 117.9048004, 118.3263168, 118.8006821, 119.2988586,\n      119.8310318, 120.3776703, 121.0383987, 121.6810684, 122.4489899, 123.207077,  124.071022,  124.9082108, 125.74823,   126.6865311,\n      127.4425888, 127.8552094, 128.1067963, 128.3630676, 128.6606598, 128.9203491, 129.2632141, 129.708252,  130.1131287, 130.5647278,\n      130.9923553, 131.5979462, 132.2623444, 132.8651428, 133.4651947, 134.1470337, 134.8683624, 135.683609,  136.6136017, 137.5203552,\n      138.3826599, 139.2931976, 140.2762299, 141.2150574, 142.3930054, 143.7060547, 145.0472565, 146.3404083, 147.6144257, 148.9406586,\n      150.3545532, 151.8509674, 153.4246826, 155.0567017, 156.7265472, 158.4546509, 160.2428131, 162.1348267, 164.1415863, 166.2302551,\n      168.4024506, 170.5583649, 172.6457672, 174.9460449, 177.2792664, 179.6472473, 182.1867218, 184.5882721, 187.3068848, 189.8807373,\n      192.5116577, 195.5551453, 198.5196381, 201.3429413, 203.941452,  206.8439484, 209.5599213, 212.4866943, 215.0750885, 217.929306,\n      220.6668701, 223.364151,  226.2115479, 228.9524536, 231.5583954, 234.405304,  237.0275879, 239.5091705, 242.0047455, 242.0177155,\n      244.8230133\};\n\n    // populate the input primaries matrix\n    RGB_to_XYZ_input = generate_RGB_to_XYZ_matrix(primariesIn);\n    XYZ_to_RGB_input = RGB_to_XYZ_input.invert();\n\n    // AP1 matrix\n    AP1_to_XYZ = generate_RGB_to_XYZ_matrix(1); // AP1 == 1\n    XYZ_to_AP1 = AP1_to_XYZ.invert();\n\n    // populate the limiting primaries matrix\n    // RGBPrimsToXYZMatrix\n    float2 limitWhiteForMatrix;\n    float2 limitRedForMatrix;\n    float2 limitGreenForMatrix;\n    float2 limitBlueForMatrix;\n    if (whiteLimit == 0)\n    \{\n      limitWhiteForMatrix = float2(0.32168f, 0.33767f);\n    \}\n    else if (whiteLimit == 1)\n    \{\n      limitWhiteForMatrix = float2(0.3127f, 0.3290f);\n    \}\n    else\n    \{\n      limitWhiteForMatrix = float2(0.333333f, 0.333333f);\n    \}\n\n    // TODO: could we share these primaries with matrix generation code?\n    if (primariesLimit == 0)\n    \{\n      limitRedForMatrix   = float2(0.7347f, 0.2653);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0001, -0.077);\n    \}\n    else if (primariesLimit == 1)\n    \{\n      limitRedForMatrix   = float2(0.713f, 0.293f);\n      limitGreenForMatrix = float2(0.165f, 0.830f);\n      limitBlueForMatrix  = float2(0.128f, 0.044f);\n    \}\n    else if (primariesLimit == 2)\n    \{\n      limitRedForMatrix   = float2(0.64f, 0.33f);\n      limitGreenForMatrix = float2(0.3f, 0.6f);\n      limitBlueForMatrix  = float2(0.15f, 0.06f);\n    \}\n    else if (primariesLimit == 3)\n    \{\n      limitRedForMatrix   = float2(0.708f, 0.292f);\n      limitGreenForMatrix = float2(0.170f, 0.797f);\n      limitBlueForMatrix  = float2(0.131f, 0.046f);\n    \}\n    else if (primariesLimit == 4)\n    \{\n      limitRedForMatrix   = float2(0.680f, 0.320f);\n      limitGreenForMatrix = float2(0.265f, 0.690f);\n      limitBlueForMatrix  = float2(0.150f, 0.060f);\n    \}\n    else\n    \{\n      limitRedForMatrix   = float2(1.0f, 0.0f);\n      limitGreenForMatrix = float2(0.0f, 1.0f);\n      limitBlueForMatrix  = float2(0.0f, 0.0f);\n    \}\n\n    RGB_to_XYZ_limit = RGBPrimsToXYZMatrix(limitRedForMatrix, limitGreenForMatrix, limitBlueForMatrix, limitWhiteForMatrix, 1.0f, 0);\n    XYZ_to_RGB_limit = RGB_to_XYZ_limit.invert();\n\n    RGB_to_XYZ_reach = generate_RGB_to_XYZ_matrix(primariesReach);\n    XYZ_to_RGB_reach = RGB_to_XYZ_reach.invert();\n\n    RGB_to_XYZ_output = generate_RGB_to_XYZ_matrix(primariesOut);\n    XYZ_to_RGB_output = RGB_to_XYZ_output.invert();\n\n    float3 white(1.0f, 1.0f, 1.0f);\n    inWhite    = vector_dot(RGB_to_XYZ_input, white);\n    outWhite   = vector_dot(RGB_to_XYZ_output, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = peakLuminance / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n      CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n      CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n      CAT_CAT16 = RGBPrimsToXYZMatrix(rxy, gxy, bxy, wxy, 1.0f, 1);\n    \}\n    CAT_CAT16_INVERSE = CAT_CAT16.invert();\n\n    generate_panlrcm();\n\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      LocusLimitMTable\[i] = LocusLimitMTable_data\[i];\n    \}\n\n    // calculate the maximum expected J & M values for the given limit gamut\n    // these are used as limiting values for the gamut boundary searches\n    // limitJmax (assumed to match limitRGB white)\n    limitJmax = RGB_to_JMh(float3(1.0f), limitWhite, RGB_to_XYZ_limit).x;\n\n    // Cusp table for chroma compression gamut\n    float3x3 RGB_to_XYZ_cgReach;\n    if (ccReach == 0) // Chroma Compression Space (primaries defined in kernel params)\n    \{\n      RGB_to_XYZ_cgReach = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 0);\n\n    \}\n    else if (ccReach == 1)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(0);\n    \}\n    else if (ccReach == 2)\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(1);\n    \}\n    else\n    \{\n      RGB_to_XYZ_cgReach = generate_RGB_to_XYZ_matrix(3);\n    \}\n    const float3x3 XYZ_to_RGB_cgReach = RGB_to_XYZ_cgReach.invert();\n\n    initialise_cusp_table(cgamutCuspTable, gamutCuspTableSize, inWhite, RGB_to_XYZ_cgReach);\n    initialise_reach_cusp_table(cgamutReachTable, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_cgReach);\n\n    // With gamut mapper reach mode 7, use the chroma compression reach space with the\n    // gamut mapper.\n    if (primariesReach == 7)\n      XYZ_to_RGB_reach = XYZ_to_RGB_cgReach;\n\n    // Cusp table for limiting gamut\n    initialise_cusp_table(gamutCuspTable, gamutCuspTableSize, limitWhite, RGB_to_XYZ_limit);\n    initialise_reach_cusp_table(gamutCuspTableReach, gamutCuspTableSize, limitJmax, inWhite, XYZ_to_RGB_reach);\n\n    midJ = XYZ_to_JMh(inWhite * daniele_c_t * mmScaleFactor, inWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid,\n                      HK_mode_mid)\n             .x;\n\n    initialise_upper_hull_gamma();\n    initialise_lower_hull_gamma();\n  \}\n\n  void initialise_cusp_table(float3 output_table\[], const int table_size, float3 refWhite, const float3x3& matrix)\n  \{\n    // the 'tempTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    float3 tempTableUnsorted\[gamutCuspTableSize];\n    int    minhIndex = 0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float  hNorm   = float(i) / (table_size);\n      const float3 RGB     = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      tempTableUnsorted\[i] = RGB_to_JMh(RGB, refWhite, matrix);\n      if (tempTableUnsorted\[i].z < tempTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    copy_table_rotated(tempTableUnsorted, table_size, output_table, minhIndex);\n\n    // Add extra entry to wrap\n    output_table\[gamutCuspTableSize]   = output_table\[0];\n    output_table\[gamutCuspTableSize].z = output_table\[gamutCuspTableSize].z + 360.0f;\n  \}\n\n  void copy_table_rotated(float3 tableUnsorted\[], const int tableSize, float3 output_table\[], const int offsetIndex)\n  \{\n    for (int i = 0; i < tableSize; ++i)\n    \{\n      output_table\[i] = tableUnsorted\[(offsetIndex + i) % tableSize];\n    \}\n  \}\n\n  void initialise_reach_cusp_table(float3 output_table\[], const int table_size, const float limitJ, float3 refWhite, const float3x3& matrix)\n  \{\n    const float search_range = 100.0;\n    for (int i = 0; i < table_size; ++i)\n    \{\n      const float hue = base_hue_for_position(i, table_size);\n\n      float low     = 0.0;\n      float high    = low + search_range;\n      bool  outside = false;\n\n      while (!outside && high < 1400.0)\n      \{\n        outside = any_below_zero(JMh_to_RGB(float3(limitJ, high, hue), refWhite, matrix));\n        if (!outside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      while ((high - low) > 1e-2)\n      \{\n        const float sampleM = (high + low) / 2.0;\n        outside             = any_below_zero(JMh_to_RGB(float3(limitJ, sampleM, hue), refWhite, matrix));\n        if (outside)\n        \{\n          high = sampleM;\n        \}\n        else\n        \{\n          low = sampleM;\n        \}\n      \}\n      output_table\[i].x = limitJ;\n      output_table\[i].y = high;\n      output_table\[i].z = hue;\n    \}\n    // Wrap last entry in table\n    output_table\[table_size] = output_table\[0];\n    output_table\[table_size].z += 360.0f;\n  \}\n\n  inline bool outside_hull(const float3 newLimitRGB)\n  \{\n    // limit value, once we cross this value, we are outside of the top gamut shell\n    const float maxRGBtestVal = 1.0f;\n    if (newLimitRGB.x > maxRGBtestVal || newLimitRGB.y > maxRGBtestVal || newLimitRGB.z > maxRGBtestVal)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_upper_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float topGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, min(1.0, cuspMidBlend - (JMcusp.x / limitJmax)));\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float  slope_gain  = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n      const float3 approxLimit =\n        findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, topGamma, lowerHullGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!outside_hull(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_upper_hull_gamma()\n  \{\n    // Find upper hull gamma values for the gamut mapper\n    // start by taking a h angle\n    // get the cusp J value for that angle\n    // find a J value halfway to the Jmax\n    // iterate through gamma values until the approximate max M is negative through the actual boundary\n\n    // positions between the cusp and Jmax we will check\n    // variables that get set as we iterate through, once all are set to true we break the loop\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.5f, 0.99f\};\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableUpperHullGamma)\n      \{\n        gamutGammas\[i].x =  upperHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n      //  default value. This will get overridden as we loop, but can be a good diagnostic to make sure things are working\n      gamutGammas\[i].x    = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        // create test values halfway between the cusp and the Jmax\n        testJmh\[testIndex] = float3(JMcusp.x + ((limitJmax - JMcusp.x) * testPositions\[testIndex]), JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.4;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_upper_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].x = gamutGammas\[0].x;\n   \}\n\n  inline bool any_below_zero(const float3 newLimitRGB)\n  \{\n    if (newLimitRGB.x < 0.0f || newLimitRGB.y < 0.0f || newLimitRGB.z < 0.0f)\n    \{\n      return true;\n    \}\n    return false;\n  \}\n\n  bool evaluate_lower_hull_gamma_fit(const float2 JMcusp, float3 testJmh\[], const int test_count, const float bottomGamma)\n  \{\n    const float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n    for (int testIndex = 0; testIndex < test_count; ++testIndex)\n    \{\n      const float slope_gain = limitJmax * focusDist * getFocusGain(testJmh\[testIndex].x, JMcusp.x);\n\n      const float3 approxLimit     = findGamutBoundaryIntersection(testJmh\[testIndex], JMcusp, focusJ, limitJmax,\n                                                                   slope_gain, smoothCusps, upperHullGamma, bottomGamma);\n      const float3 approximate_JMh = float3(approxLimit.x, approxLimit.y, testJmh\[testIndex].z);\n      const float3 newLimitRGB     = JMh_to_RGB(approximate_JMh, limitWhite, XYZ_to_RGB_limit);\n\n      if (!any_below_zero(newLimitRGB))\n      \{\n        return false;\n      \}\n    \}\n    return true;\n  \}\n\n  void initialise_lower_hull_gamma()\n  \{\n    // Same process, for the bottom hull gamma\n    const int   test_count                = 3;\n    const float testPositions\[test_count] = \{0.01f, 0.4f, 0.75f\};\n\n    for (int i = 0; i < gamutCuspTableSize; ++i)\n    \{\n      if (disableLowerHullGamma)\n      \{\n        gamutGammas\[i].y = lowerHullGamma;\n        continue;\n      \}\n      const float hue = base_hue_for_position(i, gamutCuspTableSize);\n\n      gamutGammas\[i].y = -1.0f;\n      const float2 JMcusp = cuspFromTable(hue);\n      float3       testJmh\[test_count];\n      for (int testIndex = 0; testIndex < test_count; ++testIndex)\n      \{\n        testJmh\[testIndex] = float3(JMcusp.x * testPositions\[testIndex], JMcusp.y, hue);\n      \}\n\n      const float search_range = 0.4;\n      float       low          = 0.8;\n      float       high         = low + search_range;\n      bool        all_inside   = false;\n\n      while (!all_inside && high < 5.0)\n      \{\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, high);\n        if (!all_inside)\n        \{\n          low  = high;\n          high = high + search_range;\n        \}\n      \}\n\n      float testGamma = -1.0;\n      while ((high - low) > 1e-5)\n      \{\n        testGamma  = (high + low) / 2.0;\n        all_inside = evaluate_lower_hull_gamma_fit(JMcusp, testJmh, test_count, testGamma);\n        if (all_inside)\n        \{\n          high = testGamma;\n        \}\n        else\n        \{\n          low = testGamma;\n        \}\n      \}\n      gamutGammas\[i].x = testGamma;\n    \}\n    // Wrap the last entry\n    gamutGammas\[gamutCuspTableSize].y = gamutGammas\[0].y;\n  \}\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n    float3 diagnostic;\n\n    if (invert)\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh           = inverseTonescale(tonemappedJMh);\n      diagnostic    = JMh_to_input_RGB(JMh);\n    \}\n    else\n    \{\n      JMh           = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n      diagnostic    = JMh_to_output_RGB(compressedJMh);\n    \}\n\n    if (diagnosticMode == 1 || diagnosticMode == 6)\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      if (invert)\n      \{\n        diagnostic = JMh_to_input_RGB(srcRGB);\n      \}\n      else\n      \{\n        diagnostic = JMh;\n      \}\n    \}\n    else if (diagnosticMode == 2 || diagnosticMode == 99)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if (diagnosticMode == 3 || diagnosticMode == 5)\n    \{\n      diagnostic = compressedJMh;\n    \}\n    else if (diagnosticMode == 4 || diagnosticMode == 7)\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB     = JMh_to_output_RGB(srcRGB);\n      diagnostic = dstRGB;\n    \}\n    else if (diagnosticMode == 8)\n    \{\n      diagnostic = inWhite;\n    \}\n    else if (diagnosticMode == 9)\n    \{\n      diagnostic = outWhite;\n    \}\n    else if (diagnosticMode == 10)\n    \{\n      diagnostic = limitWhite;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    else if (diagnosticMode == 14)\n    \{\n      // output gamut cusp\n      const float2 JMcusp = cuspFromTable(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 16)\n    \{\n      // output Locus cusp\n      const float2 JMcusp = cuspFromTableLocus(srcRGB.z);\n      diagnostic          = float3(JMcusp.x, JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 17)\n    \{\n      // output Locus boundary\n      diagnostic = getLocusBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 18)\n    \{\n      // output gamut boundary\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 19)\n    \{\n      // output Reach boundary\n      diagnostic = getReachBoundry(srcRGB);\n    \}\n    else if (diagnosticMode == 20)\n    \{\n      // output JMFocus\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 21)\n    \{\n      // output JMFocus\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).y, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 22)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float slope_gain = limitJmax * focusDist;\n      diagnostic       = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 23)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic         = float3(approxLimit.x, approxLimit.y, srcRGB.z);\n    \}\n\n    else if (diagnosticMode == 24)\n    \{\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      // create test value halfway between the cusp and the Jmax\n      float  slope_gain  = limitJmax * focusDist;\n      float3 testJmh     = float3(JMcusp.x + ((limitJmax - JMcusp.x) / 2.0f), JMcusp.y, srcRGB.z);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 approxLimit = findGamutBoundaryIntersection(testJmh, JMcusp, (JMcusp.x + 38.0f) / 2, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      float3 newLimitRGB = JMh_to_RGB(float3(approxLimit.x, approxLimit.y, srcRGB.z), limitWhite, XYZ_to_RGB_limit);\n      diagnostic         = newLimitRGB;\n    \}\n\n    else if (diagnosticMode == 25)\n    \{\n      float2 JMcusp            = cuspFromTable(srcRGB.z);\n      float  focusJ            = lerp(JMcusp.x, midJ, min(1.0f, cuspMidBlend - (JMcusp.x / limitJmax)));\n      float  slope_gain        = limitJmax * focusDist * getFocusGain(JMh.x, JMcusp.x);\n      const float2 gammas      = hueDependantHullGammas(srcRGB.z);\n      float3 nickBoundryReturn = findGamutBoundaryIntersection(srcRGB, JMcusp, focusJ, limitJmax, slope_gain, smoothCusps, gammas.x, gammas.y);\n      diagnostic               = float3(srcRGB.x, nickBoundryReturn.y, srcRGB.z);\n    \}\n    else if (diagnosticMode == 26)\n    \{\n      // XYZ back to luminance RGB\n      float3 JMh = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n      diagnostic = vector_dot(XYZ_to_RGB_limit, JMh);\n    \}\n    else if (diagnosticMode == 27)\n    \{\n      // output\n      diagnostic = float3(hueDependantHullGammas(srcRGB.z).x, 0.0f, 0.0f);\n    \}\n    else if (diagnosticMode == 28)\n    \{\n      // output\n      float2 JMcusp = cuspFromTable(srcRGB.z);\n      const float2 gammas = hueDependantHullGammas(srcRGB.z);\n      diagnostic    = findGamutBoundaryIntersection(srcRGB, JMcusp, lerp(JMcusp.x, midJ, cuspMidBlend), limitJmax, 10000.0f, 0.0f,\n                                                    gammas.x, gammas.y);\n    \}\n\n    // extra modes to allow for easier breakout of the order of events.\n    // modes starting with 100\n\n    ////// FORWARD PATHWAY\n\n    else if (diagnosticMode == 100)\n    \{\n      // display encoding to display linear\n      diagnostic      = encodingToLuminance3(encodingIn, srcRGB);\n    \}\n    else if (diagnosticMode == 101)\n    \{\n      // convert to linear XYZ luminance values\n      diagnostic = vector_dot(RGB_to_XYZ_input, srcRGB);\n    \}\n    else if (diagnosticMode == 102)\n    \{\n      // convert luminanceXYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 103)\n    \{\n      // JMh to tonemappedJMh\n      diagnostic = forwardTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 104)\n    \{\n      // JMh to gamut compressed JMh\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n    else if (diagnosticMode == 105)\n    \{\n      // JMh to luminance XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, limitWhite, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 106)\n    \{\n      // display luminance XYZ to display linear RGB\n      diagnostic = vector_dot(XYZ_to_RGB_output, srcRGB);\n    \}\n    else if (diagnosticMode == 107)\n    \{\n      // display linear RGB to display encoded RGB\n      diagnostic = luminanceToEncoding3(encodingOut, srcRGB);\n    \}\n\n    ////// INVERSE PATHWAY\n\n    else if (diagnosticMode == 200)\n    \{\n      // output display encoded RGB to display linear RGB\n      diagnostic = encodingToLuminance3(encodingOut, srcRGB);\n    \}\n    else if (diagnosticMode == 201)\n    \{\n      // output display linear RGB to output display linear XYZ\n      diagnostic = vector_dot(RGB_to_XYZ_output, srcRGB);\n    \}\n    else if (diagnosticMode == 202)\n    \{\n      // output XYZ to JMh\n      diagnostic = XYZ_to_JMh(srcRGB, limitWhite, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    \}\n    else if (diagnosticMode == 203)\n    \{\n      // uncompress gamut\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 204)\n    \{\n      // inverse tonescale in JMh\n      diagnostic = inverseTonescale(srcRGB);\n    \}\n    else if (diagnosticMode == 205)\n    \{\n      // inverted JMh back to XYZ\n      diagnostic = JMh_to_XYZ(srcRGB, inWhite, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    \}\n    else if (diagnosticMode == 206)\n    \{\n      // XYZ back to luminance RGB\n      diagnostic = vector_dot(XYZ_to_RGB_input, srcRGB);\n    \}\n    else if (diagnosticMode == 207)\n    \{\n      // luminance RGB to input encoding RGB\n      diagnostic = luminanceToEncoding3(encodingIn, srcRGB);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w);\n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_AP1Clamp {{parent.ap1_clamp}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_peakLuminance {{parent.peak_luminance}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_applyInGamutExpansion {{parent.applyInGamutExpansion}}
  DRT_CAM_Kernel_applyInGamutCompression {{parent.applyInGamutCompression}}
  DRT_CAM_Kernel_applyReachClamp {{parent.applyReachClamp}}
  DRT_CAM_Kernel_monochrome {{parent.monochrome}}
  DRT_CAM_Kernel_chroma_compress {{parent.compress}}
  "DRT_CAM_Kernel_Chroma Compress Factor" {{parent.chroma_compress_fact}}
  DRT_CAM_Kernel_chroma_expand {{parent.chroma_expand}}
  "DRT_CAM_Kernel_Chroma Expansion Factor" {{parent.chroma_expand_fact}}
  DRT_CAM_Kernel_chroma_expand_thr {{parent.chroma_expand_thr}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_ccReach {{parent.ccReachPrimaries}}
  DRT_CAM_Kernel_crxy {0.7347 0.2653}
  DRT_CAM_Kernel_cgxy {0.12 0.88}
  DRT_CAM_Kernel_cbxy {0.08 -0.04}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_whiteLimit {{parent.white_limit}}
  DRT_CAM_Kernel_primariesReach {{parent.primaries_reach}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_focusAdjustGain {{parent.focusgain}}
  DRT_CAM_Kernel_focusGainBlend {{parent.focus_gain_blend}}
  DRT_CAM_Kernel_focusDistScaling {{parent.focusdistscaling}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r x272 -1.75} {parent.compression_params.g} {parent.compression_params.b} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR x272 0.21} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_Reachcompressmode {{parent.reachCompressMode}}
  DRT_CAM_Kernel_reachNick true
  DRT_CAM_Kernel_Locuscompressmode {{parent.BlinkScript1_DRT_CAM_Kernel_Locuscompressmode}}
  DRT_CAM_Kernel_boundryIntersectionMethod {{boundryIntersectionMethod}}
  DRT_CAM_Kernel_disableLowerHullGamma true
  DRT_CAM_Kernel_lowerHullGamma {{lowerHullGamma}}
  DRT_CAM_Kernel_upperHullGamma {{parent.upperHullGamma}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  "DRT_CAM_Kernel_Smoothing factor cusp J" {{parent.smoothJ}}
  "DRT_CAM_Kernel_Smoothing factor cust M" {{parent.smoothM}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_fitWhite {{parent.fit_white}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.peak_luminance}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.8336 0.1735}
  DRT_CAM_Kernel_gxy {2.3854 -1.4659}
  DRT_CAM_Kernel_bxy {0.087 -0.125}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -201
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Reformat {
 type scale
 scale 7
 filter impulse
 name Reformat6
 label "scale up 7x"
 xpos 774
 ypos 658
}
Dot {
 name Dot12
 xpos 808
 ypos 690
}
set Nb1d61400 [stack 0]
Expression {
 expr0 isnan(r)?0:r
 expr1 isnan(g)?0:g
 expr2 isnan(b)?0:b
 name killNan5
 xpos 820
 ypos 707
}
Clamp {
 minimum -65535
 maximum 65535
 name Clamp1
 xpos 820
 ypos 731
}
Colorspace {
 illuminant_in ACES
 primary_in ACES
 colorspace_out CIE-XYZ
 name Colorspace9
 label "XYZ to AP0"
 xpos 820
 ypos 767
 disable true
}
ColorMatrix {
 matrix {
     {1.009929895 -0.01972960308 -0.03755422309}
     {0.3892438412 0.7234188318 -0.112662673}
     {-0.347163409 -0.04603575915 1.402024388}
   }
 invert true
 name ColorMatrix6
 label "APS4 to XYZ"
 xpos 820
 ypos 799
 disable true
}
Expression {
 temp_name0 cut_lin
 temp_expr0 0.0078125
 temp_name1 cut_log
 temp_expr1 0.155251141552511
 temp_name2 A
 temp_expr2 10.5402377416545
 temp_name3 B
 temp_expr3 0.0729055341958355
 expr0 r<=cut_lin?A*r+B:(log(r)/log(2)+9.72)/17.52
 expr1 g<=cut_lin?A*g+B:(log(g)/log(2)+9.72)/17.52
 expr2 b<=cut_lin?A*b+B:(log(b)/log(2)+9.72)/17.52
 channel3 none
 name lin2log5
 label ACEScct
 xpos 820
 ypos 831
}
push $Nb1d61400
Switch {
 inputs 2
 which {{master.inverseMode}}
 name Switch8
 xpos 774
 ypos 874
}
Group {
 name Write_ResolveACES_ODT_LUT11
 label "\[python nuke.thisNode().knob('cubePath').evaluate().split('/').pop(-1)]"
 xpos 774
 ypos 994
 addUserKnob {20 User}
 addUserKnob {1 candidate}
 candidate CAMDRT
 addUserKnob {1 revision}
 revision "\[value master.revision]"
 addUserKnob {1 target}
 target "Rec2100 (P3D65 500nit Limited)"
 addUserKnob {2 cubePath}
 cubePath "DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {2 ocioCubePath}
 ocioCubePath "OCIO/luts/ACES2_Candidates_rev\[value revision]/ACES2 Candidate \[value candidate] rev\[value revision] \[value target].cube"
 addUserKnob {1 cubPath t "For truelight cub files"}
 cubPath "Baselight/ACES2_Candidates_rev\[value revision]/ACES2_Candidate_\[value candidate]_rev\[value revision]_\[value target].cub"
 addUserKnob {41 file l "output file" +INVISIBLE T GenerateLUT1.file}
 addUserKnob {41 generate l "Generate and Write LUT File" +INVISIBLE T GenerateLUT1.generate}
 addUserKnob {26 ""}
 addUserKnob {2 dctlTemplate}
 dctlTemplate resources/ACES_ApplyLUT_Template_AP0.dctl
 addUserKnob {2 fltransformTemplate}
 fltransformTemplate resources/ACES_DRT_Template_AP0.fltransform
 addUserKnob {1 dctlColorspaceBufferTag}
 dctlColorspaceBufferTag Rec2020_1000nits_15nits_ST2084
}
 Input {
  inputs 0
  name Input1
  xpos 411
  ypos 213
 }
 GenerateLUT {
  file "/Users/afry/GitHub/ACES_ODT_Candidates/DaVinci Resolve/ACES Transforms/ODT/ACES2 Candidates rev060/ACES2 Candidate CAMDRT rev060 Rec2100 (P3D65 500nit Limited)_inverse.cube"
  file_type .cube
  name GenerateLUT1
  xpos 411
  ypos 267
 }
 Output {
  name Output1
  xpos 411
  ypos 353
 }
end_group
push $Nb2fe8e00
push 0
push 0
Viewer {
 inputs 3
 frame_range 1-100
 colour_sample_bbox {0.03296703473 -0.7857142687 0.04395604506 -0.7747252584}
 gl_buffer_depth half-float
 viewerProcess None
 monitorOutNDISenderName "Nuke - ACES_ODT_Candidates_LUT_Bake_rev060 - Viewer1"
 monitorOutOutputTransform rec709
 name Viewer1
 xpos 611
 ypos 1109
}
NoOp {
 inputs 0
 name master
 tile_color 0x102307ff
 label "rev\[value revision]"
 note_font_size 50
 note_font_color 0x347216ff
 xpos 831
 ypos 5
 addUserKnob {20 User}
 addUserKnob {1 revision}
 revision 060
 addUserKnob {22 bakeAllODTs T "### This code is embedded in the nukescript, not accessed from here\n\n\n\n\n\n\n\n\nimport os\nimport shutil\n\n\n\n\n\nmasterNode = nuke.thisNode()\n\n\n\n\n\nbakeLuts = nuke.thisNode().knob('bakeLUTs').value()\n\n\n\n\n\ndef cubeToCub(cubePath,cubPath):\n    inputCubePath = cubePath\n    ouputCubPath = cubPath\n\n\n\n\n    # read the cube\n    with open(inputCubePath) as f:\n        lines = f.readlines()\n\n\n\n\n    cubeSize = lines\[1].split(' ')\[1].replace('\\n','')\n\n\n\n\n    # header\n    tlHeader = '''# Truelight Cube v2.1\n    # iDims     3\n    # oDims     3\n    # width     CUBESIZE CUBESIZE CUBESIZE\\n\n    # Cube'''\n\n\n\n\n    tlHeader = tlHeader.replace('CUBESIZE',cubeSize)\n\n\n\n\n    # footer\n    tlFooter = '''\\n# end\\n'''\n\n\n\n\n    LUTlines = lines\[2:]\n    LUTlines = \[x.replace('\\n','').split(' ') for x in LUTlines]\n    LUTlines = \[\[float(i) for i in x] for x in LUTlines]\n    LUTlines = \[\[str(i) for i in x] for x in LUTlines]\n\n\n\n\n    ## remove decimal from 0.0 and 1.0\n    for i, x in enumerate(LUTlines):\n        for j, a in enumerate(x):\n            if '0.0' == a:\n                LUTlines\[i]\[j] = '0'\n            if '1.0' == a:\n                LUTlines\[i]\[j] = '1'\n\n\n\n\n    # reconstruct the cube string\n    stringLUTlines = \[]\n    for line in LUTlines:\n        stringLUTlines.append(' '.join(line))\n    newLUTStringBlock = '\\n'.join(stringLUTlines)\n\n\n\n\n    # join it all up\n    outputContents = tlHeader + '\\n' + newLUTStringBlock + '\\n' + tlFooter\n\n\n\n\n    # check directory for outputCubPath exists, if not, create it\n    if not os.path.exists(os.path.dirname(ouputCubPath)):\n        os.makedirs(os.path.dirname(ouputCubPath))\n\n\n\n\n    # write the file\n    with open(ouputCubPath, 'w') as f:\n        f.write(outputContents)\n\n\n\n\n\n\n\n\ndef bakeCandidateLUTfromNode(node,inverse=False):\n    candidate = node.knob('candidate').value()\n    revision = node.knob('revision').value()\n    target = node.knob('target').value()\n\n\n\n\n\n\n\n\n    nukeScriptDir = nuke.script_directory()\n    print(nukeScriptDir)\n    dctltemplatePath = os.path.join(nukeScriptDir,node.knob('dctlTemplate').evaluate())\n    if inverse:\n        dctltemplatePath = dctltemplatePath.replace('.dctl','_inverse.dctl')\n\n\n\n\n    fltransformTemplatePath = os.path.join(nukeScriptDir,node.knob('fltransformTemplate').evaluate())\n    # flSpacePath = os.path.join(nukeScriptDir,'resources/ACEScct_AP0.flspace')\n    # print(flSpacePath)\n\n\n\n\n\n\n\n\n    cubePath = os.path.join(nukeScriptDir,node.knob('cubePath').evaluate())\n    cubePathClean = cubePath.replace('(','').replace(')','')\n    ocioCubePath = os.path.join(nukeScriptDir,node.knob('ocioCubePath').evaluate())\n    cubPath = os.path.join(nukeScriptDir,node.knob('cubPath').evaluate())\n    dctlColorspaceBufferTag = node.knob('dctlColorspaceBufferTag').getValue()\n\n\n\n\n    if inverse:\n        cubePath = cubePath.replace('.cube','_inverse.cube')\n        cubePathClean = cubePathClean.replace('.cube','_inverse.cube')\n        ocioCubePath = ocioCubePath.replace('.cube','_inverse.cube')\n        cubPath = cubPath.replace('.cub','_inverse.cub')\n\n\n\n\n    # replace LUT writer path with evaluated path\n    node.knob('file').setValue(cubePath)\n\n\n\n\n\n\n\n\n    # check cubePath exists, if not, create it\n    if not os.path.exists(os.path.dirname(cubePath)):\n        os.makedirs(os.path.dirname(cubePath))\n\n\n\n\n\n\n\n    # check ocioCubePath exists, if not, create it\n    if not os.path.exists(os.path.dirname(ocioCubePath)):\n        os.makedirs(os.path.dirname(ocioCubePath))\n\n\n\n\n    dctlPath = cubePath.replace('.cube','.dctl')\n    if inverse:\n        dctlPath = dctlPath.replace('/ODT/','/IDT/')\n\n\n\n\n    # check dctlPath exists, if not, create it\n    if not os.path.exists(os.path.dirname(dctlPath)):\n        os.makedirs(os.path.dirname(dctlPath))\n\n\n\n\n    cubeName = cubePath.split('/').pop(-1)\n    cubeNameClean = cubeName.replace('(','').replace(')','')\n\n\n\n\n\n\n\n\n\n    if bakeLuts == True:\n        node.knob('generate').execute()\n        # if cubeName does not match cubeNameClean copy cubeName to cubeNameClean\n        if cubePath != cubePathClean:\n            shutil.copy(cubePath,cubePathClean)\n\n\n\n\n\n    # read contents of cube file\n    with open(cubePathClean) as f:\n        cubelines = f.readlines()\n\n\n\n\n\n\n    ## write the dctl file\n    with open(dctltemplatePath) as f:\n        lines = f.readlines()\n    newLines = \[x.replace('replace.cube',cubeNameClean) for x in lines]\n    newLines = \[x.replace('DCTL_ACES_COLORSPACE_BUFFER_TAG_PLACEHOLDER',dctlColorspaceBufferTag) for x in lines]\n    # replace the string REPLACE_WITH_CUBE_DATA with the contents of cubelines\n    newLines = \[x.replace('REPLACE_WITH_CUBE_DATA',''.join(cubelines)) for x in newLines]\n\n\n\n\n    with open(dctlPath, 'w') as f:\n        f.write(''.join(newLines))\n\n\n\n\n\n\n\n\n    # Baselight\n    # convert cube to cub\n    cubeToCub(cubePath,cubPath)\n\n\n\n\n    # copy cubePath to ocioCubePath\n    shutil.copy(cubePath,ocioCubePath)\n\n\n\n\n    # # remove original cube if it isnt the same as the clean version\n    # if cubePathClean != cubePath:\n    #     # delete cubeName\n        # os.remove(cubePath)\n    if os.path.exists(cubePath):\n        os.remove(cubePath)\n    if os.path.exists(cubePathClean):\n        os.remove(cubePathClean)\n\n\n\n\n\n\n\n\n    ## write the fltransform\n    if target == 'Rec709':\n        if  inverse == False:\n            fltransformPath = cubPath.replace('.cub','.fltransform')\n            cubeToken = os.path.basename(cubPath.replace('_Rec709','').replace('.cub',''))\n            newFltransformName = fltransformPath.replace('_Rec709','')\n            with open(fltransformTemplatePath) as f:\n                lines = f.readlines()\n            newLines = \[x.replace('replaceTransformName','ACES 2.0 Candidate'+ candidate + ' rev'+revision) for x in lines]\n            newLines = \[x.replace('replaceForward',cubeToken) for x in newLines]\n            # newLines = \[x.replace('replaceForward_Rec2100',os.path.basename(cubPath).replace('Rec709','Rec2100').replace('.cub','')) for x in newLines]\n            with open(newFltransformName, 'w') as f:\n                f.write(''.join(newLines))\n\n\n\n\n\n\n\n\n    # check ACEScct_AP0.flspace exists, if not, copy it\n    for flspace in \['/ACEScct_AP0.flspace','/ACEScct_APS4.flspace']:\n        flSpaceSourcePath = os.path.join(nukeScriptDir,'resources' + flspace)\n        flSpaceDestPath = os.path.dirname(cubPath) + flspace\n        if not os.path.exists(flSpaceDestPath):\n            shutil.copy(flSpaceSourcePath,flSpaceDestPath)\n\n\n\n\n\n\n\n\ndef createOCIOconfigs(revision):\n    nukeScriptDir = nuke.script_directory()\n    revision = nuke.thisNode().knob('revision').value()\n    ocioTemplateDir = os.path.join(nukeScriptDir,'resources/')\n    newOcioTemplateDir = os.path.join(nukeScriptDir,'OCIO/')\n    ocioConfigTemplates = \[x for x in os.listdir(ocioTemplateDir) if x.endswith('.ocio')]\n    ocioConfigTemplatePaths = \[os.path.join(ocioTemplateDir,x) for x in ocioConfigTemplates]\n\n\n\n\n\n    activeViewDicts = \[]\n    activeViewDicts.append(\{'name':'All','values':\[\n        'ACES 2.0 Candidate CAMDRT revXXX - Rec.709',\n        'ACES 2.0 Candidate CAMDRT revXXX - P3D65',\n        'ACES 2.0 Candidate CAMDRT revXXX - P3D65 (Rec709 sim)',\n        'ACES 2.0 Candidate CAMDRT revXXX - Rec.2100 (Rec709 sim)',\n        'ACES 2.0 Candidate CAMDRT revXXX - Rec.2100 (P3D65 540nit Limited)',\n        'ACES 2.0 Candidate CAMDRT revXXX - Rec.2100 (P3D65 1000nit Limited)',\n        'ACES 2.0 Candidate CAMDRT revXXX - DisplayP3 (Rec.709 Limited)',\n        'ACES 2.0 Candidate CAMDRT revXXX - DisplayP3 (P3D65 Limited)',\n        'ACES 2.0 Candidate CAMDRT revXXX - DisplayP3 (P3D65 540nit Limited)',\n        'ACES 2.0 Candidate CAMDRT revXXX - DisplayP3 (P3D65 1000nit Limited)',\n        'ACES 1.2 - Rec.709',\n        'ACES 1.2 - Rec2100',\n        'ACES 1.2 - Rec2100 (Rec709 sim)',\n        'ACES 1.2 - DisplayP3 (Rec.709 Limited)',\n        'ACES 1.2 - DisplayP3 (P3D65 1000nit Limited)',\n        ]\})\n\n\n\n\n    activeViewDicts.append(\{'name':'DisplayP3','values':\[\n        'ACES 2.0 Candidate CAMDRT revXXX - DisplayP3 (Rec.709 Limited)',\n        'ACES 2.0 Candidate CAMDRT revXXX - DisplayP3 (P3D65 Limited)',\n        'ACES 2.0 Candidate CAMDRT revXXX - DisplayP3 (P3D65 540nit Limited)',\n        'ACES 2.0 Candidate CAMDRT revXXX - DisplayP3 (P3D65 1000nit Limited)',\n        'ACES 1.2 - DisplayP3 (Rec.709 Limited)',\n        'ACES 1.2 - DisplayP3 (P3D65 1000nit Limited)',\n        ]\})\n\n\n\n\n    activeViewDicts.append(\{'name':'Limited','values':\[\n        'ACES 2.0 Candidate CAMDRT revXXX - Rec.709',\n        'ACES 2.0 Candidate CAMDRT revXXX - P3D65',\n        'ACES 2.0 Candidate CAMDRT revXXX - P3D65 (Rec709 sim)',\n        'ACES 2.0 Candidate CAMDRT revXXX - Rec.2100 (Rec709 sim)',\n        'ACES 2.0 Candidate CAMDRT revXXX - Rec.2100 (P3D65 540nit Limited)',\n        'ACES 2.0 Candidate CAMDRT revXXX - Rec.2100 (P3D65 1000nit Limited)',\n        'ACES 1.2 - Rec.709',\n        'ACES 1.2 - Rec2100',\n        'ACES 1.2 - Rec2100 (Rec709 sim)',\n        ]\})\n\n\n\n\n\n    for config in ocioConfigTemplatePaths:\n        for activeViewDict in activeViewDicts:\n\n\n\n\n            configName = config.split('/').pop(-1)\n            newConfigName = configName.replace('revXXX','rev'+revision).replace('TEMPLATE',activeViewDict\['name'])\n            newConfigPath = os.path.join(newOcioTemplateDir,newConfigName)\n            with open(config) as f:\n                lines = f.readlines()\n            activeViewsStrings = \[ x.replace('revXXX','rev'+revision) for x in  activeViewDict\['values']]\n            activeViews = ','.join(activeViewsStrings)\n            newLines = \[x.replace('revXXX','rev'+revision).replace('ACTIVEVIEWSPLACEHOLDER',activeViews) for x in lines]\n            with open(newConfigPath, 'w') as f:\n                f.write(''.join(newLines))\n\n\n\n\n\n\n\nODTWrites = \[]\nfor node in nuke.allNodes():\n    if 'Write_ResolveACES_ODT_LUT' in node.name():\n        ODTWrites.append(node)\n\n\n\n\n\n\n\nfor ODTWriteNode in ODTWrites:\n    masterNode.knob('inverseMode').setValue(False)\n    bakeCandidateLUTfromNode(ODTWriteNode)\n    masterNode.knob('inverseMode').setValue(True)\n    bakeCandidateLUTfromNode(ODTWriteNode, inverse=True)\n\n\n\n\n## flip flag back to nukescript makes more sense when opened afterwards\nmasterNode.knob('inverseMode').setValue(False)\n\n\n\n\n# createOCIOconfigs(revision)\ncreateOCIOconfigs(nuke.thisNode().knob('revision').getValue())" +STARTLINE}
 addUserKnob {6 bakeLUTs +STARTLINE}
 bakeLUTs true
 addUserKnob {26 ""}
 addUserKnob {6 inverseMode +STARTLINE}
}
